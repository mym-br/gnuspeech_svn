


CSH(1)              UNIX Programmer's Manual               CSH(1)



NAME
     csh - a shell (command interpreter) with C-like syntax

SYNOPSIS
     csh [ -cefinstvVxX ] [ arg ...  ]

DESCRIPTION
     _C_s_h is a first implementation of a command language inter-
     preter incorporating a history mechanism (see History Sub-
     stitutions), job control facilities (see Jobs), interactive
     file name and user name completion (see File Name Comple-
     tion), and a C-like syntax.  So as to be able to use its job
     control facilities, users of _c_s_h must (and automatically)
     use the new tty driver fully described in _t_t_y(4).  This new
     tty driver allows generation of interrupt characters from
     the keyboard to tell jobs to stop.  See _s_t_t_y(1) for details
     on setting options in the new tty driver.

     An instance of _c_s_h begins by executing commands from the
     file `.cshrc' in the _h_o_m_e directory of the invoker.  If this
     is a login shell then it also executes commands from the
     file `.login' there.  It is typical for users on crt's to
     put the command ``stty crt'' in their ._l_o_g_i_n file, and to
     also invoke _t_s_e_t(1) there.

     In the normal case, the shell will then begin reading com-
     mands from the terminal, prompting with `% '.  Processing of
     arguments and the use of the shell to process files contain-
     ing command scripts will be described later.

     The shell then repeatedly performs the following actions: a
     line of command input is read and broken into _w_o_r_d_s.  This
     sequence of words is placed on the command history list and
     then parsed.  Finally each command in the current line is
     executed.

     When a login shell terminates it executes commands from the
     file `.logout' in the users home directory.

     Lexical structure

     The shell splits input lines into words at blanks and tabs
     with the following exceptions.  The characters `&' `|' `;'
     `<' `>' `(' `)' form separate words.  If doubled in `&&',
     `||', `<<' or `>>' these pairs form single words.  These
     parser metacharacters may be made part of other words, or
     prevented their special meaning, by preceding them with `\'.
     A newline preceded by a `\' is equivalent to a blank.

     In addition strings enclosed in matched pairs of quotations,
     `'', ``' or `"', form parts of a word; metacharacters in
     these strings, including blanks and tabs, do not form
     separate words.  These quotations have semantics to be
     described subsequently.  Within pairs of `'' or `"' charac-
     ters a newline preceded by a `\' gives a true newline char-
     acter.

     When the shell's input is not a terminal, the character `#'
     introduces a comment which continues to the end of the input
     line.  It is prevented this special meaning when preceded by
     `\' and in quotations using ``', `'', and `"'.

     Commands

     A simple command is a sequence of words, the first of which
     specifies the command to be executed.  A simple command or a
     sequence of simple commands separated by `|' characters
     forms a pipeline.  The output of each command in a pipeline
     is connected to the input of the next.  Sequences of pipe-
     lines may be separated by `;', and are then executed sequen-
     tially.  A sequence of pipelines may be executed without
     immediately waiting for it to terminate by following it with
     an `&'.

     Any of the above may be placed in `(' `)' to form a simple
     command (which may be a component of a pipeline, etc.) It is
     also possible to separate pipelines with `||' or `&&' indi-
     cating, as in the C language, that the second is to be exe-
     cuted only if the first fails or succeeds respectively. (See
     _E_x_p_r_e_s_s_i_o_n_s.)

     Jobs

     The shell associates a _j_o_b with each pipeline.  It keeps a
     table of current jobs, printed by the _j_o_b_s command, and
     assigns them small integer numbers.  When a job is started
     asynchronously with `&', the shell prints a line which looks
     like:

          [1] 1234

     indicating that the job which was started asynchronously was
     job number 1 and had one (top-level) process, whose process
     id was 1234.

     If you are running a job and wish to do something else you
     may hit the key ^Z (control-Z) which sends a STOP signal to
     the current job.  The shell will then normally indicate that
     the job has been `Stopped', and print another prompt.  You
     can then manipulate the state of this job, putting it in the
     background with the _b_g command, or run some other commands
     and then eventually bring the job back into the foreground
     with the foreground command _f_g.  A ^Z takes effect immedi-
     ately and is like an interrupt in that pending output and
     unread input are discarded when it is typed.  There is
     another special key ^Y which does not generate a STOP signal
     until a program attempts to _r_e_a_d(2) it.  This can usefully
     be typed ahead when you have prepared some commands for a
     job which you wish to stop after it has read them.

     A job being run in the background will stop if it tries to
     read from the terminal.  Background jobs are normally
     allowed to produce output, but this can be disabled by giv-
     ing the command ``stty tostop''.  If you set this tty
     option, then background jobs will stop when they try to pro-
     duce output like they do when they try to read input.


     There are several ways to refer to jobs in the shell.  The
     character `%' introduces a job name.  If you wish to refer
     to job number 1, you can name it as `%1'.  Just naming a job
     brings it to the foreground; thus `%1' is a synonym for `fg
     %1', bringing job 1 back into the foreground.  Similarly
     saying `%1 &' resumes job 1 in the background.  Jobs can
     also be named by prefixes of the string typed in to start
     them, if these prefixes are unambiguous, thus `%ex' would
     normally restart a suspended _e_x(1) job, if there were only
     one suspended job whose name began with the string `ex'.  It
     is also possible to say `%?string' which specifies a job
     whose text contains _s_t_r_i_n_g, if there is only one such job.

     The shell maintains a notion of the current and previous
     jobs.  In output pertaining to jobs, the current job is
     marked with a `+' and the previous job with a `-'.  The
     abbreviation `%+' refers to the current job and `%-' refers
     to the previous job.  For close analogy with the syntax of
     the _h_i_s_t_o_r_y mechanism (described below), `%%' is also a
     synonym for the current job.

     Status reporting

     This shell learns immediately whenever a process changes
     state.  It normally informs you whenever a job becomes
     blocked so that no further progress is possible, but only
     just before it prints a prompt.  This is done so that it
     does not otherwise disturb your work.  If, however, you set
     the shell variable _n_o_t_i_f_y, the shell will notify you immedi-
     ately of changes of status in background jobs.  There is
     also a shell command _n_o_t_i_f_y which marks a single process so
     that its status changes will be immediately reported.  By
     default _n_o_t_i_f_y marks the current process; simply say
     `notify' after starting a background job to mark it.

     When you try to leave the shell while jobs are stopped, you
     will be warned that `You have stopped jobs.'  You may use
     the _j_o_b_s command to see what they are.  If you do this or
     immediately try to exit again, the shell will not warn you a
     second time, and the suspended jobs will be terminated.

     File Name Completion

     When the file name completion feature is enabled by setting
     the shell variable _f_i_l_e_c (see set), _c_s_h will interactively
     complete file names and user names from unique prefixes,
     when they are input from the terminal followed by the escape
     character (the escape key, or control-[).  For example, if
     the current directory looks like
               DSC.OLD   bin       cmd       lib       xmpl.c
               DSC.NEW   chaosnet  cmtest    mail      xmpl.o
               bench     class     dev       mbox      xmpl.out
     and the input is
               % vi ch<escape>
     _c_s_h will complete the prefix ``ch'' to the only matching
     file name ``chaosnet'', changing the input line to
               % vi chaosnet
     However, given
               % vi D<escape>
     _c_s_h will only expand the input to
               % vi DSC.
     and will sound the terminal bell to indicate that the expan-
     sion is incomplete, since there are two file names matching
     the prefix ``D''.


     If a partial file name is followed by the end-of-file char-
     acter (usually control-D), then, instead of completing the
     name, _c_s_h will list all file names matching the prefix.  For
     example, the input
               % vi D<control-D>
     causes all files beginning with ``D'' to be listed:
               DSC.NEW   DSC.OLD
     while the input line remains unchanged.

     The same system of escape and end-of-file can also be used
     to expand partial user names, if the word to be completed
     (or listed) begins with the character ``~''.  For example,
     typing
               cd ~ro<control-D>
     may produce the expansion
               cd ~root

     The use of the terminal bell to signal errors or multiple
     matches can be inhibited by setting the variable _n_o_b_e_e_p.

     Normally, all files in the particular directory are candi-
     dates for name completion.  Files with certain suffixes can
     be excluded from consideration by setting the variable _f_i_g_-
     _n_o_r_e to the list of suffixes to be ignored.  Thus, if _f_i_g_-
     _n_o_r_e is set by the command
               % set fignore = (.o .out)
     then typing
               % vi x<escape>
     would result in the completion to
               % vi xmpl.c
     ignoring the files "xmpl.o" and "xmpl.out".  However, if the
     only completion possible requires not ignoring these suf-
     fixes, then they are not ignored.  In addition, _f_i_g_n_o_r_e does
     not affect the listing of file names by control-D.  All
     files are listed regardless of their suffixes.

     Substitutions

     We now describe the various transformations the shell per-
     forms on the input in the order in which they occur.

     History substitutions

     History substitutions place words from previous command
     input as portions of new commands, making it easy to repeat
     commands, repeat arguments of a previous command in the
     current command, or fix spelling mistakes in the previous
     command with little typing and a high degree of confidence.
     History substitutions begin with the character `!' and may
     begin anywhere in the input stream (with the proviso that
     they do not nest.) This `!' may be preceded by an `\' to
     prevent its special meaning; for convenience, a `!' is
     passed unchanged when it is followed by a blank, tab, new-
     line, `=' or `('.  (History substitutions also occur when an
     input line begins with `^'.  This special abbreviation will
     be described later.) Any input line which contains history
     substitution is echoed on the terminal before it is executed
     as it could have been typed without history substitution.

     Commands input from the terminal which consist of one or
     more words are saved on the history list.  The history sub-
     stitutions reintroduce sequences of words from these saved
     commands into the input stream.  The size of which is con-
     trolled by the _h_i_s_t_o_r_y variable; the previous command is
     always retained, regardless of its value.  Commands are num-
     bered sequentially from 1.

     For definiteness, consider the following output from the
     _h_i_s_t_o_r_y command:

           9  write michael
          10  ex write.c
          11  cat oldwrite.c
          12  diff *write.c

     The commands are shown with their event numbers.  It is not
     usually necessary to use event numbers, but the current
     event number can be made part of the _p_r_o_m_p_t by placing an
     `!' in the prompt string.

     With the current event 13 we can refer to previous events by
     event number `!11', relatively as in `!-2' (referring to the
     same event), by a prefix of a command word as in `!d' for
     event 12 or `!wri' for event 9, or by a string contained in
     a word in the command as in `!?mic?' also referring to event
     9.  These forms, without further modification, simply rein-
     troduce the words of the specified events, each separated by
     a single blank.  As a special case `!!' refers to the previ-
     ous command; thus `!!' alone is essentially a _r_e_d_o.

     To select words from an event we can follow the event
     specification by a `:' and a designator for the desired
     words.  The words of an input line are numbered from 0, the
     first (usually command) word being 0, the second word (first
     argument) being 1, etc.  The basic word designators are:

          0    first (command) word
          _n    _n'th argument
          ^    first argument,  i.e. `1'
          $    last argument
          %    word matched by (immediately preceding) ?_s? search
          _x-_y  range of words
          -_y   abbreviates `0-_y'
          *    abbreviates `^-$', or nothing if only 1 word in event
          _x*   abbreviates `_x-$'
          _x-   like `_x*' but omitting word `$'

     The `:' separating the event specification from the word
     designator can be omitted if the argument selector begins
     with a `^', `$', `*' `-' or `%'.  After the optional word
     designator can be placed a sequence of modifiers, each pre-
     ceded by a `:'.  The following modifiers are defined:

          h      Remove a trailing pathname component, leaving the head.
          r      Remove a trailing `.xxx' component, leaving the root name.
          e      Remove all but the extension `.xxx' part.
          s/_l/_r/ Substitute _l for _r
          t      Remove all leading pathname components, leaving the tail.
          &      Repeat the previous substitution.
          g      Apply the change globally, prefixing the above, e.g. `g&'.
          p      Print the new command but do not execute it.
          q      Quote the substituted words, preventing further substitutions.
          x      Like q, but break into words at blanks, tabs and newlines.

     Unless preceded by a `g' the modification is applied only to
     the first modifiable word.  With substitutions, it is an
     error for no word to be applicable.

     The left hand side of substitutions are not regular expres-
     sions in the sense of the editors, but rather strings.  Any
     character may be used as the delimiter in place of `/'; a
     `\' quotes the delimiter into the _l and _r strings.  The
     character `&' in the right hand side is replaced by the text
     from the left.  A `\' quotes `&' also.  A null _l uses the
     previous string either from a _l or from a contextual scan
     string _s in `!?_s?'.  The trailing delimiter in the substitu-
     tion may be omitted if a newline follows immediately as may
     the trailing `?' in a contextual scan.

     A history reference may be given without an event specifica-
     tion, e.g. `!$'.  In this case the reference is to the pre-
     vious command unless a previous history reference occurred
     on the same line in which case this form repeats the previ-
     ous reference.  Thus `!?foo?^ !$' gives the first and last
     arguments from the command matching `?foo?'.

     A special abbreviation of a history reference occurs when
     the first non-blank character of an input line is a `^'.
     This is equivalent to `!:s^' providing a convenient short-
     hand for substitutions on the text of the previous line.
     Thus `^lb^lib' fixes the spelling of `lib' in the previous
     command.  Finally, a history substitution may be surrounded
     with `{' and `}' if necessary to insulate it from the char-
     acters which follow.  Thus, after `ls -ld ~paul' we might do
     `!{l}a' to do `ls -ld ~paula', while `!la' would look for a
     command starting `la'.

     Quotations with ' and "

     The quotation of strings by `'' and `"' can be used to
     prevent all or some of the remaining substitutions.  Strings
     enclosed in `'' are prevented any further interpretation.
     Strings enclosed in `"' may be expanded as described below.

     In both cases the resulting text becomes (all or part of) a
     single word; only in one special case (see _C_o_m_m_a_n_d _S_u_b_s_t_i_t_i_-
     _t_i_o_n below) does a `"' quoted string yield parts of more
     than one word; `'' quoted strings never do.

     Alias substitution

     The shell maintains a list of aliases which can be esta-
     blished, displayed and modified by the _a_l_i_a_s and _u_n_a_l_i_a_s
     commands.  After a command line is scanned, it is parsed
     into distinct commands and the first word of each command,
     left-to-right, is checked to see if it has an alias.  If it
     does, then the text which is the alias for that command is
     reread with the history mechanism available as though that
     command were the previous input line.  The resulting words
     replace the command and argument list.  If no reference is
     made to the history list, then the argument list is left
     unchanged.

     Thus if the alias for `ls' is `ls -l' the command `ls /usr'
     would map to `ls -l /usr', the argument list here being
     undisturbed.  Similarly if the alias for `lookup' was `grep
     !^ /etc/passwd' then `lookup bill' would map to `grep bill
     /etc/passwd'.

     If an alias is found, the word transformation of the input
     text is performed and the aliasing process begins again on
     the reformed input line.  Looping is prevented if the first
     word of the new text is the same as the old by flagging it
     to prevent further aliasing.  Other loops are detected and
     cause an error.

     Note that the mechanism allows aliases to introduce parser
     metasyntax.  Thus we can `alias print 'pr \!* | lpr'' to
     make a command which _p_r'_s its arguments to the line printer.

     Variable substitution

     The shell maintains a set of variables, each of which has as
     value a list of zero or more words.  Some of these variables
     are set by the shell or referred to by it.  For instance,
     the _a_r_g_v variable is an image of the shell's argument list,
     and words of this variable's value are referred to in spe-
     cial ways.

     The values of variables may be displayed and changed by
     using the _s_e_t and _u_n_s_e_t commands.  Of the variables referred
     to by the shell a number are toggles; the shell does not
     care what their value is, only whether they are set or not.
     For instance, the _v_e_r_b_o_s_e variable is a toggle which causes
     command input to be echoed.  The setting of this variable
     results from the -v command line option.

     Other operations treat variables numerically.  The `@' com-
     mand permits numeric calculations to be performed and the
     result assigned to a variable.  Variable values are, how-
     ever, always represented as (zero or more) strings.  For the
     purposes of numeric operations, the null string is con-
     sidered to be zero, and the second and subsequent words of
     multiword values are ignored.

     After the input line is aliased and parsed, and before each
     command is executed, variable substitution is performed
     keyed by `$' characters.  This expansion can be prevented by
     preceding the `$' with a `\' except within `"'s where it
     always occurs, and within `''s where it never occurs.
     Strings quoted by ``' are interpreted later (see _C_o_m_m_a_n_d
     _s_u_b_s_t_i_t_u_t_i_o_n below) so `$' substitution does not occur there
     until later, if at all.  A `$' is passed unchanged if fol-
     lowed by a blank, tab, or end-of-line.

     Input/output redirections are recognized before variable
     expansion, and are variable expanded separately.  Otherwise,
     the command name and entire argument list are expanded
     together.  It is thus possible for the first (command) word
     to this point to generate more than one word, the first of
     which becomes the command name, and the rest of which become
     arguments.

     Unless enclosed in `"' or given the `:q' modifier the
     results of variable substitution may eventually be command
     and filename substituted.  Within `"', a variable whose
     value consists of multiple words expands to a (portion of) a
     single word, with the words of the variables value separated
     by blanks.  When the `:q' modifier is applied to a substitu-
     tion the variable will expand to multiple words with each
     word separated by a blank and quoted to prevent later com-
     mand or filename substitution.

     The following metasequences are provided for introducing
     variable values into the shell input.  Except as noted, it
     is an error to reference a variable which is not set.

     $name
     ${name}
          Are replaced by the words of the value of variable
          _n_a_m_e, each separated by a blank.  Braces insulate _n_a_m_e
          from following characters which would otherwise be part
          of it.  Shell variables have names consisting of up to
          20 letters and digits starting with a letter.  The
          underscore character is considered a letter.
          If _n_a_m_e is not a shell variable, but is set in the
          environment, then that value is returned (but : modif-
          iers and the other forms given below are not available
          in this case).


     $name[selector]
     ${name[selector]}
          May be used to select only some of the words from the
          value of _n_a_m_e. The selector is subjected to `$' substi-
          tution and may consist of a single number or two
          numbers separated by a `-'.  The first word of a vari-
          ables value is numbered `1'.  If the first number of a
          range is omitted it defaults to `1'.  If the last
          member of a range is omitted it defaults to `$#name'.
          The selector `*' selects all words.  It is not an error
          for a range to be empty if the second argument is omit-
          ted or in range.

     $#name
     ${#name}
          Gives the number of words in the variable.  This is
          useful for later use in a `[selector]'.

     $0
          Substitutes the name of the file from which command
          input is being read.  An error occurs if the name is
          not known.

     $number
     ${number}
          Equivalent to `$argv[number]'.

     $*
          Equivalent to `$argv[*]'.

     The modifiers `:h', `:t', `:r', `:q' and `:x' may be applied
     to the substitutions above as may `:gh', `:gt' and `:gr'.
     If braces `{' '}' appear in the command form then the modif-
     iers must appear within the braces.  The current implementa-
     tion allows only one `:' modifier on each `$' expansion.

     The following substitutions may not be modified with `:'
     modifiers.

     $?name
     ${?name}
          Substitutes the string `1' if name is set, `0' if it is
          not.

     $?0
          Substitutes `1' if the current input filename is known,
          `0' if it is not.

     $$
          Substitute the (decimal) process number of the (parent)
          shell.

     $<
          Substitutes a line from the standard input, with no
          further interpretation thereafter.  It can be used to
          read from the keyboard in a shell script.




     Command and filename substitution

     The remaining substitutions, command and filename substitu-
     tion, are applied selectively to the arguments of builtin
     commands.  This means that portions of expressions which are
     not evaluated are not subjected to these expansions.  For
     commands which are not internal to the shell, the command
     name is substituted separately from the argument list.  This
     occurs very late, after input-output redirection is per-
     formed, and in a child of the main shell.

     Command substitution

     Command substitution is indicated by a command enclosed in
     ``'.  The output from such a command is normally broken into
     separate words at blanks, tabs and newlines, with null words
     being discarded, this text then replacing the original
     string.  Within `"'s, only newlines force new words; blanks
     and tabs are preserved.

     In any case, the single final newline does not force a new
     word.  Note that it is thus possible for a command substitu-
     tion to yield only part of a word, even if the command out-
     puts a complete line.

     Filename substitution

     If a word contains any of the characters `*', `?', `[' or
     `{' or begins with the character `~', then that word is a
     candidate for filename substitution, also known as `glob-
     bing'.  This word is then regarded as a pattern, and
     replaced with an alphabetically sorted list of file names
     which match the pattern.  In a list of words specifying
     filename substitution it is an error for no pattern to match
     an existing file name, but it is not required for each pat-
     tern to match.  Only the metacharacters `*', `?' and `['
     imply pattern matching, the characters `~' and `{' being
     more akin to abbreviations.

     In matching filenames, the character `.' at the beginning of
     a filename or immediately following a `/', as well as the
     character `/' must be matched explicitly.  The character `*'
     matches any string of characters, including the null string.
     The character `?' matches any single character.  The
     sequence `[...]' matches any one of the characters enclosed.
     Within `[...]', a pair of characters separated by `-'
     matches any character lexically between the two.

     The character `~' at the beginning of a filename is used to
     refer to home directories.  Standing alone, i.e. `~' it
     expands to the invokers home directory as reflected in the
     value of the variable _h_o_m_e. When followed by a name consist-
     ing of letters, digits and `-' characters the shell searches
     for a user with that name and substitutes their home direc-
     tory;  thus `~ken' might expand to `/usr/ken' and
     `~ken/chmach' to `/usr/ken/chmach'.  If the character `~' is
     followed by a character other than a letter or `/' or
     appears not at the beginning of a word, it is left undis-
     turbed.

     The metanotation `a{b,c,d}e' is a shorthand for `abe ace
     ade'.  Left to right order is preserved, with results of
     matches being sorted separately at a low level to preserve
     this order.  This construct may be nested.  Thus
     `~source/s1/{oldls,ls}.c' expands to `/usr/source/s1/oldls.c
     /usr/source/s1/ls.c' whether or not these files exist
     without any chance of error if the home directory for
     `source' is `/usr/source'.  Similarly `../{memo,*box}' might
     expand to `../memo ../box ../mbox'.  (Note that `memo' was
     not sorted with the results of matching `*box'.) As a spe-
     cial case `{', `}' and `{}' are passed undisturbed.


     Input/output

     The standard input and standard output of a command may be
     redirected with the following syntax:

     < name
          Open file _n_a_m_e (which is first variable, command and
          filename expanded) as the standard input.

     << word
          Read the shell input up to a line which is identical to
          _w_o_r_d. _W_o_r_d is not subjected to variable, filename or
          command substitution, and each input line is compared
          to _w_o_r_d before any substitutions are done on this input
          line.  Unless a quoting `\', `"', `'' or ``' appears in
          _w_o_r_d variable and command substitution is performed on
          the intervening lines, allowing `\' to quote `$', `\'
          and ``'.  Commands which are substituted have all
          blanks, tabs, and newlines preserved, except for the
          final newline which is dropped.  The resultant text is
          placed in an anonymous temporary file which is given to
          the command as standard input.

     > name
     >! name
     >& name
     >&! name
          The file _n_a_m_e is used as standard output.  If the file
          does not exist then it is created; if the file exists,
          its is truncated, its previous contents being lost.

          If the variable _n_o_c_l_o_b_b_e_r is set, then the file must
          not exist or be a character special file (e.g. a termi-
          nal or `/dev/null') or an error results.  This helps
          prevent accidental destruction of files.  In this case
          the `!' forms can be used and suppress this check.

          The forms involving `&' route the diagnostic output
          into the specified file as well as the standard output.
          _N_a_m_e is expanded in the same way as `<' input filenames
          are.

     >> name
     >>& name
     >>! name
     >>&! name
          Uses file _n_a_m_e as standard output like `>' but places
          output at the end of the file.  If the variable
          _n_o_c_l_o_b_b_e_r is set, then it is an error for the file not
          to exist unless one of the `!' forms is given.  Other-
          wise similar to `>'.

     A command receives the environment in which the shell was
     invoked as modified by the input-output parameters and the
     presence of the command in a pipeline.  Thus, unlike some
     previous shells, commands run from a file of shell commands
     have no access to the text of the commands by default;
     rather they receive the original standard input of the
     shell.  The `<<' mechanism should be used to present inline
     data.  This permits shell command scripts to function as
     components of pipelines and allows the shell to block read
     its input.  Note that the default standard input for a com-
     mand run detached is not modified to be the empty file
     `/dev/null'; rather the standard input remains as the origi-
     nal standard input of the shell.  If this is a terminal and
     if the process attempts to read from the terminal, then the
     process will block and the user will be notified (see Jobs
     above).

     Diagnostic output may be directed through a pipe with the
     standard output.  Simply use the form `|&' rather than just
     `|'.

     Expressions

     A number of the builtin commands (to be described subse-
     quently) take expressions, in which the operators are simi-
     lar to those of C, with the same precedence.  These expres-
     sions appear in the @, _e_x_i_t, _i_f, and _w_h_i_l_e commands.  The
     following operators are available:

          ||  &&  |  ^  &  ==  !=  =~  !~  <=  >=  <  >  <<  >>
     +  -  *  /  %  !  ~  (  )

     Here the precedence increases to the right, `==' `!=' `=~'
     and `!~', `<=' `>=' `<' and `>', `<<' and `>>', `+' and `-',
     `*' `/' and `%' being, in groups, at the same level.  The
     `==' `!=' `=~' and `!~' operators compare their arguments as
     strings; all others operate on numbers.  The operators `=~'
     and `!~' are like `!=' and `==' except that the right hand
     side is a _p_a_t_t_e_r_n (containing, e.g. `*'s, `?'s and instances
     of `[...]') against which the left hand operand is matched.
     This reduces the need for use of the _s_w_i_t_c_h statement in
     shell scripts when all that is really needed is pattern
     matching.

     Strings which begin with `0' are considered octal numbers.
     Null or missing arguments are considered `0'.  The result of
     all expressions are strings, which represent decimal
     numbers.  It is important to note that no two components of
     an expression can appear in the same word; except when adja-
     cent to components of expressions which are syntactically
     significant to the parser (`&' `|' `<' `>' `(' `)') they
     should be surrounded by spaces.

     Also available in expressions as primitive operands are com-
     mand executions enclosed in `{' and `}' and file enquiries
     of the form `-_l  name' where _l is one of:

          r    read access
          w    write access
          x    execute access
          e    existence
          o    ownership
          z    zero size
          f    plain file
          d    directory

     The specified name is command and filename expanded and then
     tested to see if it has the specified relationship to the
     real user.  If the file does not exist or is inaccessible
     then all enquiries return false, i.e. `0'.  Command execu-
     tions succeed, returning true, i.e. `1', if the command
     exits with status 0, otherwise they fail, returning false,
     i.e. `0'.  If more detailed status information is required
     then the command should be executed outside of an expression
     and the variable _s_t_a_t_u_s examined.





     Control flow

     The shell contains a number of commands which can be used to
     regulate the flow of control in command files (shell
     scripts) and (in limited but useful ways) from terminal
     input.  These commands all operate by forcing the shell to
     reread or skip in its input and, due to the implementation,
     restrict the placement of some of the commands.

     The _f_o_r_e_a_c_h, _s_w_i_t_c_h, and _w_h_i_l_e statements, as well as the
     _i_f-_t_h_e_n-_e_l_s_e form of the _i_f statement require that the major
     keywords appear in a single simple command on an input line
     as shown below.

     If the shell's input is not seekable, the shell buffers up
     input whenever a loop is being read and performs seeks in
     this internal buffer to accomplish the rereading implied by
     the loop.  (To the extent that this allows, backward goto's
     will succeed on non-seekable inputs.)

     Builtin commands

     Builtin commands are executed within the shell.  If a buil-
     tin command occurs as any component of a pipeline except the
     last then it is executed in a subshell.

     alias
     alias name
     alias name wordlist
          The first form prints all aliases.  The second form
          prints the alias for name.  The final form assigns the
          specified _w_o_r_d_l_i_s_t as the alias of _n_a_m_e; _w_o_r_d_l_i_s_t is
          command and filename substituted.  _N_a_m_e is not allowed
          to be _a_l_i_a_s or _u_n_a_l_i_a_s.

     alloc
          Shows the amount of dynamic memory acquired, broken
          down into used and free memory.  With an argument shows
          the number of free and used blocks in each size
          category.  The categories start at size 8 and double at
          each step.  This command's output may vary across sys-
          tem types, since different systems may use a different
          memory allocator.

     bg
     bg %job ...
          Puts the current or specified jobs into the background,
          continuing them if they were stopped.

     break
          Causes execution to resume after the _e_n_d of the nearest
          enclosing _f_o_r_e_a_c_h or _w_h_i_l_e. The remaining commands on
          the current line are executed.  Multi-level breaks are
          thus possible by writing them all on one line.

     breaksw
          Causes a break from a _s_w_i_t_c_h, resuming after the _e_n_d_s_w.

     case label:
          A label in a _s_w_i_t_c_h statement as discussed below.

     cd
     cd name
     chdir

     chdir name
          Change the shell's working directory to directory _n_a_m_e.
          If no argument is given then change to the home direc-
          tory of the user.
          If _n_a_m_e is not found as a subdirectory of the current
          directory (and does not begin with `/', `./' or `../'),
          then each component of the variable _c_d_p_a_t_h is checked
          to see if it has a subdirectory _n_a_m_e. Finally, if all
          else fails but _n_a_m_e is a shell variable whose value
          begins with `/', then this is tried to see if it is a
          directory.

     continue
          Continue execution of the nearest enclosing _w_h_i_l_e or
          _f_o_r_e_a_c_h. The rest of the commands on the current line
          are executed.

     default:
          Labels the default case in a _s_w_i_t_c_h statement.  The
          default should come after all _c_a_s_e labels.

     dirs
          Prints the directory stack; the top of the stack is at
          the left, the first directory in the stack being the
          current directory.

     echo wordlist
     echo -n wordlist
          The specified words are written to the shells standard
          output, separated by spaces, and terminated with a new-
          line unless the -n option is specified.

     else
     end
     endif
     endsw
          See the description of the _f_o_r_e_a_c_h, _i_f, _s_w_i_t_c_h, and
          _w_h_i_l_e statements below.

     eval arg ...
          (As in _s_h(1).) The arguments are read as input to the
          shell and the resulting command(s) executed in the con-
          text of the current shell.  This is usually used to
          execute commands generated as the result of command or
          variable substitution, since parsing occurs before
          these substitutions.  See _t_s_e_t(1) for an example of
          using _e_v_a_l.

     exec command
          The specified command is executed in place of the
          current shell.

     exit
     exit(expr)
          The shell exits either with the value of the _s_t_a_t_u_s
          variable (first form) or with the value of the speci-
          fied _e_x_p_r (second form).


     fg
     fg %job ...
          Brings the current or specified jobs into the fore-
          ground, continuing them if they were stopped.

     foreach name (wordlist)

         ...
     end
          The variable _n_a_m_e is successively set to each member of
          _w_o_r_d_l_i_s_t and the sequence of commands between this com-
          mand and the matching _e_n_d are executed.  (Both _f_o_r_e_a_c_h
          and _e_n_d must appear alone on separate lines.)

          The builtin command _c_o_n_t_i_n_u_e may be used to continue
          the loop prematurely and the builtin command _b_r_e_a_k to
          terminate it prematurely.  When this command is read
          from the terminal, the loop is read up once prompting
          with `?' before any statements in the loop are exe-
          cuted.  If you make a mistake typing in a loop at the
          terminal you can rub it out.

     glob wordlist
          Like _e_c_h_o but no `\' escapes are recognized and words
          are delimited by null characters in the output.  Useful
          for programs which wish to use the shell to filename
          expand a list of words.

     goto word
          The specified _w_o_r_d is filename and command expanded to
          yield a string of the form `label'.  The shell rewinds
          its input as much as possible and searches for a line
          of the form `label:' possibly preceded by blanks or
          tabs.  Execution continues after the specified line.

     hashstat
          Print a statistics line indicating how effective the
          internal hash table has been at locating commands (and
          avoiding _e_x_e_c's).  An _e_x_e_c is attempted for each com-
          ponent of the _p_a_t_h where the hash function indicates a
          possible hit, and in each component which does not
          begin with a `/'.

     history
     history _n
     history -r _n
     history -h _n
          Displays the history event list; if _n is given only the
          _n most recent events are printed.  The -r option rev-
          erses the order of printout to be most recent first
          rather than oldest first.  The -h option causes the
          history list to be printed without leading numbers.
          This is used to produce files suitable for sourceing
          using the -h option to _s_o_u_r_c_e.

     if (expr) command
          If the specified expression evaluates true, then the
          single _c_o_m_m_a_n_d with arguments is executed.  Variable
          substitution on _c_o_m_m_a_n_d happens early, at the same time
          it does for the rest of the _i_f command.  _C_o_m_m_a_n_d must
          be a simple command, not a pipeline, a command list, or
          a parenthesized command list.  Input/output redirection
          occurs even if _e_x_p_r is false, when command is not exe-
          cuted (this is a bug).


     if (expr) then
         ...
     else if (expr2) then
         ...
     else
         ...

     endif
          If the specified _e_x_p_r is true then the commands to the
          first _e_l_s_e are executed; otherwise if _e_x_p_r_2 is true
          then the commands to the second _e_l_s_e are executed, etc.
          Any number of _e_l_s_e-_i_f pairs are possible; only one
          _e_n_d_i_f is needed.  The _e_l_s_e part is likewise optional.
          (The words _e_l_s_e and _e_n_d_i_f must appear at the beginning
          of input lines; the _i_f must appear alone on its input
          line or after an _e_l_s_e.)

     jobs
     jobs -l
          Lists the active jobs; given the -l options lists pro-
          cess id's in addition to the normal information.

     kill %job
     kill -sig %job ...
     kill pid
     kill -sig pid ...
     kill -l
          Sends either the TERM (terminate) signal or the speci-
          fied signal to the specified jobs or processes.  Sig-
          nals are either given by number or by names (as given
          in /_u_s_r/_i_n_c_l_u_d_e/_s_i_g_n_a_l._h, stripped of the prefix
          ``SIG'').  The signal names are listed by ``kill -l''.
          There is no default, saying just `kill' does not send a
          signal to the current job.  If the signal being sent is
          TERM (terminate) or HUP (hangup), then the job or pro-
          cess will be sent a CONT (continue) signal as well.

     limit
     limit _r_e_s_o_u_r_c_e
     limit _r_e_s_o_u_r_c_e _m_a_x_i_m_u_m-_u_s_e
     limit -h
     limit -h _r_e_s_o_u_r_c_e
     limit -h _r_e_s_o_u_r_c_e _m_a_x_i_m_u_m-_u_s_e
          Limits the consumption by the current process and each
          process it creates to not individually exceed _m_a_x_i_m_u_m-
          _u_s_e on the specified _r_e_s_o_u_r_c_e.  If no _m_a_x_i_m_u_m-_u_s_e is
          given, then the current limit is printed; if no
          _r_e_s_o_u_r_c_e is given, then all limitations are given.  If
          the -h flag is given, the hard limits are used instead
          of the current limits.  The hard limits impose a ceil-
          ing on the values of the current limits.  Only the
          super-user may raise the hard limits, but a user may
          lower or raise the current limits within the legal
          range.

          Resources controllable currently include _c_p_u_t_i_m_e (the
          maximum number of cpu-seconds to be used by each pro-
          cess), _f_i_l_e_s_i_z_e (the largest single file which can be
          created), _d_a_t_a_s_i_z_e (the maximum growth of the
          data+stack region via _s_b_r_k(2) beyond the end of the
          program text), _s_t_a_c_k_s_i_z_e (the maximum size of the
          automatically-extended stack region), and _c_o_r_e_d_u_m_p_s_i_z_e
          (the size of the largest core dump that will be
          created).

          The _m_a_x_i_m_u_m-_u_s_e may be given as a (floating point or
          integer) number followed by a scale factor.  For all
          limits other than _c_p_u_t_i_m_e the default scale is `k' or
          `kilobytes' (1024 bytes); a scale factor of `m' or
          `megabytes' may also be used.  For _c_p_u_t_i_m_e the default
          scaling is `seconds', while `m' for minutes or `h' for
          hours, or a time of the form `mm:ss' giving minutes and
          seconds may be used.

          For both _r_e_s_o_u_r_c_e names and scale factors, unambiguous
          prefixes of the names suffice.

     login
          Terminate a login shell, replacing it with an instance
          of /bin/login. This is one way to log off, included for
          compatibility with _s_h(1).

     logout
          Terminate a login shell.  Especially useful if
          _i_g_n_o_r_e_e_o_f is set.

     nice
     nice +number
     nice command
     nice +number command
          The first form sets the scheduling priority for this
          shell to 4.  The second form sets the priority to the
          given number.  The final two forms run command at
          priority 4 and _n_u_m_b_e_r respectively.  The greater the
          number, the less cpu the process will get.  The super-
          user may specify negative priority by using `nice
          -number ...'.  Command is always executed in a sub-
          shell, and the restrictions placed on commands in sim-
          ple _i_f statements apply.

     nohup
     nohup command
          The first form can be used in shell scripts to cause
          hangups to be ignored for the remainder of the script.
          The second form causes the specified command to be run
          with hangups ignored.  All processes detached with `&'
          are effectively _n_o_h_u_p'_e_d.

     notify
     notify %job ...
          Causes the shell to notify the user asynchronously when
          the status of the current or specified jobs changes;
          normally notification is presented before a prompt.
          This is automatic if the shell variable _n_o_t_i_f_y is set.

     onintr
     onintr  -
     onintr  label
          Control the action of the shell on interrupts.  The
          first form restores the default action of the shell on
          interrupts which is to terminate shell scripts or to
          return to the terminal command input level.  The second
          form `onintr -' causes all interrupts to be ignored.
          The final form causes the shell to execute a `goto
          label' when an interrupt is received or a child process
          terminates because it was interrupted.

          In any case, if the shell is running detached and
          interrupts are being ignored, all forms of _o_n_i_n_t_r have
          no meaning and interrupts continue to be ignored by the
          shell and all invoked commands.

     popd
     popd +n
          Pops the directory stack, returning to the new top
          directory.  With an argument `+_n' discards the _nth
          entry in the stack.  The elements of the directory
          stack are numbered from 0 starting at the top.

     pushd
     pushd name
     pushd +n
          With no arguments, _p_u_s_h_d exchanges the top two elements
          of the directory stack.  Given a _n_a_m_e argument, _p_u_s_h_d
          changes to the new directory (ala _c_d) and pushes the
          old current working directory (as in _c_s_w) onto the
          directory stack.  With a numeric argument, rotates the
          _nth argument of the directory stack around to be the
          top element and changes to it.  The members of the
          directory stack are numbered from the top starting at
          0.

     rehash
          Causes the internal hash table of the contents of the
          directories in the _p_a_t_h variable to be recomputed.
          This is needed if new commands are added to directories
          in the _p_a_t_h while you are logged in.  This should only
          be necessary if you add commands to one of your own
          directories, or if a systems programmer changes the
          contents of one of the system directories.

     repeat count command
          The specified _c_o_m_m_a_n_d which is subject to the same res-
          trictions as the _c_o_m_m_a_n_d in the one line _i_f statement
          above, is executed _c_o_u_n_t times.  I/O redirections occur
          exactly once, even if _c_o_u_n_t is 0.

     set
     set name
     set name=word
     set name[index]=word
     set name=(wordlist)
          The first form of the command shows the value of all
          shell variables.  Variables which have other than a
          single word as value print as a parenthesized word
          list.  The second form sets _n_a_m_e to the null string.
          The third form sets _n_a_m_e to the single _w_o_r_d. The fourth
          form sets the _i_n_d_e_x'_t_h component of name to word; this
          component must already exist.  The final form sets _n_a_m_e
          to the list of words in _w_o_r_d_l_i_s_t. In all cases the
          value is command and filename expanded.

          These arguments may be repeated to set multiple values
          in a single set command.  Note however, that variable
          expansion happens for all arguments before any setting
          occurs.

     setenv
     setenv name value
     setenv name
          The first form lists all current environment variables.
          The last form sets the value of environment variable
          _n_a_m_e to be _v_a_l_u_e, a single string.  The second form
          sets _n_a_m_e to an empty string.  The most commonly used
          environment variable USER, TERM, and PATH are automati-
          cally imported to and exported from the _c_s_h variables
          _u_s_e_r, _t_e_r_m, and _p_a_t_h; there is no need to use _s_e_t_e_n_v
          for these.

     shift
     shift variable
          The members of _a_r_g_v are shifted to the left, discarding
          _a_r_g_v[_1]. It is an error for _a_r_g_v not to be set or to
          have less than one word as value.  The second form per-
          forms the same function on the specified variable.

     source name
     source -h name
          The shell reads commands from _n_a_m_e. _S_o_u_r_c_e commands may
          be nested; if they are nested too deeply the shell may
          run out of file descriptors.  An error in a _s_o_u_r_c_e at
          any level terminates all nested _s_o_u_r_c_e commands.  Nor-
          mally input during _s_o_u_r_c_e commands is not placed on the
          history list; the -h option causes the commands to be
          placed in the history list without being executed.

     stop
     stop %job ...
          Stops the current or specified job which is executing
          in the background.

     suspend
          Causes the shell to stop in its tracks, much as if it
          had been sent a stop signal with ^Z.  This is most
          often used to stop shells started by _s_u(1).

     switch (string)
     case str1:
         ...
       breaksw
     ...
     default:
         ...
       breaksw
     endsw
          Each case label is successively matched, against the
          specified _s_t_r_i_n_g which is first command and filename
          expanded.  The file metacharacters `*', `?' and `[...]'
          may be used in the case labels, which are variable
          expanded.  If none of the labels match before a
          `default' label is found, then the execution begins
          after the default label.  Each case label and the
          default label must appear at the beginning of a line.
          The command _b_r_e_a_k_s_w causes execution to continue after
          the _e_n_d_s_w. Otherwise control may fall through case
          labels and default labels as in C.  If no label matches
          and there is no default, execution continues after the
          _e_n_d_s_w.

     time
     time command
          With no argument, a summary of time used by this shell
          and its children is printed.  If arguments are given
          the specified simple command is timed and a time sum-
          mary as described under the _t_i_m_e variable is printed.
          If necessary, an extra shell is created to print the
          time statistic when the command completes.

     umask
     umask value
          The file creation mask is displayed (first form) or set
          to the specified value (second form).  The mask is
          given in octal.  Common values for the mask are 002
          giving all access to the group and read and execute
          access to others or 022 giving all access except no
          write access for users in the group or others.

     unalias pattern
          All aliases whose names match the specified pattern are
          discarded.  Thus all aliases are removed by `unalias
          *'.  It is not an error for nothing to be _u_n_a_l_i_a_s_e_d.

     unhash
          Use of the internal hash table to speed location of
          executed programs is disabled.

     unlimit
     unlimit _r_e_s_o_u_r_c_e
     unlimit -h
     unlimit -h _r_e_s_o_u_r_c_e
          Removes the limitation on _r_e_s_o_u_r_c_e.  If no _r_e_s_o_u_r_c_e is
          specified, then all _r_e_s_o_u_r_c_e limitations are removed.
          If -h is given, the corresponding hard limits are
          removed.  Only the super-user may do this.

     unset pattern
          All variables whose names match the specified pattern
          are removed.  Thus all variables are removed by `unset
          *'; this has noticeably distasteful side-effects.  It
          is not an error for nothing to be _u_n_s_e_t.

     unsetenv pattern
          Removes all variables whose name match the specified
          pattern from the environment.  See also the _s_e_t_e_n_v com-
          mand above and _p_r_i_n_t_e_n_v(1).

     wait
          All background jobs are waited for.  It the shell is
          interactive, then an interrupt can disrupt the wait, at
          which time the shell prints names and job numbers of
          all jobs known to be outstanding.

     while (expr)
         ...
     end
          While the specified expression evaluates non-zero, the
          commands between the _w_h_i_l_e and the matching end are
          evaluated.  _B_r_e_a_k and _c_o_n_t_i_n_u_e may be used to terminate
          or continue the loop prematurely.  (The _w_h_i_l_e and _e_n_d
          must appear alone on their input lines.) Prompting
          occurs here the first time through the loop as for the
          _f_o_r_e_a_c_h statement if the input is a terminal.

     %job
          Brings the specified job into the foreground.

     %job &
          Continues the specified job in the background.

     @
     @ name = expr
     @ name[index] = expr
          The first form prints the values of all the shell vari-
          ables.  The second form sets the specified _n_a_m_e to the
          value of _e_x_p_r. If the expression contains `<', `>', `&'
          or `|' then at least this part of the expression must
          be placed within `(' `)'.  The third form assigns the
          value of _e_x_p_r to the _i_n_d_e_x'_t_h argument of _n_a_m_e. Both
          _n_a_m_e and its _i_n_d_e_x'_t_h component must already exist.

          The operators `*=', `+=', etc are available as in C.
          The space separating the name from the assignment
          operator is optional.  Spaces are, however, mandatory
          in separating components of _e_x_p_r which would otherwise
          be single words.

          Special postfix `++' and `--' operators increment and
          decrement _n_a_m_e respectively, i.e. `@  i++'.

     Pre-defined and environment variables

     The following variables have special meaning to the shell.
     Of these, _a_r_g_v, _c_w_d, _h_o_m_e, _p_a_t_h, _p_r_o_m_p_t, _s_h_e_l_l and _s_t_a_t_u_s
     are always set by the shell.  Except for _c_w_d and _s_t_a_t_u_s this
     setting occurs only at initialization; these variables will
     not then be modified unless this is done explicitly by the
     user.

     This shell copies the environment variable USER into the
     variable _u_s_e_r, TERM into _t_e_r_m, and HOME into _h_o_m_e, and
     copies these back into the environment whenever the normal
     shell variables are reset.  The environment variable PATH is
     likewise handled; it is not necessary to worry about its
     setting other than in the file ._c_s_h_r_c as inferior _c_s_h
     processes will import the definition of _p_a_t_h from the
     environment, and re-export it if you then change it.

     argv           Set to the arguments to the shell, it is from
                    this variable that positional parameters are
                    substituted, i.e. `$1' is replaced by
                    `$argv[1]', etc.

     cdpath         Gives a list of alternate directories
                    searched to find subdirectories in _c_h_d_i_r com-
                    mands.

     cwd            The full pathname of the current directory.

     echo           Set when the -x command line option is given.
                    Causes each command and its arguments to be
                    echoed just before it is executed.  For non-
                    builtin commands all expansions occur before
                    echoing.  Builtin commands are echoed before
                    command and filename substitution, since
                    these substitutions are then done selec-
                    tively.

     filec          Enable file name completion.

     histchars      Can be given a string value to change the
                    characters used in history substitution.  The
                    first character of its value is used as the
                    history substitution character, replacing the
                    default character !.  The second character of
                    its value replaces the character |^ in quick
                    substitutions.

     history        Can be given a numeric value to control the
                    size of the history list.  Any command which
                    has been referenced in this many events will
                    not be discarded.  Too large values of _h_i_s_-
                    _t_o_r_y may run the shell out of memory.  The
                    last executed command is always saved on the
                    history list.

     home           The home directory of the invoker,
                    initialized from the environment.  The
                    filename expansion of `~' refers to this
                    variable.

     ignoreeof      If set the shell ignores end-of-file from
                    input devices which are terminals.  This
                    prevents shells from accidentally being
                    killed by control-D's.

     mail           The files where the shell checks for mail.
                    This is done after each command completion
                    which will result in a prompt, if a specified
                    interval has elapsed.  The shell says `You
                    have new mail.' if the file exists with an
                    access time not greater than its modify time.

                    If the first word of the value of _m_a_i_l is
                    numeric it specifies a different mail check-
                    ing interval, in seconds, than the default,
                    which is 10 minutes.

                    If multiple mail files are specified, then
                    the shell says `New mail in _n_a_m_e' when there
                    is mail in the file _n_a_m_e.

     noclobber      As described in the section on _I_n_p_u_t/_o_u_t_p_u_t,
                    restrictions are placed on output redirection
                    to insure that files are not accidentally
                    destroyed, and that `>>' redirections refer
                    to existing files.

     noglob         If set, filename expansion is inhibited.
                    This is most useful in shell scripts which
                    are not dealing with filenames, or after a
                    list of filenames has been obtained and
                    further expansions are not desirable.

     nonomatch      If set, it is not an error for a filename
                    expansion to not match any existing files;
                    rather the primitive pattern is returned.  It
                    is still an error for the primitive pattern
                    to be malformed, i.e.  `echo [' still gives
                    an error.

     notify         If set, the shell notifies asynchronously of
                    job completions.  The default is to rather
                    present job completions just before printing
                    a prompt.

     path           Each word of the path variable specifies a
                    directory in which commands are to be sought
                    for execution.  A null word specifies the
                    current directory.  If there is no _p_a_t_h vari-
                    able then only full path names will execute.
                    The usual search path is `.', `/bin' and
                    `/usr/bin', but this may vary from system to
                    system.  For the super-user the default
                    search path is `/etc', `/bin' and `/usr/bin'.
                    A shell which is given neither the -c nor the
                    -t option will normally hash the contents of
                    the directories in the _p_a_t_h variable after
                    reading ._c_s_h_r_c, and each time the _p_a_t_h vari-
                    able is reset.  If new commands are added to
                    these directories while the shell is active,
                    it may be necessary to give the _r_e_h_a_s_h or the
                    commands may not be found.

     prompt         The string which is printed before each com-
                    mand is read from an interactive terminal
                    input.  If a `!' appears in the string it
                    will be replaced by the current event number
                    unless a preceding `\' is given.  Default is
                    `% ', or `# ' for the super-user.

     savehist       is given a numeric value to control the
                    number of entries of the history list that
                    are saved in ~/.history when the user logs
                    out.  Any command which has been referenced
                    in this many events will be saved.  During
                    start up the shell sources ~/.history into
                    the history list enabling history to be saved
                    across logins.  Too large values of _s_a_v_e_h_i_s_t
                    will slow down the shell during start up.

     shell          The file in which the shell resides.  This is
                    used in forking shells to interpret files
                    which have execute bits set, but which are
                    not executable by the system.  (See the
                    description of _N_o_n-_b_u_i_l_t_i_n _C_o_m_m_a_n_d _E_x_e_c_u_t_i_o_n
                    below.) Initialized to the (system-dependent)
                    home of the shell.

     status         The status returned by the last command.  If
                    it terminated abnormally, then 0200 is added
                    to the status.  Builtin commands which fail
                    return exit status `1', all other builtin
                    commands set status `0'.

     time           Controls automatic timing of commands.  If
                    set, then any command which takes more than
                    this many cpu seconds will cause a line giv-
                    ing user, system, and real times and a utili-
                    zation percentage which is the ratio of user
                    plus system times to real time to be printed
                    when it terminates.

     verbose        Set by the -v command line option, causes the
                    words of each command to be printed after
                    history substitution.

     Non-builtin command execution

     When a command to be executed is found to not be a builtin
     command the shell attempts to execute the command via
     _e_x_e_c_v_e(2).  Each word in the variable _p_a_t_h names a directory
     from which the shell will attempt to execute the command.
     If it is given neither a -c nor a -t option, the shell will
     hash the names in these directories into an internal table
     so that it will only try an _e_x_e_c in a directory if there is
     a possibility that the command resides there.  This greatly
     speeds command location when a large number of directories
     are present in the search path.  If this mechanism has been
     turned off (via _u_n_h_a_s_h), or if the shell was given a -c or
     -t argument, and in any case for each directory component of
     _p_a_t_h which does not begin with a `/', the shell concatenates
     with the given command name to form a path name of a file
     which it then attempts to execute.

     Parenthesized commands are always executed in a subshell.
     Thus `(cd ; pwd) ; pwd' prints the _h_o_m_e directory; leaving
     you where you were (printing this after the home directory),
     while `cd ; pwd' leaves you in the _h_o_m_e directory.
     Parenthesized commands are most often used to prevent _c_h_d_i_r
     from affecting the current shell.

     If the file has execute permissions but is not an executable
     binary to the system, then it is assumed to be a file con-
     taining shell commands and a new shell is spawned to read
     it.

     If there is an _a_l_i_a_s for _s_h_e_l_l then the words of the alias
     will be prepended to the argument list to form the shell
     command.  The first word of the _a_l_i_a_s should be the full
     path name of the shell (e.g. `$shell').  Note that this is a
     special, late occurring, case of _a_l_i_a_s substitution, and
     only allows words to be prepended to the argument list
     without modification.

     Argument list processing

     If argument 0 to the shell is `-' then this is a login
     shell.  The flag arguments are interpreted as follows:

     -b   This flag forces a ``break'' from option processing,
          causing any further shell arguments to be treated as
          non-option arguments.  The remaining arguments will not
          be interpreted as shell options.  This may be used to
          pass options to a shell script without confusion or
          possible subterfuge.  The shell will not run a set-user
          ID script without this option.

     -c   Commands are read from the (single) following argument
          which must be present.  Any remaining arguments are
          placed in _a_r_g_v.

     -e   The shell exits if any invoked command terminates
          abnormally or yields a non-zero exit status.

     -f   The shell will start faster, because it will neither
          search for nor execute commands from the file `.cshrc'
          in the invoker's home directory.

     -i   The shell is interactive and prompts for its top-level
          input, even if it appears to not be a terminal.  Shells
          are interactive without this option if their inputs and
          outputs are terminals.

     -n   Commands are parsed, but not executed.  This aids in
          syntactic checking of shell scripts.

     -s   Command input is taken from the standard input.

     -t   A single line of input is read and executed.  A `\' may
          be used to escape the newline at the end of this line
          and continue onto another line.

     -v   Causes the _v_e_r_b_o_s_e variable to be set, with the effect
          that command input is echoed after history substitu-
          tion.

     -x   Causes the _e_c_h_o variable to be set, so that commands
          are echoed immediately before execution.

     -V   Causes the _v_e_r_b_o_s_e variable to be set even before
          `.cshrc' is executed.

     -X   Is to -x as -V is to -v.

     After processing of flag arguments, if arguments remain but
     none of the -c, -i, -s, or -t options was given, the first
     argument is taken as the name of a file of commands to be
     executed.  The shell opens this file, and saves its name for
     possible resubstitution by `$0'.  Since many systems use
     either the standard version 6 or version 7 shells whose
     shell scripts are not compatible with this shell, the shell
     will execute such a `standard' shell if the first character
     of a script is not a `#', i.e. if the script does not start
     with a comment.  Remaining arguments initialize the variable
     _a_r_g_v.

     Signal handling

     The shell normally ignores _q_u_i_t signals.  Jobs running
     detached (either by `&' or the _b_g or %... & commands) are
     immune to signals generated from the keyboard, including
     hangups.  Other signals have the values which the shell
     inherited from its parent.  The shells handling of inter-
     rupts and terminate signals in shell scripts can be con-
     trolled by _o_n_i_n_t_r. Login shells catch the _t_e_r_m_i_n_a_t_e signal;
     otherwise this signal is passed on to children from the
     state in the shell's parent.  In no case are interrupts
     allowed when a login shell is reading the file `.logout'.

EXTENDED C-SHELL FEATURES
     The version of the C-shell supplied on the NeXT computer
     includes several entensions, such as intra-command line
     editing, a kill buffer, multi-line named keyboard macros
     which can be automatically saved and restored, convenient
     access to the history list, and user settable key bindings.
     A summary of the currently available functions and their
     default key bindings is given in the BINDINGS section below.
     In most cases the functionality will be apparent from the
     names of the routines in the list.

     The shell's editing mode is determined by the value of the
     shell editmode variable which users should set to emacs in
     their ._c_s_h_r_c files If editmode is not set, then the shell
     will run in "dumb" mode.  It is possible to set the mode
     after the shell starts up; so if you find yourself in "dumb"
     mode, you can alter the situation without having to log out
     and log in again.  Setting the editmode variable has two
     important side effects:  (1) it causes the key bindings to
     be reevaluated, and (2) it sets the EDITMODE environment
     variable.  The latter has no effect within the shell; so
     users should not set the environment variable directly in
     hopes of altering the editing mode.

     Terminal control capabilities are extracted from the user's
     termcap file (usually /_e_t_c/_t_e_r_m_c_a_p), using the value of the
     shell variable term -- not the environment variable TERM --
     as the terminal type.  If term is undefined, unknown, or if
     the associated termcap definition is inadequate, a warning
     will be displayed and most, or all, of the editing features
     of the shell will be disabled.  It is the user's responsi-
     bility to make sure that term is set to an appropriate value
     before the editmode variable is set to emacs. Usually this
     should be done in the ._c_s_h_r_c file.  If editing is disabled
     because term is not properly set when the shell starts up,
     simply setting term to the proper value will normally cause
     the shell editor to be re-enabled.  NB: Setting the shell
     variable term causes the environment variable TERM to be set
     to the same value.  For information on controlling the bell,
     see the DIAGNOSTICS section.

     There is a new command in this shell, bind-to-key, which
     allows the functions listed in the BINDINGS section below,
     and also user defined keyboard macros, to be bound to keys.
     The form of the command is

               bind-to-key function key ...

     where _f_u_n_c_t_i_o_n is one of the function names from the list or
     else the single character name of a keyboard macro and where
     _k_e_y is a quoted string designating a key sequence.  Control
     characters in the _k_e_y designation should not be entered
     literally, but should be indicated by the prefix "\^", e.g.
     "\^X".  Similarly, escape is indicated by "\e".  A literal
     slash is "\\".  Escape and control-X are the only legitimate
     "prefix" characters.  The following mnemonics should be
     used: "\t" for tab, "\^?" for rubout, "\n" for newline, and
     "\r" for return.  Since the shell converts returns to new-
     lines it is probably unwise to alter the binding of newline.

     During editor initialization the shell will read a file
     named ._b_i_n_d_i_n_g_s in the user's home directory.  If you regu-
     larly want certain non-default key bindings to be effective,
     put the appropriate bind-to-key commands in your ~/._b_i_n_d_i_n_g_s
     file.  NB: The bind-to-key commands would work if placed in
     your ~/._c_s_h_r_c file, but they will be more useful (in the
     future) if they are in the ~/._b_i_n_d_i_n_g_s file.

     Invocation of the history mechanism with "!" either causes
     the matched command to be inserted on the command line for
     editing before execution or immediatedly executes the com-
     mand.  This is controlled by the shell variable edithist,
     which is automatically _s_e_t, when the shell variable editmode
     is _s_e_t, thereby allowing editing of previous commands
     invoked by the history mechanism.  This feature may be
     turned off with the command "unset edithist", which may be
     placed in the user's .cshrc file.

HOW TO ENABLE THE EXTENDED C-SHELL FEATURES
     To enable the extended C-Shell features, put the line:

               set editmode = emacs

     in the ._c_s_h_r_c file in your home directory.  If you don't
     have such a file, create one and add the line to the end.
     Log out and log in again and you will be using the new
     shell.

BINDINGS
     The following functions and default key bindings are
     currently implemented.

      _E_m_a_c_s    _F_u_n_c_t_i_o_n _N_a_m_e            _R_e_m_a_r_k

      ^B       Backspace
      ESC-b    BackwardWord
      ^A       BeginningOfLine
      ^L       ClearScreen
               DefaultBinding
      ESC-n    DefineNamedMacro         name macro
      ^D       DeleteCurrentChar
      ^H       DeletePreviousChar
      ESC-d    DeleteWord               after cursor
               EndOfFile                exit shell
      ^E       EndOfLine
               EraseLine                kills whole line
      ESC-h    EraseWord                before cursor
      ESC-e    ExecuteNamedMacro
      ESC-x    ExecuteNamedMacro
      ^X-e     ExecuteUnNamedMacro
      ESC-ESC  FilenameExpansion
      ESC-l    FilenameList
      ^F       ForwardChar
      ESC-f    ForwardWord
      ^W       KillRegion               to kill buffer
      ^K       KillToEOL                to kill buffer
               IncrementalSearchForward
               IncrementalSearchReverse
               InsertChar               self insert
      ^V       InsertLiteralChar
      ^X^R     LoadMacroFile
      ^N       NextHistEntry            wraps around
      ^P       PreviousHistEntry        wraps around
      ^R       Redisplay                redraws line
      ^U       Repetition               greater than 0
      ^M,^J    Return
      ^X^S     SaveMacroFile
      ^@       SetMark                  default mark at BOL
               SearchReverse            look for next char
               SearchForward            look for next char
      ^Q       StartFlow                (see FLOW CONTROL)
      ^X-(     StartRemembering         begin a macro
      ^S       StopFlow                 (see FLOW CONTROL)
      ^X-)     StopRemembering          end a macro
      ^I       Tab                      inserts 8 spaces
      ^T       TransposeChars           before cursor
      ^Y       YankKillBuffer           no kill ring

     Users may change the bindings of functions to keys by means
     of the shell _b_i_n_d-_t_o-_k_e_y command.  These commands may be
     stored in a file named ._b_i_n_d_i_n_g_s in the users home directory
     and will then be read by the shell when the editor is ini-
     tialized.

     NB:  The shell variable bindings is no longer being sup-
     ported and will become ineffective in a future release.
     Before that happens users should convert to using the
     ~/._b_i_n_d_i_n_g_s file.

FLOW CONTROL
     Flow control is handled by the terminal driver, not by the
     shell.  The terminal driver normally interprets ^S and ^Q as
     a signal to respectively stop and restart output to the ter-
     minal.  By default, the shell does not override these "bind-
     ings", but the user may override them by rebinding ^S or ^Q
     to functions other than StopFlow and StartFlow.

     The functions StopFlow and StartFlow can only be usefully
     bound to the keys that the terminal driver interprets as
     performing the corresponding flow control functions.  In
     other words, you cannot simply bind these functions to other
     keys in order to have them perform the flow control opera-
     tions normally provided by ^S and ^Q.

KEYBOARD MACROS
     Keyboard macros can be used to simplify repetitive opera-
     tions and reduce typing lengthy commands.  For example, the
     following lines illustrate how to create a macro to startup
     Emacs and have it run the shell inside a buffer:

           % ^X(emacs -eshell
           % ^X)

     Notice that this is a multi-line macro, since it contains an
     embedded newline.  The user can give this macro a single
     character name, e.g. "e", as follows:

             % \ene                       (escape-n-e).

     The macro may then be executed by typing "\exe". It can also
     be bound to a key using the bind-to-key command.  Macros can
     be saved in files and can be reloaded automatically when the
     shell starts up.

     Macro Creation
          To create a new unnamed macro, use the StartRemembering
          function which is bound by default to ^X(.  Subsequent
          keystrokes, until the StopRemembering,^X), function is
          executed, are remembered as an "unnamed" keyboard
          macro.  It can contain at most 1024 characters.  You
          are not allowed to begin creating another macro during
          macro creation, but it is okay to execute other macros,
          provided loops aren't created.  The unnamed macro can
          be executed using the ExecuteUnNamedMacro function,
          bound to ^Xe.  There is only one unnamed macro.

     Named Macros
          Users can have up to 128 named macros.  To define such
          a macro, first create an unnamed macro as above and
          then give it a name by executing the DefineNamedMacro
          function, bound to \en (escape-n).  The function takes
          a single character argument which will be the name of
          the macro.  Any previous macro with that same name will
          be destroyed.

     Macro Execution
          To execute a named macro simply use the ExecuteNamed-
          Macro function, bound to \ex, and give it the name of
          the macro to be executed.  Named macros can also be
          bound to keys using the builtin cshell command _b_i_n_d-
          _t_o-_k_e_y.

     Macro Files
          Named keyboard macros can be saved in files and loaded
          from files.  To save the named macros in a file simply
          type the filename on the command line (by itself) and
          then execute the SaveMacroFile function bound to ^X^S.
          To read a file of previously saved macros type the
          filename on the command line and execute the LoadMacro-
          File function bound to ^X^R.  Success in each case is
          indicated by the erasure of the filename.  It is okay
          to store macros in several different macro files.

          NB:  It is not advisable to try to edit saved macros!

     Autoloading and AutoSaving Macros
          If the shell variable _m_a_c_r_o_f_i_l_e_s is assigned (in the
          user's ._c_s_h_r_c file) the names of one or more files of
          saved keyboard macros, then those macro files will be
          automatically loaded when the shell starts up.  Simi-
          larly, the variable savemacros can be assigned the name
          of a (single) file in which all named macros will be
          saved when the user logs out.

SEARCHING
     NB: The names of the incremental search functions have
     changed since earlier releases of this shell.

     Four search functions are available to the user, but are not
     bound (by default) to keys.  If you want to use them, use
     the cshell bind-to-key command to bind them to keys.

     IncrementalSearchForward
          When the user executes this function he is placed in a
          read/search loop in which the string to be found is
          built up character by character.  As each new character
          is added to the search string the cursor is placed at
          the end of the first match on the command line follow-
          ing the position of the cursor when the function was
          executed.  You can reexecute the search function while
          in the loop to cause the cursor to move to subsequent
          matches.  Type ESC to exit the loop.

     IncrementalSearchReverse
          This function is similar to IncrementalSearchForward
          except that the cursor is placed at the beginning of
          the first match on the command line preceding the posi-
          tion of the cursor when the function was executed.

     SearchForward
          This function grabs the next character you type and
          searches for that character from the position of the
          cursor to the end of the command line, leaving the cur-
          sor following the first instance of the character if
          one is found.

     SearchReverse
          This function is like SearchForward except that it
          searches from where the cursor is to the beginning of
          the command line.

MISCELLANEOUS
     If the shell variable breakchars is assigned a string, then
     the characters in that string are used to determine word
     boundaries.  The default break characters are " ", ",", ^I,
     /, \, (, ), [, ], {, }, ., ;, >, <, !, ^, &, and |.  The
     user defined break characters are used instead of, not in
     addition to, the default list.



AUTHOR
     William Joy.  Job control and directory stack features first
     implemented by J.E. Kulp of I.I.A.S.A, Laxenburg, Austria,
     with different syntax than that used now.  File name comple-
     tion code written by Ken Greer, HP Labs.  Command line edi-
     tor code written by Duane Williams, Carnegie-Mellon Univer-
     sity.

FILES
     ~/.cshrc         Read at beginning of execution by each shell.
     ~/.login         Read by login shell, after `.cshrc' at login.
     ~/.logout        Read by login shell, at logout.
     ~/.bindings      Definitions for non-default key bindings, read during shell editor initialization.
     /bin/sh          Standard shell, for shell scripts not starting with a `#'.
     /tmp/sh*         Temporary file for `<<'.
     /etc/passwd      Source of home directories for `~name'.

LIMITATIONS
     Words can be no longer than 1024 characters.  The system
     limits argument lists to 10240 characters.  The number of
     arguments to a command which involves filename expansion is
     limited to 1/6'th the number of characters allowed in an
     argument list.  Command substitutions may substitute no more
     characters than are allowed in an argument list.  To detect
     looping, the shell restricts the number of _a_l_i_a_s substitu-
     tions on a single line to 20.

SEE ALSO
     sh(1), access(2), execve(2), fork(2), killpg(2), pipe(2),
     sigvec(2), umask(2), setrlimit(2), wait(2), tty(4),
     a.out(5), environ(7), `An introduction to the C shell'

DIAGNOSTICS
     Error conditions within the editor functions are usually
     indicated by an audible bell.  If you prefer a visual signal
     and your terminal has a visible bell capability, then you
     should set the variable visiblebell in your ._c_s_h_r_c file.  If
     you want an audible bell also, then set both visiblebell and
     audiblebell.  If you don't want to be told about your mis-
     takes, you can set the nobell variable.

BUGS
     When a command is restarted from a stop, the shell prints
     the directory it started in if this is different from the
     current directory; this can be misleading (i.e. wrong) as
     the job may have changed directories internally.

     Shell builtin functions are not stoppable/restartable.  Com-
     mand sequences of the form `a ; b ; c' are also not handled
     gracefully when stopping is attempted.  If you suspend `b',
     the shell will then immediately execute `c'.  This is espe-
     cially noticeable if this expansion results from an _a_l_i_a_s.
     It suffices to place the sequence of commands in ()'s to
     force it to a subshell, i.e. `( a ; b ; c )'.

     Control over tty output after processes are started is prim-
     itive; perhaps this will inspire someone to work on a good
     virtual terminal interface.  In a virtual terminal interface
     much more interesting things could be done with output con-
     trol.

     Alias substitution is most often used to clumsily simulate
     shell procedures; shell procedures should be provided rather
     than aliases.

     Commands within loops, prompted for by `?', are not placed
     in the _h_i_s_t_o_r_y list.  Control structure should be parsed
     rather than being recognized as built-in commands.  This
     would allow control commands to be placed anywhere, to be
     combined with `|', and to be used with `&' and `;' metasyn-
     tax.

     It should be possible to use the `:' modifiers on the output
     of command substitutions.  All and more than one `:' modif-
     ier should be allowed on `$' substitutions.

     The shell variable filec is currently ignored; this means
     that file and user name completion always takes place.
     Also, the way the filec facility is implemented is ugly and
     expensive.

















