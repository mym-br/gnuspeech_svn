/*
 *    Filename:	TNTEventGenerator.m 
 *    Created :	Mon Aug 23 19:03:43 1993 
 *    Author  :	Dale Brisinda
 *		<dale@pegasus.cuc.ab.ca>
 *
 *    Last modified on "Fri Jun 10 01:56:03 1994"
 *
 * $Id: TNTEventGenerator.m,v 1.9 1994/06/03 19:28:24 dale Exp $
 *
 * $Log: TNTEventGenerator.m,v $
 * Revision 1.9  1994/06/03  19:28:24  dale
 * Fixed problem where dragging of stylus caused no events to be processed. Also changed
 * "LastEditDate" to "Last modified on" within header.
 *
 * Revision 1.8  1994/06/03  08:03:28  dale
 * *** empty log message ***
 *
 * Revision 1.7  1994/06/01  19:13:28  dale
 * Commented velocity and direction calculation methods since not required.
 *
 * Revision 1.6  1994/05/28  21:24:37  dale
 * *** empty log message ***
 *
 * Revision 1.5  1993/10/10  20:58:14  dale
 * Modified detection of events, and now handle stylus up, down, moved, tip down, and barrel down.
 *
 * Revision 1.4  1993/09/04  17:49:22  dale
 * Added event posting, and finished velocity, and direction.
 *
 * Revision 1.3  1993/09/01  19:35:12  dale
 * *** empty log message ***
 *
 * Revision 1.2  1993/08/31  04:51:27  dale
 * *** empty log message ***
 *
 * Revision 1.1  1993/08/24  02:08:33  dale
 * Initial revision
 *
 *
 * The values for the event generated by this class are placed within the NXEvent structure defined in
 * the NeXTSTEP header file dpsclient/event.h. A description of  the NXEvent record, of its various 
 * components and fields, appears below. Only the contents of redefined components are listed and 
 * explained. Other component definitions are the same as those which appear in  the NeXTSTEP Concepts
 * and General Reference documentation.
 *
 *     typedef struct _NXEvent {
 *         int           type        // application-defined event type
 *         NXPoint       location;   // stylus location
 *         long          time;       // millisecond resolution event timestamp
 *         int           flags;      // TouchNTalk event type
 *         unsigned int  window;     // groove number within region
 *         NXEventData   data;       // additional TNT event information
 *         DPSContext    ctxt;       // region id
 *     } NXEvent;
 *
 * The "type" field holds the event type, which is always set to NX_APPDEFINED. This allows the 
 * NeXTSTEP event system to differentiate an application-defined event from other NeXTSTEP events, and
 * have the -applicationDefined: method invoked in the appropriate class.
 *
 * The "location" component holds the current location of the stylus. The default coordinate system 
 * normally has the origin (0,0) set to be at the lower left corner of the tablet. Coordinate values 
 * for x and y increase as the stylus is dragged to the right and upwards respectively.
 *
 * The "time" field holds the timestamp for the application-defined event. This field contains time 
 * measured with millisecond resolution. The time value is the number of milliseconds that have 
 * elapsed since some arbitrary point in time. The roll-over period is approximately every 24.9 days.
 * This value is taken from the current tablet kit event, and differs from the timestamp values used 
 * for other NeXTSTEP events.
 *
 * The "flags" field holds the event subtype. This will always be set to TNT_EVENT for application-
 * defined events generated by an instance of this class. This field is used to distinguish between 
 * application-defined events generated by TouchNTalk and those generated by the TabletKit. The
 * definition TNT_APPSUBTYPE is a macro defined to "flags" for NXEvent structure transparency.
 * 
 * The "window" field holds the groove number of the stylus within a particular region, as defined in
 * the tablet groove definitions section of TNTDefinitions.h. For regions with only one active area, 
 * such as the softArea, prevArea, nextArea, or silArea regions, there only exists one groove. See 
 * TNTDefinitions.h for additional information. TNT_GROOVE is a macro defined to "window" for 
 * additional NXEvent structure transparency.
 *
 * The "ctxt" field holds the region of the stylus. Since TouchNTalk events cannot meaningfully be 
 * associated with a window, we associate them with a region instead. This can be useful for narrowing
 * the search space for determining in which groove a particular event had occurred. For example, we
 * can quickly determine that an event did not occur in the tactile area region, and therefore rule
 * out 40 grooves. Similarly, we can quickly determine that an event did not occur in the left holo 
 * region, and therefore rule out an additional 4 grooves. Note, this field contains a region id, and
 * should be cast as such when being accessed: (id)anEvent->TNT_REGION. TNT_REGION is a macro defined
 * to "ctxt" for additional NXEvent stucture transparency.
 *
 * The "data" component of the NXEvent record is a C union where only the "compound" component is 
 * utilized. Likewise, the "misc" component of the "compound" record is a C union where only the "S" 
 * component is utilized. This structure appears here in abbreviated form showing only those 
 * components which are used:
 *
 *     typedef union {
 *         (...unused components deleted...)
 *         struct {
 *             short  reserved;   // reserved
 *	       short  subtype;    // event subtype
 * 	       union {
 *	           (...unused components deleted...)
 *	           short  S[4];   // additional tablet event information
 *	       } misc;
 *         } compound;
 *     } NXEventData;
 *
 * The "subtype" field holds the TouchNTalk event type. These types inlude such information as whether
 * the stylus is raised off the tablet, whether the stylus is in tablet proximity and has been moved,
 * and various button click events. TNT_SUBTYPE is a macro defined to "compound.misc.subtype" for
 * additional NXEvent structure transparency. These types are listed here for quick reference:
 *
 *     // TouchNTalk event types.
 *     #define TNT_STYLUSUP             1   // stylus raised off tablet or moved out of region/groove
 *     #define TNT_STYLUSDOWN           2   // stylus placed on tablet or in new region/groove
 *     #define TNT_STYLUSMOVED          3   // stylus in tablet proximity and moved
 *     #define TNT_STYLUSTIPDOWN        4   // stylus tip button was clicked
 *     #define TNT_STYLUSBARRELDOWN     5   // stylus barrel button was clicked
 *
 * The S component is an array of 4 elements. A convenient way for indexing the required elements is 
 * to use the hash defines which appear in the TNTDefinitions.h header file. These definitions are 
 * listed here for easy reference:
 *
 *     // NXEvent data.compound.misc.S component definitions.
 *     #define TNT_PARTITION             data.compound.misc.S[0]
 *     #define TNT_CLICKS                data.compound.misc.S[1]
 *     #define TNT_DIRECTION             data.compound.misc.S[2]
 *     #define TNT_VELOCITY              data.compound.misc.S[3]
 *		  
 * The definition TNT_PARTITION references the element at index 0. This element contains the partition
 * number for the groove in which the event occurred. For vertical grooves this represents a row of
 * some height, while for horizontal grooves this represents a column of some width. The definition 
 * TNT_CLICKS references the element at index 1. This element contains the number of taps/clicks that 
 * have occurred. It identifies, a single or double tap/click. The definition TNT_DIRECTION references
 * the element at index 2. This element contains the direction of stylus in resolution equal to whole
 * degrees. The definition TNT_VELOCITY references the element at index 3. This element contains the 
 * velocity of the stylus in the form of coordinate units per second. This is calculated by obtaining
 * the time difference between two events, the coordinate distance between two events, and then using 
 * the standard velocity formula V = D/T.
 */

#import <tabletkit/tabletkit.h>
#import "TNTDefinitions.h"
#import "TouchNTalk.h"
#import "TabletSurface.h"
#import "TabletRegion.h"
#import "TabletGroove.h"
#import "GestureExpert.h"
#import "TNTEventGenerator.h"

@implementation TNTEventGenerator

static void postClickEvent(DPSTimedEntry tag, double now, TNTEventGenerator *self)
{
    DPSRemoveTimedEntry(self->postEventTE);
    self->postEventTE = (DPSTimedEntry)0;
    if (DPSPostEvent(&(self->prevTTEvent), NO) == -1) {   // event queue full
	NXLogError("TNTEventGenerator: Unable to post app-defined event; event queue full.");
    }
}


/* INITIALIZING *************************************************************************************/


- init
{
    [super init];
    bzero(&prevEvent, sizeof(NXEvent));
    bzero(&prevTTEvent, sizeof(NXEvent));
    postEventTE = (DPSTimedEntry)0;
    if (!(eventHandle = NXOpenEventStatus()))
	NXLogError("TNTEventGenerator: Unable to open event status driver.");

    // default click space threshold assumes tablet resolution = screen resolution
    NXGetClickSpace(eventHandle, &clickSpaceThresh);
    return self;
}


/* EVENT GENERATION *********************************************************************************/


/* Generates a TouchNTalk event. Note that in the case that the stylus has moved out of a region or
 * groove, we must post a TNT_STYLUSUP and TNT_STYLUSDOWN in rapid succession in order to preserve
 * the mapping of stylus motion with mouse motion within a slider. Movement out of grooves/regions is
 * equivalent to raising the stylus out of the groove/region, then lowering it into a new 
 * groove/region. Also, the last else statement is a catch-all intended to handle any other possible
 * case that could occur. This includes handling the dummy events generated by the tablet when the
 * stylus is raised off the tablet. Three identical events are generated, we only use the first one
 * one for detecting stylus up, and the other two are ignored. The if-else statement is sensitive to
 * order. That is, we take advantage of previous evaluations of test conditions in subsequent else-if
 * case tests. Returns self.
 */
- generateEvent:(const NXEvent *)theEvent
{
    static NXEvent ttEvent, tempEvent;
    id tabletSurface = [[NXApp delegate] tabletSurface];
    BOOL delayPost = NO;

    ttEvent.type = NX_APPDEFINED;
    ttEvent.time = theEvent->time;
    ttEvent.location = theEvent->location;
    ttEvent.TNT_CLICKS = 0;
    ttEvent.TNT_APPSUBTYPE = TNT_EVENT;
    ttEvent.TNT_REGION = (void *)[tabletSurface regionForPoint:&(theEvent->location)];
    ttEvent.TNT_GROOVE = [[tabletSurface grooveForPoint:&(theEvent->location) 
					 inRegion:(id)ttEvent.TNT_REGION] tag];
    ttEvent.TNT_PARTITION = [tabletSurface groovePartitionAtPoint:&(theEvent->location) 
					   inRegion:(id)ttEvent.TNT_REGION 
					   inGrooveWithTag:ttEvent.TNT_GROOVE];

    // We could calculate the direction and velocity only for those regions that require it but
    // currently none do require it since stylus motion DRIVES graphical display. If we were to
    // implement the page turning gestures then we would require stylus direction as these would
    // be REAL gestures.
    // 
    // ttEvent.TNT_DIRECTION = [self stylusDirection:theEvent];
    // ttEvent.TNT_VELOCITY = [self stylusVelocity:theEvent];

    if (theEvent->TK_SUBTYPE == TK_STYLUSLOWERED) {   // stylus placed on tablet
	ttEvent.TNT_SUBTYPE = TNT_STYLUSDOWN;
    } else if (theEvent->TK_SUBTYPE == TK_STYLUSRAISED) {   // stylus raised
	ttEvent.TNT_SUBTYPE = TNT_STYLUSUP;
	ttEvent.TNT_REGION = prevTTEvent.TNT_REGION;
	ttEvent.TNT_GROOVE = prevTTEvent.TNT_GROOVE;
	ttEvent.TNT_PARTITION = prevTTEvent.TNT_PARTITION;
	ttEvent.location = prevTTEvent.location;
    } else if ((prevTTEvent.TNT_REGION != ttEvent.TNT_REGION) ||
	       (prevTTEvent.TNT_GROOVE != ttEvent.TNT_GROOVE)) {   // stylus out of groove/region
	tempEvent = ttEvent;
	ttEvent.TNT_SUBTYPE = TNT_STYLUSUP;
	ttEvent.TNT_REGION = prevTTEvent.TNT_REGION;
	ttEvent.TNT_GROOVE = prevTTEvent.TNT_GROOVE;
	ttEvent.TNT_PARTITION = prevTTEvent.TNT_PARTITION;
	ttEvent.location = prevTTEvent.location;
	if (DPSPostEvent(&ttEvent, NO) == -1) {   // event queue full
	    NXLogError("TNTEventGenerator: Unable to post app-defined event; event queue full.");
	}
	ttEvent = tempEvent;
	ttEvent.TNT_SUBTYPE = TNT_STYLUSDOWN;

    } else if (theEvent->TK_SUBTYPE == TK_STYLUSUP && 
	       theEvent->TK_BUTTON == TK_BUTTON1 &&
	       theEvent->TK_CLICKS == 1) {   // tip button single-clicked (recognized when released)
	ttEvent.TNT_SUBTYPE = TNT_STYLUSTIPDOWN;
	ttEvent.TNT_CLICKS = 1;
	delayPost = YES;
	printf("Single-click.\n");

    } else if (theEvent->TK_SUBTYPE == TK_STYLUSDOWN && 
	       theEvent->TK_BUTTON == TK_BUTTON1 &&
	       theEvent->TK_CLICKS > 1) {   // tip button multi-clicked (recognized when depressed)
	ttEvent.TNT_SUBTYPE = TNT_STYLUSTIPDOWN;
	ttEvent.TNT_CLICKS = theEvent->TK_CLICKS;
	delayPost = YES;
	printf("Multi-click: %d\n", ttEvent.TNT_CLICKS);

    } else if (theEvent->TK_SUBTYPE == TK_STYLUSDOWN &&
	       theEvent->TK_BUTTON == TK_BUTTON2) {   // barrel button clicked (recognized when down)
 	ttEvent.TNT_SUBTYPE = TNT_STYLUSBARRELDOWN;
	ttEvent.TNT_CLICKS = 1;   // only allow single barrel clicks (for efficiency)

    } else if (theEvent->TK_SUBTYPE == TK_STYLUSMOVED || 
	       theEvent->TK_SUBTYPE == TK_STYLUSDRAGGED) {   // stylus must have moved (drag == move)
	ttEvent.TNT_SUBTYPE = TNT_STYLUSMOVED;

    } else {   // catch-all (includes button-up after dragging -- ignore)
	return self;
    }

    if (delayPost) {   // delay posting click event since final click count is uncertain
        if (postEventTE) {   // remove previous click event post TE if existant
	    DPSRemoveTimedEntry(postEventTE);
	}

	// We store the TNT event BEFORE we add the TE. This is a safety precaution, since the TE
	// function uses the prevTTEvent variable. Therefore, we really should set this variable 
	// before adding the TE. However, it probably wouldn't make any difference since we set this
	// variable immediately after as well.

	prevTTEvent = ttEvent;   // remember TouchNTalk event (safer to do this BEFORE we add TE)
	postEventTE = DPSAddTimedEntry(NXClickTime(self->eventHandle), (void *)&postClickEvent, self,
				       NX_MODALRESPTHRESHOLD);

    } else {

	// The current event is not a click event. However, if the last event was, and it was delayed
	// via the addition of the TE, then we should remove the TE and IMMEDIATELY post that event 
	// since we now know that it contained the correct click count -- with one exception: if the 
	// current event lies within the click space threshold area from where the down click occurred
	// then a multi-click is still possible and we are still uncertain as to the click count. In 
	// this case we should NOT remove the TE. Regardless, we always post the current event.

	// Well, upon experiementation, adding the click space threshold comparisons actually makes 
	// things worse!

	if (postEventTE && 
	    (ABS(theEvent->location.x - prevEvent.location.x) > self->clickSpaceThresh.width ||
	     ABS(theEvent->location.y - prevEvent.location.y) > self->clickSpaceThresh.height)) {

	    DPSRemoveTimedEntry(postEventTE);
	    postEventTE = (DPSTimedEntry)0;
	    if (DPSPostEvent(&prevTTEvent, NO) == -1) {   // event queue full
		NXLogError("TNTEventGenerator: Unable to post app-defined event; event queue full.");
	    }
	}
	if (DPSPostEvent(&ttEvent, NO) == -1) {   // event queue full
	    NXLogError("TNTEventGenerator: Unable to post app-defined event; event queue full.");
	}
    }
    prevEvent = *theEvent;   // remember tablet kit event
    prevTTEvent = ttEvent;   // remember TouchNTalk event
    return self;
}


/* UTILITY METHODS **********************************************************************************/


/* Would have to use timed-entries which in turn cause an all-around response time penalty on clicks.
 * Will he "double-click" button to invoke additinal functionality. The TouchNTalk model is not very 
 * amenable to the single/double click model. The NEXTSTEP model includes processing of single clicks
 * in double clicks which does NOT require a response time penalty. Another button must be used for 
 * the "double-click" or the TouchNTalk model ought to be revamped. Because of this philosophy this 
 * method always returns 1.
 */
- (short)stylusClicks:(const NXEvent *)currEvent
{
    return 1;
}

/* Returns the stylus direction in degrees, based on the current and previous stylus events. */
- (short)stylusDirection:(const NXEvent *)currEvent
{
    float deltaX = ABS(currEvent->location.x - prevEvent.location.x);
    float deltaY = ABS(currEvent->location.y - prevEvent.location.y);

    if (currEvent->location.x == prevEvent.location.x && 
	currEvent->location.y == prevEvent.location.y) {
        return TNT_NODIRECTION;
    }
    if (currEvent->location.x >= prevEvent.location.x) {   // <= 90 degrees, or >= 270 degrees
        if (currEvent->location.y >= prevEvent.location.y) {   // between 0 and 90 degrees inclusive
	    return TNT_EAST + (short)(atan(deltaY/deltaX) * (180/M_PI));
	} else {   // between 270 and 359.999[...] degrees inclusive
	    return TNT_SOUTH + (90 - (short)(atan(deltaY/deltaX) * (180/M_PI)));
	}
    } else {   // >= 90 degrees, and <= 270 degrees
	if (currEvent->location.y >= prevEvent.location.y) {   // between 90 and 180 degrees inclusv.
	    return TNT_NORTH + (90 - (short)(atan(deltaY/deltaX) * (180/M_PI)));
	} else {   // between 180 and 270 degrees inclusive 
	    return TNT_WEST + (short)(atan(deltaY/deltaX) * (180/M_PI));
	}
    }
}

/* Returns the stylus velocity in cartesian units per second, based on the current and previous 
 * stylus events.
 */
- (short)stylusVelocity:(const NXEvent *)currEvent
{
    return (short)(hypot((double)ABS(currEvent->location.x - prevEvent.location.x), 
			 (double)ABS(currEvent->location.y - prevEvent.location.y)) / 
		   (ABS(currEvent->time - prevEvent.time) / 1000));
}

@end
