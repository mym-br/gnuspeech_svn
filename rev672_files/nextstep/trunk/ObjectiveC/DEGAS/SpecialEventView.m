
/* Generated by Interface Builder */

#import "SpecialEventView.h"
#import <appkit/NXImage.h>
#import <dpsclient/psops.h>
#import <dpsclient/wraps.h>

/*  GRAPHIC CONSTANTS  */
#define TOP_MARGIN	20.0
#define BOTTOM_MARGIN   28.0
#define LEFT_MARGIN	55.0
#define RIGHT_MARGIN    20.0
#define NUMBER_SPACER   5.0

#define REGRESSION_HEIGHT 4.0
#define REGRESSION_Y	  ((BOTTOM_MARGIN - REGRESSION_HEIGHT)/2.0)

#define VERTICAL_DIV    20.0

/*  COLOURS  */
#define WHITE            1.0
#define LIGHT_GRAY       0.667
#define DARK_GRAY        0.333
#define BLACK            0.0

#define PLOT_FONT_SIZE   12.0
#define DIGITS_MAX       8
#define DIGITS_PREC      1

/*  NODE RECTANGLE  */
#define NODE_SIZE        6.0
#define NODE_OFFSET      (-NODE_SIZE/2.0)

@implementation SpecialEventView

+ alloc
{
    self = [super alloc];
    return self;
}

- initFrame:(const NXRect *)viewFrame
{
    /*  INCORPORATE INITIALIZATIONS OF SUPERCLASS  */
    [super initFrame:viewFrame];

    /*  CREATE CACHES AND SET GRAPHICS  */
    [self makeBackgroundCache];
    [self makeBitmapCache];
    [self setFlipped:NO];
    [self setClipping:NO];
    [self allocateGState];

    /*  SET SOME GRAPHING CONSTANTS  */
    extent_width = bounds.size.width - (LEFT_MARGIN + RIGHT_MARGIN);
    extent_height = bounds.size.height - (TOP_MARGIN + BOTTOM_MARGIN);
    vertical_div_height = extent_height / VERTICAL_DIV;
    unity_extent_width = extent_width;
    unity_extent_height = extent_height/2.0;

    graph_origin_x = LEFT_MARGIN;
    graph_origin_y = BOTTOM_MARGIN;
    zero_x = graph_origin_x;
    zero_y = graph_origin_y + unity_extent_height;
    one_x = zero_x + unity_extent_width;

    return self;
}

// makeBitmapCache creates the bitmap cache on which we draw
- makeBitmapCache
{
    cache = [[NXImage alloc] initSize:&bounds.size];
    [cache setFlipped:NO];
    [cache setUnique:YES];
    return self;
}

// makeBackgroundCache creates the bitmap cache on which we draw
- makeBackgroundCache
{
    backgroundcache = [[NXImage alloc] initSize:&bounds.size];
    [backgroundcache setFlipped:NO];
    [backgroundcache setUnique:YES];
    return self;
}




- drawSelf:(const NXRect *)rects :(int)rectCount
{
    if (rectCount == 3) {  // Scrolling diagonally; use last two rectangles
	[backgroundcache composite:NX_COPY fromRect:rects+1 toPoint:&(rects+1)->origin];
	[backgroundcache composite:NX_COPY fromRect:rects+2 toPoint:&(rects+2)->origin];

	[cache composite:NX_PLUSD fromRect:rects+1 toPoint:&(rects+1)->origin];
	[cache composite:NX_PLUSD fromRect:rects+2 toPoint:&(rects+2)->origin];
    } else {
        [backgroundcache composite:NX_COPY fromRect:rects toPoint:&rects->origin];
	[cache composite:NX_PLUSD fromRect:rects toPoint:&rects->origin];
    }

    return self;
}




- createbackground:(float)range
{
    int i;
    int fontobject1;
    char temp[DIGITS_MAX+1];
    float width, height;

    /*  SET THE GLOBAL RANGE FROM ARGUMENT  */
    full_range = range;

    /*  DEFINE FONT OBJECT  */
    PSfindfont("Times-Roman");
    PSscalefont(PLOT_FONT_SIZE);
    fontobject1 = DPSDefineUserObject(0);

    /*  WRITE ON CACHE BITMAP  */
    [backgroundcache lockFocus];

    /*  ERASE AREA AND DRAW BORDER  */
    PSsetalpha(1.0);
    NXDrawWhiteBezel(&bounds,&bounds);

    /*  DRAW IN GRID  */
    /*  HORIZONTAL LINES  */
    PSsetgray(LIGHT_GRAY);
    PSsetlinewidth(1.0);
    for (i = 0; i <= VERTICAL_DIV; i++) {
	PSmoveto(graph_origin_x, (graph_origin_y + (i * vertical_div_height)) );
	if ((i == 0) || (i == 10) || (i == 20)) {
	    PSsetlinewidth(2.0);
	    PSrlineto(unity_extent_width,0.0);
	    PSstroke();
	    PSsetlinewidth(1.0);
	}
	else {
	    PSrlineto(unity_extent_width,0.0);
	    PSstroke();
	}
    }
    /*  VERTICAL LINES  */
    PSsetgray(BLACK);
    PSsetlinewidth(2.0);
    PSmoveto(graph_origin_x, graph_origin_y);
    PSrlineto(0.0, extent_height);
    PSmoveto((graph_origin_x + unity_extent_width), graph_origin_y);
    PSrlineto(0.0, extent_height);
    PSstroke();

    /*  LEFT HAND VALUES  */
    PSsetfont(fontobject1);
    /*  NEGATIVE RANGE VALUE  */
    sprintf(temp,"%+*.*f",DIGITS_MAX,DIGITS_PREC,-range);
    PSstringwidth(temp,&width,&height);
    PSmoveto((graph_origin_x - width - NUMBER_SPACER),
	(graph_origin_y - (PLOT_FONT_SIZE/2.0) + 1.0) );
    PSshow(temp);
    /*  ZERO VALUE  */
    sprintf(temp,"%*.*f",DIGITS_MAX,DIGITS_PREC,0.0);
    PSstringwidth(temp,&width,&height);
    PSmoveto((graph_origin_x - width - NUMBER_SPACER),
	(zero_y - (PLOT_FONT_SIZE/2.0) + 1.0) );
    PSshow(temp);
    /*  POSITIVE RANGE VALUE  */
    sprintf(temp,"%+*.*f",DIGITS_MAX,DIGITS_PREC,range);
    PSstringwidth(temp,&width,&height);
    PSmoveto((graph_origin_x - width - NUMBER_SPACER),
	((zero_y + unity_extent_height) - (PLOT_FONT_SIZE/2.0) + 1.0) );
    PSshow(temp);

    /*  FINISHED WRITING ON CACHE BITMAP  */
    [backgroundcache unlockFocus];

    return self;
}



- blankDisplay
{
    int fontobject2;
    char text[] = "No Special Event Profile Chosen";
    float width, height;

    /*  DEFINE FONT OBJECT  */
    PSfindfont("Times-Roman");
    PSscalefont(24.0);
    fontobject2 = DPSDefineUserObject(1);

    /*  ERASE AREA AND DRAW BORDER  */
    [backgroundcache lockFocus];
    PSsetalpha(1.0);
    NXDrawWhiteBezel(&bounds,&bounds);

    /*  DRAW IN TEXT  */
    PSsetfont(fontobject2);
    PSstringwidth(text,&width,&height);
    PSmoveto(((bounds.size.width-width)/2.0),((bounds.size.height-height)/2.0));
    PSsetgray(DARK_GRAY);
    PSshow(text);

    [backgroundcache unlockFocus];

    /*  CLEAR THE BITMAP  */
    [cache lockFocus];
    [cache composite:NX_CLEAR fromRect:&bounds toPoint:&bounds.origin];
    [cache unlockFocus];

    [self display];
    return self;
}


- zoomOutDisplay:(specifierStructPtr)specifier:(specialEventStructPtr)specialEvent
{
    int i, j;
    t_intervalPtr current_t_interval_ptr = NULL;
    int total_t_intervals;
    float current_x, current_y;

    float proportional_space;
    float fixed_space;

    int fixed_total_duration = 0;
    int number_of_p_intervals = 0;
    int number_of_f_intervals = 0;
    int total_intervals = 0;

    se_intervalPtr current_se_interval_ptr;
    sub_intervalPtr current_sub_interval_ptr;
    int total_sub_intervals;

    /*  GET TOTAL NUMBER OF T_INTERVALS  */
    total_t_intervals = specifier->number_of_t_intervals;

    /*  FIND FIXED AND PROPORTIONAL SPACE  */
    current_t_interval_ptr = specifier->t_intervalHead;
    current_se_interval_ptr = specialEvent->se_intervalHead;

    for (i = 0; i < total_t_intervals; i++) {
	/*  GET TOTAL NUMBER OF SUB_INTERVALS  */
	total_sub_intervals = current_se_interval_ptr->number_of_sub_intervals;

	current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
	for (j = 0; j < total_sub_intervals; j++) {
	    total_intervals++;
	    if (current_sub_interval_ptr->proportional)
		number_of_p_intervals++;
	    else {
		number_of_f_intervals++;
		fixed_total_duration += current_sub_interval_ptr->duration.ival;
	    }
	    current_sub_interval_ptr = current_sub_interval_ptr->next;
	}
        current_t_interval_ptr = current_t_interval_ptr->next;
	current_se_interval_ptr = current_se_interval_ptr->next;
    }

    proportional_space = unity_extent_width * 
	((float)number_of_p_intervals/(float)total_intervals);
    fixed_space = unity_extent_width * 
	((float)number_of_f_intervals/(float)total_intervals);
/*
printf("\nnumber_of_p_intervals = %-d\n",number_of_p_intervals);
printf("number_of_f_intervals = %-d\n",number_of_f_intervals);
printf("fixed_total_duration = %-d\n",fixed_total_duration);
printf("proportional_space = %f\n",proportional_space);
printf("fixed_space = %f\n",fixed_space);
*/

    /*  WRITE ON CACHE BITMAP  */
    [cache lockFocus];

    /*  CLEAR THE BITMAP  */
    [cache composite:NX_CLEAR fromRect:&bounds toPoint:&bounds.origin];

    /*  DRAW VERTICAL LINES, SHADING, CONNECTING LINE, AND NODES  */
    current_x = graph_origin_x;
    current_y = zero_y;
    current_t_interval_ptr = specifier->t_intervalHead;
    current_se_interval_ptr = specialEvent->se_intervalHead;
    PSsetlinewidth(2.0);

    for (i = 0; i < total_t_intervals; i++) {
	/*  GET TOTAL NUMBER OF SUB_INTERVALS  */
	total_sub_intervals = current_se_interval_ptr->number_of_sub_intervals;

	/*  DRAW EACH SUB INTERVAL  */
	current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
	for (j = 0; j < total_sub_intervals; j++) {
	    /*  CALCULATE SUB_INTERVAL EXTENT  */
	    float sub_interval_extent;
	    if (current_sub_interval_ptr->proportional) {
	    	sub_interval_extent = 
		    proportional_space * 
			current_sub_interval_ptr->duration.fval *
			current_t_interval_ptr->duration.fval;
	    }
	    else {
	    	sub_interval_extent = fixed_space *
		 ((float)(current_sub_interval_ptr->duration.ival)/(float)fixed_total_duration);
	    }

	    /*  DRAW SHADED RECTANGLE IF FIXED INTERVAL  */
	    PSsetgray(BLACK);
	    if (!(current_sub_interval_ptr->proportional)) {
	    	PSsetalpha(0.333);
	    	PSrectfill(current_x, graph_origin_y, sub_interval_extent, extent_height);
	    }
	    
	    /*  DRAW VERTICAL GREY LINE  */
	    if (j != 0) {
		PSsetalpha(0.666);
		PSmoveto(current_x,graph_origin_y);
		PSrlineto(0.0,extent_height);
		PSstroke();
	    }

	    /*  DRAW VERTICAL LINE AND NODE FOR MAJOR (EXCEPT FOR FIRST INTERVAL)  */
            PSsetalpha(1.0);

	    if ((j == 0) && (i != 0)) {
	    	PSrectfill(current_x + NODE_OFFSET, current_y + NODE_OFFSET,NODE_SIZE,NODE_SIZE);
	    	PSmoveto(current_x, graph_origin_y);
	    	PSrlineto(0.0, extent_height);
	    }

	    /*  DRAW CONNECTING LINE  */
	    PSmoveto(current_x, current_y);
	    PSlineto(current_x + sub_interval_extent, 
		zero_y + ((current_sub_interval_ptr->rise)/full_range) * unity_extent_height);
	    PSstroke();

	    /*  DRAW REGRESSION BAR IF NECESSARY  */
	    if (current_t_interval_ptr->regression)
	    	PSrectfill(current_x, REGRESSION_Y, sub_interval_extent, REGRESSION_HEIGHT);
	    else {
	    	PSsetgray(LIGHT_GRAY);
	        PSrectfill(current_x, REGRESSION_Y, sub_interval_extent, REGRESSION_HEIGHT);
	    }

	    /*  UPDATE POINTER TO INTERVAL, CURRENT X, AND CURRENT Y  */
	    current_x += sub_interval_extent;
	    current_y = zero_y +
		(((current_sub_interval_ptr->rise)/full_range) * unity_extent_height);

	    current_sub_interval_ptr = current_sub_interval_ptr->next;
	}
        current_t_interval_ptr = current_t_interval_ptr->next;
	current_se_interval_ptr = current_se_interval_ptr->next;
    }

    [cache unlockFocus];
    [self display];
    return self;
}



- zoomInDisplay:(specifierStructPtr)specifier:(specialEventStructPtr)specialEvent:
                (se_intervalPtr)se_Interval:(int)regression
{
    int i;
    int total_sub_intervals;
    float current_x, current_y;

    float proportional_sub_space;
    float fixed_sub_space;

    int fixed_total_sub_duration;
    int number_of_p_intervals;
    int number_of_f_intervals;

    sub_intervalPtr current_sub_interval_ptr;

    /*  GET TOTAL NUMBER OF SUB_INTERVALS  */
    total_sub_intervals = se_Interval->number_of_sub_intervals;

    /*  FIND FIXED AND PROPORTIONAL SE_SPACE  */
    number_of_p_intervals = number_of_f_intervals = 0;
    fixed_total_sub_duration = 0;
    current_sub_interval_ptr = se_Interval->sub_intervalHead;
    for (i = 0; i < total_sub_intervals; i++) {
	if (current_sub_interval_ptr->proportional)
	    number_of_p_intervals++;
	else {
	    number_of_f_intervals++;
	    fixed_total_sub_duration += current_sub_interval_ptr->duration.ival;
	}
	
        current_sub_interval_ptr = current_sub_interval_ptr->next;
    }
    proportional_sub_space = unity_extent_width * 
	((float)number_of_p_intervals/(float)total_sub_intervals);
    fixed_sub_space = unity_extent_width * 
	((float)number_of_f_intervals/(float)total_sub_intervals);
/*
printf("number_of_p_intervals = %-d\n",number_of_p_intervals);
printf("number_of_f_intervals = %-d\n",number_of_f_intervals);
printf("fixed_total_sub_duration = %-d\n",fixed_total_sub_duration);
printf("proportional_sub_space = %f\n",proportional_sub_space);
printf("fixed_sub_space = %f\n",fixed_sub_space);
*/

    /*  WRITE ON CACHE BITMAP  */
    [cache lockFocus];

    /*  CLEAR THE BITMAP  */
    [cache composite:NX_CLEAR fromRect:&bounds toPoint:&bounds.origin];

    /*  DRAW SHADING, CONNECTING LINE, AND NODES  */
    current_x = graph_origin_x;
    /*  FIND PREVIOUS INTERVAL Y  */
    if (se_Interval->previous == NULL) {
	current_y = zero_y;
    }
    else {
	current_sub_interval_ptr = se_Interval->previous->sub_intervalHead;
	for (i = 1; i < se_Interval->previous->number_of_sub_intervals; i++)
	    current_sub_interval_ptr = current_sub_interval_ptr->next;
	current_y = zero_y + (((current_sub_interval_ptr->rise)/full_range) * unity_extent_height);
    }

    /*  LOOP THROUGH EACH SUB-INTERVAL  */
    current_sub_interval_ptr = se_Interval->sub_intervalHead;
    PSsetlinewidth(2.0);
    for (i = 0; i < total_sub_intervals; i++) {
	/*  CALCULATE SUB_INTERVAL EXTENT  */
	float sub_interval_extent;
	if (current_sub_interval_ptr->proportional) {
	    sub_interval_extent = 
		proportional_sub_space * current_sub_interval_ptr->duration.fval;
	}
	else {
	    sub_interval_extent = fixed_sub_space *
		((float)(current_sub_interval_ptr->duration.ival)/(float)fixed_total_sub_duration);
	}
	
	/*  DRAW SHADED RECTANGLE IF FIXED INTERVAL  */
	PSsetgray(BLACK);
	if (!(current_sub_interval_ptr->proportional)) {
	    PSsetalpha(0.333);
	    PSrectfill(current_x, graph_origin_y, sub_interval_extent, extent_height);
	}

	/*  DRAW VERTICAL GREY LINE  */
	if (i != 0) {
	    PSsetalpha(0.666);
	    PSmoveto(current_x,graph_origin_y);
	    PSrlineto(0.0,extent_height);
	    PSstroke();
	}

	/*  DRAW NODE FOR MAJOR EVENT POINT (EXCEPT FOR ANCHOR POINTS)  */
	PSsetalpha(1.0);
	if ((i == 0) && (se_Interval->previous == NULL)) {
	    ;  /* ANCHOR POINT */
	}
	else {
	    PSrectfill(current_x + NODE_OFFSET, current_y + NODE_OFFSET,NODE_SIZE,NODE_SIZE);
	}

	/*  DRAW CONNECTING LINE  */
	PSmoveto(current_x, current_y);
	PSlineto(current_x + sub_interval_extent, 
		  zero_y + ((current_sub_interval_ptr->rise)/full_range) * unity_extent_height);
	PSstroke();
	
	/*  DRAW REGRESSION BAR IF NECESSARY  */
	if (regression)
	    PSrectfill(current_x, REGRESSION_Y, sub_interval_extent, REGRESSION_HEIGHT);
	else {
	    PSsetgray(LIGHT_GRAY);
	    PSrectfill(current_x, REGRESSION_Y, sub_interval_extent, REGRESSION_HEIGHT);
	}
	
	/*  UPDATE POINTER TO INTERVAL, CURRENT X, AND CURRENT Y  */
	current_x += sub_interval_extent;
	current_y = zero_y +
	    (((current_sub_interval_ptr->rise)/full_range) * unity_extent_height);
	
	current_sub_interval_ptr = current_sub_interval_ptr->next;
    }
    /*  DRAW FINAL NODE IF NOT LAST SE INTERVAL  */
    PSsetgray(BLACK);
    if (se_Interval->next != NULL)
	PSrectfill(current_x + NODE_OFFSET, current_y + NODE_OFFSET,NODE_SIZE,NODE_SIZE);

    [cache unlockFocus];
    [self display];
    return self;
}



@end
