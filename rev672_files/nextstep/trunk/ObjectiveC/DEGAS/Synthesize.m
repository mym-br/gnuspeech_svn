
/* Generated by Interface Builder */

#import "Synthesize.h"
#import "Template.h"
#import "PhoneDescription.h"
#import "TileScrollView.h"
#import "Generate.h"
#import <math.h>
#import <ctype.h>
#import <appkit/appkit.h>


/*  GLOBAL VARIABLES (LOCAL TO THIS FILE)  */
    static float center_pitch;
    static synthParameterList parameter[NUMBER_SYNTH_PARAMETERS];
    static DSPFix24 *page_index;
    static void write_table_to_page();


@implementation Synthesize

- appDidInit:sender
{
    /*  SET UP SPEED CONTROLS  */
    [speedForm setFloatingPointFormat:NO left:1 right:2];
    [speedSlider setMinValue:SPEED_MINIMUM];
    [speedSlider setMaxValue:SPEED_MAXIMUM];

    /*  SET UP DISPLAY CONTROLS  */
    [hscaleForm setFloatingPointFormat:NO left:2 right:0];
    [hscaleSlider setMinValue:DISPLAY_HSCALE_MINIMUM];
    [hscaleSlider setMaxValue:DISPLAY_HSCALE_MAXIMUM];

    [vscaleForm setFloatingPointFormat:NO left:3 right:0];
    [vscaleSlider setMinValue:DISPLAY_VSCALE_MINIMUM];
    [vscaleSlider setMaxValue:DISPLAY_VSCALE_MAXIMUM];

    [valueForm setFloatingPointFormat:NO left:5 right:2];
    [sampleForm setFloatingPointFormat:NO left:5 right:2];
    [timeForm setFloatingPointFormat:NO left:5 right:2];

    [self defaultSwitchHit:self];

    /*  INITIALIZE DIPHONE LIST FOR DISPLAY  */
    number_of_diphones_display = 0;
    diphoneDisplayHead = NULL;

    /*  INITIALIZE DIPHONE LIST FOR SYNTHESIS  */
    number_of_diphones_synth = 0;
    diphoneSynthHead = NULL;

    /*  INITIALIZE DISPLAY PARAMETER LIST  */
    number_of_display_parameters = 0;
    displayParameterHead = NULL;

    /*  INITIALIZE TABLE MEMORY VARIABLES  */
    page_start = NULL;
    npages = 0;

    /*  INITIALIZE THE SYNTHESIZER  */
    initialize_synthesizer_module();

    return self;
}


- setTitleBar:(char *)currentPath
{
    char buffer[MAXPATHLEN+25];

    /*  ADD FILENAME TO TITLE OF EACH WINDOW  */
    strcpy(buffer,"Synthesize Utterance:   ");
    strcat(buffer,currentPath);
    [synthesizeWindow setTitle:(const char *)buffer];

    return self;
}



- display:sender
{
    /*  EVALUATE THE INPUT, PRODUCE LIST OF DISPLAY DIPHONES  */
    if ([self evaluateInput:&diphoneDisplayHead:&number_of_diphones_display] == ERROR)
	return self;

    /*  DO DIPHONE DISPLAY  */
    [diphoneView diphoneDisplay:self];

    /*  SYNC DISPLAY VALUES  */
    display_vscale = vscale_value;
    display_hscale = hscale_value;
    display_sample_length = [template sampleValue];

    return self;
}



- synthesize:sender
{
    /*  EVALUATE THE INPUT, PRODUCE LIST OF SYNTHESIZER DIPHONES  */
    if ([self evaluateInput:&diphoneSynthHead:&number_of_diphones_synth] == ERROR)
	return self;

    /*  DO ACTUAL SYNTHESIS (OTHER SYNTHESIZERS WILL BE ADDED HERE)  */
    if (synthesizer_type == SYNTH_SWITCH_FORMANT) {
	[self formantSynthesizer];
    }

    /*  IF AUTOMATIC REDISPLAY, THEN PUSH REDISPLAY BUTTON  */
    if (redisplay)
	[self display:self];

    /*  SELECT INPUT TEXT FIELD  */
    [entryForm selectText:self];

    return self;
}



- (int)evaluateInput:(diphoneListPtr *)diphoneHead:(int *)number_of_diphones
{
    int i, j;
    char *input;

    int input_type;

    phoneListPtr phoneHead = NULL;
    int number_of_phones = 0;

    phoneListPtr current_phone_ptr = NULL, temp_phone_ptr, new_phoneList_node();
    void free_phoneList_node();

    diphoneListPtr current_diphone_ptr, temp_diphone_ptr, new_diphoneList_node();
    void free_diphoneList_node();

    char symbol[SYMBOL_LENGTH_MAX+1], symbol1[SYMBOL_LENGTH_MAX+1], symbol2[SYMBOL_LENGTH_MAX+1];
    char diphone_symbol[DIPHONE_LENGTH_MAX+1], old_diphone_symbol[DIPHONE_LENGTH_MAX+1];

    int size_of_buffer = 0;
    char *buffer;

    /*  GET INPUT FROM FORM  */
    input = (char *)[entryForm stringValue];

    /*  CHECK FOR NULL ENTRY  */
    if (strlen(input) == 0) {
	NXBeep();
        NXRunAlertPanel("No input",
			"Enter some phones or diphones.",
			"OK", NULL, NULL);
	[entryForm selectText:self];
	[resultForm setStringValue:""];
	return(ERROR);
    }

    /*  DETERMINE IF INPUT CONSISTS OF PHONES OR DIPHONES  */
    input_type = INPUT_PHONE;
    for (i = 0; i < strlen(input); i++) {
	if (input[i] == diphone_marker) {
	    input_type = INPUT_DIPHONE;
	    break;
	}
    }

    /*  IF AUTOMATIC SILENCE REQUESTED, MAKE SURE SILENT PHONE IS DEFINED  */
    if ( ((input_type == INPUT_PHONE) && add_silent_phones) ||
	 ((input_type == INPUT_DIPHONE) && add_silent_diphones) ) {
	if (![template usedAsPhoneSymbol:silent_phone]) {
	    NXBeep();
	    NXRunAlertPanel("Undefined phone",
			    "The silent phone:  %s\n is not defined in the Template.\n",
			    "OK", NULL, NULL, silent_phone);
	    [entryForm selectText:self];
	    [resultForm setStringValue:""];
	    return(ERROR);
	}
    }


    /*  IF INPUT CONSISTS OF PHONES, CREATE PHONE LIST, 
	ADDING SILENCE IF REQUESTED  */
    if (input_type == INPUT_PHONE) {
	/*  ADD BEGINNING SILENCE IF REQUESTED  */
	if (add_silent_phones) {
	    current_phone_ptr = phoneHead = new_phoneList_node();
	    strcpy(current_phone_ptr->symbol,silent_phone);
	    current_phone_ptr->next = NULL;
	    number_of_phones++;
	}
	/*  EVALUATE INPUT PHONES  */
	j = 0;
	for (i = 0; i < strlen(input); i++) {
	    /*  SKIP INPUT BLANKS  */
	    if (input[i] == ' ')
		continue;
	    else {
		/*  IF NOT BLANK, ADD TO SYMBOL  */
		symbol[j++] = input[i];
		/*  CHECK FOR TOO LONG OF A SYMBOL  */
		if ((j >= SYMBOL_LENGTH_MAX) && (input[i+1] != ' ') && (input[i+1] != '\0')) {
		    NXBeep();
		    NXRunAlertPanel("Incorrect input",
			"The symbol entered is too long.\nTry putting in some blanks.",
			"OK", NULL, NULL);
		    [entryForm selectText:self];
		    [resultForm setStringValue:""];
		    return(ERROR);
		}
		/*  IF NEXT CHAR A BLANK OR NULL, THEN PROCESS SYMBOL  */
		if ((input[i+1] == ' ') || (input[i+1] == '\0')) {
		    /*  FINISH STRING WITH A NULL  */
		    symbol[j] = '\0';
		    /*  CHECK TO MAKE SURE SYMBOL IS IN TEMPLATE  */
		    if (![template usedAsPhoneSymbol:symbol]) {
			NXBeep();
			NXRunAlertPanel("Undefined phone",
			    "The phone:  %s\n is not defined in the Template.\n",
			    "OK", NULL, NULL, symbol);
			[entryForm selectText:self];
			[resultForm setStringValue:""];
			return(ERROR);
		    }
		    /*  ADD SYMBOL TO PHONE LIST  */
		    if (number_of_phones == 0) {
			current_phone_ptr = phoneHead = new_phoneList_node();
		    }
		    else {
			current_phone_ptr->next = new_phoneList_node();
			current_phone_ptr = current_phone_ptr->next;
		    }
		    strcpy(current_phone_ptr->symbol,symbol);
		    current_phone_ptr->next = NULL;
		    number_of_phones++;
		    /*  RESET SYMBOL INDEX  */
		    j = 0;
		}
	    }
	}
	/*  ADD END SILENCE IF REQUESTED  */
	if (add_silent_phones) {
	    current_phone_ptr->next = new_phoneList_node();
	    current_phone_ptr = current_phone_ptr->next;
	    strcpy(current_phone_ptr->symbol,silent_phone);
	    current_phone_ptr->next = NULL;
	    number_of_phones++;
	}
    }
    /*  IF INPUT CONSISTS OF DIPHONES, CREATE PHONE LIST  */
    else {
	/*  ADD BEGINNING SILENCE IF REQUESTED  */
	if (add_silent_diphones) {
	    current_phone_ptr = phoneHead = new_phoneList_node();
	    strcpy(current_phone_ptr->symbol,silent_phone);
	    current_phone_ptr->next = NULL;
	    number_of_phones++;
	}
	/*  EVALUATE INPUT DIPHONES  */
	j = 0;  old_diphone_symbol[0] = '\0';
	for (i = 0; i < strlen(input); i++) {
	    /*  SKIP INPUT BLANKS  */
	    if (input[i] == ' ')
		continue;
	    else {
		/*  IF NOT BLANK, ADD TO SYMBOL  */
		diphone_symbol[j++] = input[i];

		/*  CHECK FOR TOO LONG OF A SYMBOL  */
		if ((j >= DIPHONE_LENGTH_MAX) && 
		  (input[i+1] != ' ') && (input[i+1] != '\0')) {
		    NXBeep();
		    NXRunAlertPanel("Incorrect input",
			"The symbol entered is too long.\nTry putting in some blanks.",
			"OK", NULL, NULL);
		    [entryForm selectText:self];
		    [resultForm setStringValue:""];
		    return(ERROR);
		}

		/*  IF NEXT CHAR A BLANK OR NULL, THEN PROCESS SYMBOL  */
		if ((input[i+1] == ' ') || (input[i+1] == '\0')) {
		    int k, number_of_markers = 0;

		    /*  FINISH STRING WITH A NULL  */
		    diphone_symbol[j] = '\0';

		    /*  MAKE SURE DIPHONE SYMBOL CONTAINS ONLY ONE DIPHONE MARKER  */
		    for (k = 0; k < strlen(diphone_symbol); k++) {
			if (diphone_symbol[k] == diphone_marker)
			    number_of_markers++;
		    }
		    if (number_of_markers < 1) {
			NXBeep();
			NXRunAlertPanel("Incorrect input",
			    "The string:  %s\nshould have a diphone marker.\n",
			    "OK", NULL, NULL, diphone_symbol);
			[entryForm selectText:self];
			[resultForm setStringValue:""];
			return(ERROR);
		    }
		    if (number_of_markers > 1) {
			NXBeep();
			NXRunAlertPanel("Incorrect input",
			    "The string:  %s\n should have only one diphone marker.\n",
			    "OK", NULL, NULL, diphone_symbol);
			[entryForm selectText:self];
			[resultForm setStringValue:""];
			return(ERROR);
		    }

		    /*  MAKE SURE THE MARKER IS IN MIDDLE SOMEWHERE  */
		    for (k = 0; k < strlen(diphone_symbol); k++) {
			if (diphone_symbol[k] == diphone_marker) {
			    if ((k == 0) || (k == (strlen(diphone_symbol)-1))) {
				NXBeep();
				NXRunAlertPanel("Incorrect input",
	      "The diphone marker %c must be used\nto separate 2 phones in\nthe string:  %s.",
				   "OK", NULL, NULL, diphone_marker, diphone_symbol);
				[entryForm selectText:self];
				[resultForm setStringValue:""];
				return(ERROR);

			    }
			}
		    }

		    /*  MAKE SURE INDIVIDUAL SYMBOLS NOT TOO LONG  */
		    if (strlen(index(diphone_symbol,diphone_marker)+1) > SYMBOL_LENGTH_MAX) {
			NXBeep();
			NXRunAlertPanel("Incorrect input",
			  "The symbol entered is too long.\nTry putting in some blanks.",
			  "OK", NULL, NULL);
			[entryForm selectText:self];
			[resultForm setStringValue:""];
			return(ERROR);
		    }
		    if ((strlen(diphone_symbol) - strlen(index(diphone_symbol,diphone_marker))) >
		      SYMBOL_LENGTH_MAX) {
			NXBeep();
			NXRunAlertPanel("Incorrect input",
			  "The symbol entered is too long.\nTry putting in some blanks.",
			  "OK", NULL, NULL);
			[entryForm selectText:self];
			[resultForm setStringValue:""];
			return(ERROR);
		    }

		    /*  SEPARATE THE DIPHONE INTO TWO SYMBOLS  */
		    strcpy(symbol2,index(diphone_symbol,diphone_marker)+1);
		    strncpy(symbol1,diphone_symbol,(strlen(diphone_symbol)-strlen(symbol2)-1));
		    symbol1[(strlen(diphone_symbol)-strlen(symbol2)-1)] = '\0';

		    /*  CHECK TO MAKE SURE SYMBOLS ARE IN THE TEMPLATE  */
		    if (![template usedAsPhoneSymbol:symbol1]) {
			NXBeep();
			NXRunAlertPanel("Undefined phone",
			    "The phone:  %s\n is not defined in the Template.\n",
			    "OK", NULL, NULL, symbol1);
			[entryForm selectText:self];
			[resultForm setStringValue:""];
			return(ERROR);
		    }
		    if (![template usedAsPhoneSymbol:symbol2]) {
			NXBeep();
			NXRunAlertPanel("Undefined phone",
			    "The phone:  %s\n is not defined in the Template.\n",
			    "OK", NULL, NULL, symbol2);
			[entryForm selectText:self];
			[resultForm setStringValue:""];
			return(ERROR);
		    }

		    /*  MAKE SURE NO DISJUCTION BETWEEN DIPHONES  */
		    if ( (strlen(old_diphone_symbol) != 0) &&
			 (strcmp((index(old_diphone_symbol,diphone_marker)+1),symbol1)) ) {
			NXBeep();
			NXRunAlertPanel("Incorrect Input",
			    "Disjunction between the diphones\n%s  and  %s",
			    "OK", NULL, NULL, old_diphone_symbol, diphone_symbol);
			[entryForm selectText:self];
			[resultForm setStringValue:""];
			return(ERROR);
		    }

		    /*  ADD FIRST SYMBOL TO PHONE LIST  */
		    if (number_of_phones == 0) {
			current_phone_ptr = phoneHead = new_phoneList_node();
		    }
		    else {
			current_phone_ptr->next = new_phoneList_node();
			current_phone_ptr = current_phone_ptr->next;
		    }
		    strcpy(current_phone_ptr->symbol,symbol1);
		    current_phone_ptr->next = NULL;
		    number_of_phones++;

		    /*  ONLY ADD SECOND SYMBOL TO PHONE LIST IF LAST DIPHONE  */
		    if (i == (strlen(input)-1)) {
			current_phone_ptr->next = new_phoneList_node();
			current_phone_ptr = current_phone_ptr->next;
			strcpy(current_phone_ptr->symbol,symbol2);
			current_phone_ptr->next = NULL;
			number_of_phones++;
		    }

		    /*  RESET SYMBOL INDEX, SET UP OLD DIPHONE SYMBOL  */
		    j = 0;
		    strcpy(old_diphone_symbol,diphone_symbol);
		}
	    }
	}
	/*  ADD END SILENCE IF REQUESTED  */
	if (add_silent_diphones) {
	    current_phone_ptr->next = new_phoneList_node();
	    current_phone_ptr = current_phone_ptr->next;
	    strcpy(current_phone_ptr->symbol,silent_phone);
	    current_phone_ptr->next = NULL;
	    number_of_phones++;
	}
    }

    /*  MAKE SURE THERE ARE AT LEAST TWO PHONES  */
    if (number_of_phones <= 1) {
	NXBeep();
	NXRunAlertPanel("Incorrect Input",
			"There must be at least 2 phones entered.",
			"OK", NULL, NULL);
	[entryForm selectText:self];
	[resultForm setStringValue:""];
	return(ERROR);
    }

    /*  FREE OLD DIPHONE LIST IF NECESSARY  */
    current_diphone_ptr = *diphoneHead;
    for (i = 0; i < *number_of_diphones; i++) {
	temp_diphone_ptr = current_diphone_ptr;
	current_diphone_ptr = current_diphone_ptr->next;
	free_diphoneList_node(temp_diphone_ptr);	
    }
    *number_of_diphones = 0;
    *diphoneHead = NULL;

    /*  CREATE DIPHONE LIST FROM PHONE LIST  */
    *number_of_diphones = number_of_phones - 1;
    current_phone_ptr = phoneHead;
    for (i = 0; i < *number_of_diphones; i++) {
	if (i == 0) {
	    current_diphone_ptr = *diphoneHead = new_diphoneList_node();
	}
	else {
	    current_diphone_ptr->next = new_diphoneList_node();
	    current_diphone_ptr = current_diphone_ptr->next;
	}
	/*  ASSIGN SYMBOLS  */
	strcpy(current_diphone_ptr->symbol1,current_phone_ptr->symbol);
	strcpy(current_diphone_ptr->symbol2,current_phone_ptr->next->symbol);
	/*  KEEP TRACK OF TOTAL NUMBER OF CHARS  */
	size_of_buffer += 
	    (strlen(current_diphone_ptr->symbol1) + 1 +
	     strlen(current_diphone_ptr->symbol2) + strlen(DIPHONE_SPACING));
	/*  UPDATE PHONE POINTER  */
	current_phone_ptr = current_phone_ptr->next;
    }
    /*  ALLOW FOR NULL TERMINATOR  */
    size_of_buffer++;

    /*  FREE PHONE LIST  */
    current_phone_ptr = phoneHead;
    for (i = 0; i < number_of_phones; i++) {
	temp_phone_ptr = current_phone_ptr;
	current_phone_ptr = current_phone_ptr->next;
	free_phoneList_node(temp_phone_ptr);	
    }

    /*  PRINT DIPHONE LIST TO RESULT FORM  */
    buffer = (char *)calloc(size_of_buffer,sizeof(char));
    current_diphone_ptr = *diphoneHead;  j = 0;
    for (i = 0; i < *number_of_diphones; i++) {
	sprintf(&buffer[j],"%s%c%s%s",
	  current_diphone_ptr->symbol1,diphone_marker,
	  current_diphone_ptr->symbol2,DIPHONE_SPACING);
	current_diphone_ptr = current_diphone_ptr->next;
	j = strlen(buffer);
    }
    [resultForm setStringValue:buffer];

    /*  FREE BUFFER MEMORY  */
    cfree(buffer);

    return(NO_ERROR);
}




- typeSwitchHit:sender
{
    /*  SET SYNTHESIZER TYPE  */
    synthesizer_type = [sender selectedRow];

    return self;
}




- speedSwitchHit:sender
{
    /*  SET SPEED TYPE  */
    synthesizer_speed_type = [sender selectedRow];

    return self;
}




- speedSliderMoved:sender
{
    /*  SET ASSOCIATED FORM, IT ROUNDS FOR US  */
    [speedForm setFloatValue:[sender floatValue]];

    /*  GET VALUE OF SPEED  */
    synthesizer_speed = [speedForm floatValue];

    return self;
}




- pitchSwitchHit:sender
{
    int nint();

    /*  REMEMBER OLD PITCH TYPE  */
    int old_pitch_type = pitch_type;

    /*  SET PITCH TYPE  */
    pitch_type = [sender selectedRow];

    /*  IF PITCH TYPE CHANGED, CONVERT PITCH TO OTHER FORM, CHANGE TEXT  */
    if (pitch_type != old_pitch_type) {
	if (pitch_type == PITCH_SWITCH_FREQ) {
	    /*  CHANGE DISPLAY SETTINGS  */
	    [pitchForm setFloatingPointFormat:0 left:4 right:2];
	    [pitchSlider setMinValue:PITCH_FREQ_MINIMUM];
	    [pitchSlider setMaxValue:PITCH_FREQ_MAXIMUM];
	    /*  CONVERT FROM PITCH TO FREQUENCY  */
	    pitch.frequency = convert_to_frequency(pitch.pitch);
	    [pitchForm setFloatValue:pitch.frequency];
	    [pitchSlider setFloatValue:pitch.frequency];
	    /*  CHANGE TEXT  */
	    [pitchText setStringValue:PITCH_TEXT_FREQ];
	}
	else {
	    /*  CHANGE DISPLAY SETTINGS  */
	    [pitchForm setFloatingPointFormat:0 left:2 right:0];
	    [pitchSlider setMinValue:PITCH_PITCH_MINIMUM];
	    [pitchSlider setMaxValue:PITCH_PITCH_MAXIMUM];
	    /*  CONVERT FROM FREQUENCY TO NEAREST PITCH  */
	    pitch.pitch = nint(convert_to_pitch(pitch.frequency));
	    [pitchForm setFloatValue:pitch.pitch];
	    [pitchSlider setFloatValue:pitch.pitch];
	    /*  CHANGE TEXT  */
	    [pitchText setStringValue:PITCH_TEXT_PITCH];
	}
    }

    return self;
}




- pitchSliderMoved:sender
{
    /*  GET VALUE OF SLIDER  */
    if (pitch_type == PITCH_SWITCH_FREQ) {
	pitch.frequency = [sender floatValue];
	[pitchForm setFloatValue:pitch.frequency];
    }
    else {
	pitch.pitch = [sender intValue];
	[pitchForm setIntValue:pitch.pitch];
    }

    return self;
}




- displaySwitchHit:sender
{
    /*  SET DISPLAY TYPE  */
    display_type = [sender selectedRow];

    return self;
}




- redisplaySwitchHit:sender
{
    redisplay = [sender state];

    return self;
}



- gridSwitchHit:sender
{
    grid = [sender state];

    return self;
}



- hscaleSliderMoved:sender
{
    /*  GET HSCALE VALUE  */
    hscale_value = [sender intValue];

    /*  SET ASSOCIATED FORM  */
    [hscaleForm setIntValue:hscale_value];

    return self;
}




- vscaleSliderMoved:sender
{
    /*  GET VSCALE VALUE  */
    vscale_value = [sender intValue];

    /*  SET ASSOCIATED FORM  */
    [vscaleForm setIntValue:vscale_value];
    return self;
}




- markerEntered:sender
{
    int i;
    char *marker;

    /*  GET POINTER TO VALUE  */
    marker = (char *)[sender stringValue];

    /*  MAKE SURE MARKER IS OF LENGTH ONE  */
    if (strlen(marker) != 1) {
	NXBeep();
        NXRunAlertPanel("Illegal",
			"Marker must be one character long.",
			"OK", NULL, NULL);
	[sender selectText:self];
	return self;
    }

    /*  MAKE SURE MARKER IS VISIBLE CHARACTER  */
    if (!isgraph(*marker)) {
	NXBeep();
        NXRunAlertPanel("Illegal",
			"Marker must a visible, non-control character.",
			"OK", NULL, NULL);
	[sender selectText:self];
	return self;
    }

    /*  MAKE SURE SILENT PHONE AND DIPHONE MARKER ARE NOT IDENTICAL  */
    for (i = 0; i < strlen(silent_phone); i++) {
	if (silent_phone[i] == *marker) {
	    NXBeep();
	    NXRunAlertPanel("Illegal",
			    "Diphone marker cannot be contained\nin the silent phone.",
			    "OK", NULL, NULL);
	    [sender selectText:self];
	    return self;
	}
    }

    /*  SET VALUE OF MARKER  */
    diphone_marker = *marker;

    return self;
}



- silentPhoneEntered:sender
{
    char *phone;
    int i;

    /*  GET POINTER TO VALUE  */
    phone = (char *)[sender stringValue];

    /*  MAKE SURE STRING VALUE IS NOT TOO LONG  */
    if (strlen(phone) > SYMBOL_LENGTH_MAX) {
	NXBeep();
        NXRunAlertPanel("Illegal",
			"Maximum of %-d characters allowed.",
			"OK", NULL, NULL, SYMBOL_LENGTH_MAX);
	[sender selectText:self];
	return self;
    }

    /*  MAKE SURE ALL CHARACTERS ARE VISIBLE, NON-CONTROL CHARACTERS  */
    for (i = 0; i < strlen(phone); i++) {
	if (!isgraph(phone[i])) {
	    NXBeep();
	    NXRunAlertPanel("Illegal",
			    "Space or control characters not\nallowed in symbol.",
			    "OK", NULL, NULL);
	    [sender selectText:self];
	    return self;
	}
    }
    /*  MAKE SURE SILENT PHONE AND DIPHONE MARKER ARE NOT IDENTICAL  */
    for (i = 0; i < strlen(phone); i++) {
	if (phone[i] == diphone_marker) {
	    NXBeep();
	    NXRunAlertPanel("Illegal",
			    "Silent phone cannot contain\nthe diphone marker.",
			    "OK", NULL, NULL);
	    [sender selectText:self];
	    return self;
	}
    }

    /*  COPY STRING INTO SILENT PHONE SYMBOL BUFFER  */
    strcpy(silent_phone,phone);

    return self;
}



- silentSwitchPhonesHit:sender
{
    add_silent_phones = [sender state];
    return self;
}



- silentSwitchDiphonesHit:sender
{
    add_silent_diphones = [sender state];
    return self;
}



- defaultSwitchHit:sender
{
    /*  RESET SYNTHESIZER TYPE  */
    synthesizer_type = SYNTH_SWITCH_FORMANT;
    [typeSwitch selectCell:[typeSwitch cellAt:SYNTH_SWITCH_FORMANT:0]];

    /*  RESET SPEED  */
    synthesizer_speed_type = SPEED_SWITCH_REGRESS;
    synthesizer_speed = SPEED_DEFAULT;
    [speedSwitch selectCell:[speedSwitch cellAt:SPEED_SWITCH_REGRESS:0]];
    [speedForm setFloatValue:SPEED_DEFAULT];
    [speedSlider setFloatValue:SPEED_DEFAULT];

    /*  RESET CENTER PITCH  */
    pitch_type = PITCH_SWITCH_PITCH;
    pitch.pitch = PITCH_PITCH_DEFAULT;
    pitch.frequency = convert_to_frequency(pitch.pitch);
    [pitchSwitch selectCell:[pitchSwitch cellAt:PITCH_SWITCH_PITCH:0]];
    [pitchText setStringValue:PITCH_TEXT_PITCH];
    [pitchForm setFloatingPointFormat:0 left:2 right:0];
    [pitchForm setFloatValue:PITCH_PITCH_DEFAULT];
    [pitchSlider setMinValue:PITCH_PITCH_MINIMUM];
    [pitchSlider setMaxValue:PITCH_PITCH_MAXIMUM];
    [pitchSlider setFloatValue:pitch.pitch];
    

    /*  RESET DISPLAY SETTINGS  */
    display_type = DISPLAY_SWITCH_ALL;
    redisplay = ON;
    [displaySwitch selectCell:[displaySwitch cellAt:DISPLAY_SWITCH_ALL:0]];
    [redisplaySwitch setState:ON];
    grid = ON;
    [gridSwitch setState:ON];
    [hscaleForm setIntValue:DISPLAY_HSCALE_DEFAULT];
    [hscaleSlider setIntValue:DISPLAY_HSCALE_DEFAULT];
    hscale_value = DISPLAY_HSCALE_DEFAULT;
    [vscaleForm setIntValue:DISPLAY_VSCALE_DEFAULT];
    [vscaleSlider setIntValue:DISPLAY_VSCALE_DEFAULT];
    vscale_value = DISPLAY_VSCALE_DEFAULT;

    /*  RESET PHONE OR DIPHONE ENTRY  */
    [markerForm setStringValue:MARKER_DEFAULT];
    diphone_marker = *[markerForm stringValue];
    [silentPhoneForm setStringValue:SILENT_PHONE_DEFAULT];
    strcpy(silent_phone,[silentPhoneForm stringValue]);
    [silentSwitchPhones setState:ON];
    add_silent_phones = ON;
    [silentSwitchDiphones setState:OFF];
    add_silent_diphones = OFF;

    return self;
}



- (int)numberOfDisplayParameters:(filterParamPtr *)listHead
{
    int i;

    filterParamPtr current_display_parameter_ptr = NULL, temp_display_parameter_ptr;
    filterParamPtr new_displayParameter();
    void free_displayParameter();
    
    /*  FIRST, FREE THE LIST, IF NECESSARY  */
    if (displayParameterHead != NULL) {
	current_display_parameter_ptr = displayParameterHead;
	for (i = 0; i < number_of_display_parameters; i++) {
	    temp_display_parameter_ptr = current_display_parameter_ptr;
	    current_display_parameter_ptr = current_display_parameter_ptr->next;
	    free_displayParameter(temp_display_parameter_ptr);
	}
    }
    displayParameterHead = NULL;
    number_of_display_parameters = 0;

    if (display_type == DISPLAY_SWITCH_ALL) {
	/*  BUILD LIST FROM TEMPLATE  */
	number_of_display_parameters = [template numberOfParameters];

	for (i = 0; i < number_of_display_parameters; i++) {
	    if (i == 0) {
		current_display_parameter_ptr = displayParameterHead = new_displayParameter();
	    }
	    else {
		current_display_parameter_ptr->next = new_displayParameter();
		current_display_parameter_ptr = current_display_parameter_ptr->next;
	    }
	    strcpy(current_display_parameter_ptr->symbol,[template parameterSymbol:i+1]);
	    current_display_parameter_ptr->next = NULL;
	}
	*listHead = displayParameterHead;
	return (number_of_display_parameters);
    }
    else if (display_type == DISPLAY_SWITCH_SYNTH) {
	if (synthesizer_type == SYNTH_SWITCH_FORMANT) {
	    /*  LIST CONTAINING ALL POSSIBLE PARAMETER NAMES FOR SYNTHESIZER  */
	    static char *synth_p_name[NUMBER_SYNTH_PARAMETERS] = 
	    {FORMANT_PARAM_1,FORMANT_PARAM_2,FORMANT_PARAM_3,FORMANT_PARAM_4,FORMANT_PARAM_5,
	     FORMANT_PARAM_6,FORMANT_PARAM_7,FORMANT_PARAM_8,FORMANT_PARAM_9,FORMANT_PARAM_10,
	     FORMANT_PARAM_11,FORMANT_PARAM_12,FORMANT_PARAM_13,FORMANT_PARAM_14,FORMANT_PARAM_15,
	     FORMANT_PARAM_16,FORMANT_PARAM_17,FORMANT_PARAM_18,FORMANT_PARAM_19,FORMANT_PARAM_20};
	    int number_possible_parameters, j;
	    char *temp_symbol;

	    /*  FIND NUMBER OF ALL POSSIBLE PARAMETERS IN TEMPLATE  */
	    number_possible_parameters = [template numberOfParameters];

	    /*  INITIALIZE NUMBER OF DISPLAY PARAMETERS  */
	    number_of_display_parameters = 0;

	    /*  FOR EACH PARAMETER THAT MATCHES SYNTHESIZER LIST, ADD TO LIST  */
	    for (i = 0; i < number_possible_parameters; i++) {
		temp_symbol = [template parameterSymbol:i+1];
		for (j = 0; j < NUMBER_SYNTH_PARAMETERS; j++) {
		    if (!strcmp(temp_symbol,synth_p_name[j])) {
			if (number_of_display_parameters == 0) {
			    current_display_parameter_ptr = displayParameterHead = 
				new_displayParameter();
			}
			else {
			    current_display_parameter_ptr->next = new_displayParameter();
			    current_display_parameter_ptr = current_display_parameter_ptr->next;
			}
			strcpy(current_display_parameter_ptr->symbol,temp_symbol);
			current_display_parameter_ptr->next = NULL;
			
			number_of_display_parameters++;
			break;
		    }
		}
	    }
	    *listHead = displayParameterHead;
	    return (number_of_display_parameters);
	}
	else {
	    *listHead = NULL;
	    return (0);
	}
    }
    else if (display_type == DISPLAY_SWITCH_FILTER) {
	*listHead = NULL;
	return (0);
    }

    /*  IF HERE, THEN RETURN ERROR  */
    *listHead = NULL;
    return(0);
}



- (int)numberOfDisplayDiphones:(diphoneListPtr *)listHead
{
    *listHead = diphoneDisplayHead;
    return(number_of_diphones_display);
}



- (char)diphoneMarker
{
    return(diphone_marker);
}



- (int)grid
{
    return(grid);
}



- (int)vscale
{
    return(vscale_value);
}



- (int)hscale
{
    return(hscale_value);
}



- (int)speedType
{
    return(synthesizer_speed_type);
}



- (float)speedFactor
{
    return(synthesizer_speed);
}



- trackMouse:(NXPoint *)location
{
    int i, paramFlag = OFF, diphoneFlag = OFF;
    float adjusted_length;
    NXPoint tempPoint;
    filterParamPtr current_param_ptr;
    diphoneListPtr current_diphone_ptr;

    /*  FIND PARAMETER  */
    tempPoint.y = PARAM_SEP + ((number_of_display_parameters-1) * (display_vscale+PARAM_SEP));
    current_param_ptr = displayParameterHead;
    for (i = 0; i < number_of_display_parameters; i++) {
	if ((location->y > tempPoint.y) && (location->y <= (tempPoint.y+display_vscale))) {
	    paramFlag = ON;
	    break;
	}
	current_param_ptr = current_param_ptr->next;
	tempPoint.y -= (display_vscale + PARAM_SEP);
    }
    if (paramFlag) {
	float min, max;
	/*  DISPLAY PARAMETER NAME IN FORM  */
	[parameterForm setStringValue:current_param_ptr->symbol];
	/*  CALCULATE PARAMETER VALUE  */
	min = [template parameterSymMinimum:current_param_ptr->symbol];
	max = [template parameterSymMaximum:current_param_ptr->symbol];
	[valueForm setFloatValue:
	 ((((location->y - tempPoint.y)/display_vscale) * (max - min)) + min)];
    }
    else {
	[parameterForm setStringValue:""];
	[valueForm setStringValue:""];
    }

    /*  FIND DIPHONE  */
    tempPoint.x = 0.0;
    current_diphone_ptr = diphoneDisplayHead;
    for (i = 0; i < number_of_diphones_display; i++) {
	/*  GET ADJUSTED LENGTH OF DIPHONE  */
	adjusted_length = current_diphone_ptr->length;
	if ((location->x >= tempPoint.x) && (location->x < (tempPoint.x+adjusted_length))) {
	    diphoneFlag = ON;
	    break;
	}
	current_diphone_ptr = current_diphone_ptr->next;
	tempPoint.x += adjusted_length;
    }
    if (diphoneFlag) {
	float s_length;
	/*  DISPLAY DIPHONE NAME IN FORM  */
	char buffer[(2*SYMBOL_LENGTH_MAX)+1];
	sprintf(buffer,"%s%c%s",current_diphone_ptr->symbol1,diphone_marker,
		current_diphone_ptr->symbol2);
	[diphoneForm setStringValue:buffer];
	/*  CALCULATE DIPHONE LENGTH IN SAMPLES  */
	s_length = ((location->x + 1.0) - tempPoint.x)/display_hscale;
	[sampleForm setFloatValue:s_length];
	/*  CALCULATE LENGTH IN MS  */
	[timeForm setFloatValue:(s_length * display_sample_length)];
    }
    else {
	[diphoneForm setStringValue:""];
	[sampleForm setStringValue:""];
	[timeForm setStringValue:""];
    }

    return self;
}



- stopTrackingMouse
{
    [parameterForm setStringValue:""];
    [valueForm setStringValue:""];
    [diphoneForm setStringValue:""];
    [sampleForm setStringValue:""];
    [timeForm setStringValue:""];
    return self;
}



- setDisplayDuration:(float)diphoneDuration for:(int)diphoneNumber
{
    int i;
    diphoneListPtr current_diphone_ptr;

    /*  FIND THE RIGHT DIPHONE  */
    current_diphone_ptr = diphoneDisplayHead;
    for (i = 0; i < diphoneNumber; i++)
	current_diphone_ptr = current_diphone_ptr->next;

    /*  SET THE DURATION  */
    current_diphone_ptr->length = diphoneDuration;

    return self;
}



- formantSynthesizer
{
    int i;
    vm_address_t *diphone_page;
    diphoneListPtr current_diphone_ptr;

    int number_of_synth_parameters = 0;
    filterParamPtr synthParameterHead = NULL, current_synth_parameter_ptr = NULL;
    filterParamPtr new_displayParameter(), temp_synth_parameter_ptr = NULL;
    void free_displayParameter();

    int utterance_duration, adjusted_utterance_duration;
    int nint();

    /*  USER SUPPLIED FUNCTION TO UPDATE THE GLOBAL synth_read_ptr  */
    void update_synth_ptr();

    /*  LIST CONTAINING ALL POSSIBLE PARAMETER NAMES FOR SYNTHESIZER  */
    static char *synth_p_name[NUMBER_SYNTH_PARAMETERS] = 
      {FORMANT_PARAM_1,FORMANT_PARAM_2,FORMANT_PARAM_3,FORMANT_PARAM_4,FORMANT_PARAM_5,
       FORMANT_PARAM_6,FORMANT_PARAM_7,FORMANT_PARAM_8,FORMANT_PARAM_9,FORMANT_PARAM_10,
       FORMANT_PARAM_11,FORMANT_PARAM_12,FORMANT_PARAM_13,FORMANT_PARAM_14,FORMANT_PARAM_15,
       FORMANT_PARAM_16,FORMANT_PARAM_17,FORMANT_PARAM_18,FORMANT_PARAM_19,FORMANT_PARAM_20};


    /*  DETERMINE CENTER PITCH  */
    if (pitch_type == PITCH_SWITCH_PITCH)
	center_pitch = (float)pitch.pitch;
    else
	center_pitch = convert_to_pitch(pitch.frequency);

    /*  INITIALIZE PARAMETER LIST  */
    for (i = 0; i < NUMBER_SYNTH_PARAMETERS; i++) {
	parameter[i].calculated = FALSE;
	parameter[i].delta = 0.0;
    }
    parameter[0].value = OSC_VOL_DEF;
    parameter[1].value = MICRO_INTON_DEF;
    parameter[2].value = ASP_VOL_DEF;
    parameter[3].value = FRIC_VOL_DEF;
    parameter[4].value = FR_FREQ_DEF;
    parameter[5].value = FR_BW_DEF;
    parameter[6].value = NASAL_BYPASS_DEF;
    parameter[7].value = NNF_FREQ_DEF;
    parameter[8].value = NNF_BW_DEF;
    parameter[9].value = R1_FREQ_DEF;
    parameter[10].value = R1_BW_DEF;
    parameter[11].value = R2_FREQ_DEF;
    parameter[12].value = R2_BW_DEF;
    parameter[13].value = R3_FREQ_DEF;
    parameter[14].value = R3_BW_DEF;
    parameter[15].value = R4_FREQ_DEF;
    parameter[16].value = R4_BW_DEF;
    parameter[17].value = MASTER_VOL_DEF;
    parameter[18].value = BALANCE_DEF;
    parameter[19].value = BYPASS_REG_DEF;


    /*  DETERMINE KIND AND NUMBER OF SYNTHESIZER PARAMETERS THAT ARE SPECIFIED
        IN TEMPLATE; PUT THESE IN A FILTERED LIST; SET CALCULATED INDICATOR  */
    for (i = 0; i < NUMBER_SYNTH_PARAMETERS; i++) {
	if ([template isParameter:synth_p_name[i]]) {
	    if (number_of_synth_parameters == 0) {
		current_synth_parameter_ptr = synthParameterHead = new_displayParameter();
	    }
	    else {
		current_synth_parameter_ptr->next = new_displayParameter();
		current_synth_parameter_ptr = current_synth_parameter_ptr->next;
	    }
	    strcpy(current_synth_parameter_ptr->symbol,synth_p_name[i]);
	    current_synth_parameter_ptr->next = NULL;
	    number_of_synth_parameters++;
	    /*  THIS PARAMETER IS CALCULATED  */
	    parameter[i].calculated = TRUE;
	}
    }

    /*  SET UP VM TO WRITE DIPHONES ON  */
    diphone_page = (vm_address_t *)calloc(number_of_diphones_synth,sizeof(vm_address_t));
    for (i = 0; i < number_of_diphones_synth; i++)
	vm_allocate(task_self(),(vm_address_t *)&diphone_page[i],vm_page_size,1);

    /*  WRITE DIPHONES TO VM  */
    current_diphone_ptr = diphoneSynthHead;
    for (i = 0; i < number_of_diphones_synth; i++) {
	[rule writeDiphone:current_diphone_ptr->symbol1:current_diphone_ptr->symbol2
	          :[rule governingRule:current_diphone_ptr->symbol1:current_diphone_ptr->symbol2]
	          :(filterParamPtr)synthParameterHead
                  :(FILE *)NULL:(vm_address_t)diphone_page[i]];
	current_diphone_ptr = current_diphone_ptr->next;
    }

    /*  GET TOTAL DURATION OF UTTERANCE  */
    utterance_duration = 0;
    for (i = 0; i < number_of_diphones_synth; i++) {
	int temp_i;
	int *page_offset_i;

	page_offset_i = (int *)diphone_page[i];
	temp_i = *(page_offset_i++);
	temp_i = *(page_offset_i++);
	utterance_duration += temp_i;
    }

    /*  ADJUST UTTERANCE DURATION, TAKING SPEED INTO ACCOUNT  */
    /*  GUARD TABLES ADDED IN CASE OF ACCUMULATED ROUNDING UP  */
    adjusted_utterance_duration = 
	nint((float)utterance_duration/synthesizer_speed);
    if (synthesizer_speed != 1.0)
	adjusted_utterance_duration += GUARD_TABLES;

    /*  DEALLOCATE OLD TABLE MEMORY, IF NEEDED  */
    /*  DO THIS BEFORE ALTERING npages  */
    if (page_start != NULL) {
	vm_deallocate(task_self(), (vm_address_t)page_start,
		      (vm_size_t)(vm_page_size * npages));
    }

    /*  CALCULATE NUMBER OF PAGES NEEDED FOR TABLE MEMORY  */
    npages = (int)((float)adjusted_utterance_duration/(float)TABLES_PER_PAGE) + 1;

    /*  ALLOCATE VM PAGES FOR TABLES TO BE SENT TO SYNTHESIZER  */
    vm_allocate(task_self(), (vm_address_t *)&page_start, 
		(vm_size_t)(vm_page_size * npages), 1);


    /*  CREATE PARAMETER TRACKS FOR SYNTHESIS  */
    page_index = page_start;
    current_diphone_ptr = diphoneSynthHead;
    for (i = 0; i < number_of_diphones_synth; i++) {
	int j, k, number_of_intervals, temp_i;
	int *page_offset_i;
	float *page_offset_f;
	int duration, adjusted_duration, duration_delta;

	/*  TOP OF PAGE  */
	page_offset_i = (int *)diphone_page[i];
	page_offset_f = (float *)diphone_page[i];

	number_of_intervals = *(page_offset_i++);
	page_offset_f = (float *)page_offset_i;

	duration = *(page_offset_i++);
	page_offset_f = (float *)page_offset_i;

	adjusted_duration = nint((float)duration/synthesizer_speed);
	duration_delta = adjusted_duration - duration;

	/*  LOAD IN INITIAL TARGET VALUES FOR EACH PARAMETER  */
	for (j = 0; j < NUMBER_SYNTH_PARAMETERS; j++) {
	    if (parameter[j].calculated) {
		parameter[j].value = [phoneDescriptionObj
		  getTarget:(current_diphone_ptr->symbol1):synth_p_name[j]];
	    }
	}

	for (j = 0; j < number_of_intervals; j++) {
	    float stretch_factor;

	    /*  GET DURATION OF INTERVAL  */
	    temp_i = *(page_offset_i++);
	    page_offset_f = (float *)page_offset_i;
	    duration = temp_i & 0x7FFFFFFF;

	    /*  GET STRETCH FACTOR OF INTERVAL  */
	    stretch_factor = *(page_offset_f++);
	    page_offset_i = (int *)page_offset_f;

            /*  CALCULATE ADJUSTED DURATION  */
            if (synthesizer_speed_type == SPEED_SWITCH_REGRESS)
                adjusted_duration = duration + nint((float)duration_delta * stretch_factor);
            else
                adjusted_duration = nint((float)duration/synthesizer_speed);

            /*  MAKE SURE ADJUSTED DURATION DOESN'T FALL BELOW MINIMUM  */
            if (adjusted_duration < 1)
                adjusted_duration = 1;

	    /*  CALCULATE RISE DELTA FOR EACH CALCULATED PARAMETER  */
	    for (k = 0; k < NUMBER_SYNTH_PARAMETERS; k++) {
		float rise;
		if (parameter[k].calculated) {
		    rise = *(page_offset_f++);
		    page_offset_i = (int *)page_offset_f;
		    parameter[k].delta = rise / (float)adjusted_duration;
		}
	    }

	    /*  DO ACTUAL INTERPOLATION FOR EACH SAMPLE OF INTERVAL  */
	    for (k = 0; k < adjusted_duration; k++) {
		int m;
		/*  WRITE VALUES TO TABLE MEMORY  */
		write_table_to_page();

		/*  UPDATE RISE VALUE OF CALCULATED PARAMETERS  */
		for (m = 0; m < NUMBER_SYNTH_PARAMETERS; m++) {
		    if (parameter[m].calculated) {
			parameter[m].value += parameter[m].delta;
		    }
		}
	    }
	}
	current_diphone_ptr = current_diphone_ptr->next;
    }
    /*  WRITE LAST TABLE TO MEMORY  */
    write_table_to_page();

    /*  START THE SYNTHESIZER  */
    if (start_synthesizer() != ST_NO_ERROR) {
	NXRunAlertPanel("DSP/DAC in use",
			"Some other application is using\nthe DSP/DAC hardware.",
			"OK", NULL, NULL);
	goto free_memory;
    }
    
    /*  SEND THE PAGES TO THE SYNTHESIZER THREAD  */
    /*  THE synth_read_ptr IS BACKED UP ONE PAGE, SINCE THE
	update_synth_ptr FUNCTION ADVANCES THE POINTER *BEFORE*
	THE PAGE IS SENT TO THE SYNTHESIZER  */
    synth_read_ptr = (vm_address_t)page_start - vm_page_size;
    for (i = 0; i < npages; i++) {
	/*  BLOCK WHILE WAITING; ALSO, MAKE SURE TO SIGNAL THE LAST PAGE  */
	await_request_new_page(ST_YES,
			       (i == (npages-1)) ? ST_YES : ST_NO,
			       update_synth_ptr);
    }


    /*  FREE MEMORY USED FOR FILTERED LIST  */
    free_memory:
    current_synth_parameter_ptr = synthParameterHead;
    for (i = 0; i < number_of_synth_parameters; i++) {
	temp_synth_parameter_ptr = current_synth_parameter_ptr;
	current_synth_parameter_ptr = current_synth_parameter_ptr->next;
	free_displayParameter(temp_synth_parameter_ptr);
    }

    /*  DEALLOCATE DIPHONE PAGES VM  */
    for (i = 0; i < number_of_diphones_synth; i++)
	vm_deallocate(task_self(),diphone_page[i],vm_page_size);

    /*  FREE POINTERS TO PAGES  */
    cfree(diphone_page);

    return self;
}



- saveToFile:(FILE *)fp1
{
    /*  WRITE PREFERENCES VARIABLES TO FILE  */
    fwrite((char *)&synthesizer_type,sizeof(synthesizer_type),1,fp1);
    fwrite((char *)&synthesizer_speed_type,sizeof(synthesizer_speed_type),1,fp1);
    fwrite((char *)&synthesizer_speed,sizeof(synthesizer_speed),1,fp1);

    fwrite((char *)&pitch_type,sizeof(pitch_type),1,fp1);
    fwrite((char *)&pitch.pitch,sizeof(pitch.pitch),1,fp1);
    fwrite((char *)&pitch.frequency,sizeof(pitch.frequency),1,fp1);

    fwrite((char *)&display_type,sizeof(display_type),1,fp1);
    fwrite((char *)&redisplay,sizeof(redisplay),1,fp1);
    fwrite((char *)&grid,sizeof(grid),1,fp1);
    fwrite((char *)&hscale_value,sizeof(hscale_value),1,fp1);
    fwrite((char *)&vscale_value,sizeof(vscale_value),1,fp1);

    fwrite((char *)&diphone_marker,sizeof(diphone_marker),1,fp1);
    fwrite((char *)&silent_phone,SYMBOL_LENGTH_MAX+1,1,fp1);
    fwrite((char *)&add_silent_phones,sizeof(add_silent_phones),1,fp1);
    fwrite((char *)&add_silent_diphones,sizeof(add_silent_diphones),1,fp1);

    return self;
}



- ReadFromFile:(FILE *)fp1
{
    char buffer[2];

    /*  READ PREFERENCES VARIABLES FROM FILE  */
    fread((char *)&synthesizer_type,sizeof(synthesizer_type),1,fp1);
    fread((char *)&synthesizer_speed_type,sizeof(synthesizer_speed_type),1,fp1);
    fread((char *)&synthesizer_speed,sizeof(synthesizer_speed),1,fp1);

    fread((char *)&pitch_type,sizeof(pitch_type),1,fp1);
    fread((char *)&pitch.pitch,sizeof(pitch.pitch),1,fp1);
    fread((char *)&pitch.frequency,sizeof(pitch.frequency),1,fp1);

    fread((char *)&display_type,sizeof(display_type),1,fp1);
    fread((char *)&redisplay,sizeof(redisplay),1,fp1);
    fread((char *)&grid,sizeof(grid),1,fp1);
    fread((char *)&hscale_value,sizeof(hscale_value),1,fp1);
    fread((char *)&vscale_value,sizeof(vscale_value),1,fp1);

    fread((char *)&diphone_marker,sizeof(diphone_marker),1,fp1);
    fread((char *)&silent_phone,SYMBOL_LENGTH_MAX+1,1,fp1);
    fread((char *)&add_silent_phones,sizeof(add_silent_phones),1,fp1);
    fread((char *)&add_silent_diphones,sizeof(add_silent_diphones),1,fp1);

    /*  SET SYNTHESIZER TYPE  */
    [typeSwitch selectCell:[typeSwitch cellAt:synthesizer_type:0]];

    /*  SET SPEED  */
    [speedSwitch selectCell:[speedSwitch cellAt:synthesizer_speed_type:0]];
    [speedForm setFloatValue:synthesizer_speed];
    [speedSlider setFloatValue:synthesizer_speed];

    /*  SET CENTER PITCH  */
    [pitchSwitch selectCell:[pitchSwitch cellAt:pitch_type:0]];
    if (pitch_type == PITCH_SWITCH_FREQ) {
	[pitchText setStringValue:PITCH_TEXT_FREQ];
	[pitchForm setFloatingPointFormat:0 left:4 right:2];
	[pitchForm setFloatValue:pitch.frequency];
	[pitchSlider setMinValue:PITCH_FREQ_MINIMUM];
	[pitchSlider setMaxValue:PITCH_FREQ_MAXIMUM];
	[pitchSlider setFloatValue:pitch.frequency];
    }
    else {
	[pitchText setStringValue:PITCH_TEXT_PITCH];
	[pitchForm setFloatingPointFormat:0 left:2 right:0];
	[pitchForm setFloatValue:pitch.pitch];
	[pitchSlider setMinValue:PITCH_PITCH_MINIMUM];
	[pitchSlider setMaxValue:PITCH_PITCH_MAXIMUM];
	[pitchSlider setFloatValue:pitch.pitch];
    }

    /*  SET DISPLAY SETTINGS  */
    [displaySwitch selectCell:[displaySwitch cellAt:display_type:0]];
    [redisplaySwitch setState:redisplay];
    [gridSwitch setState:grid];
    [hscaleForm setIntValue:hscale_value];
    [hscaleSlider setIntValue:hscale_value];
    [vscaleForm setIntValue:vscale_value];
    [vscaleSlider setIntValue:vscale_value];

    /*  SET PHONE OR DIPHONE ENTRY  */
    buffer[0] = diphone_marker;
    buffer[1] = '\0';
    [markerForm setStringValue:buffer];
    [silentPhoneForm setStringValue:silent_phone];
    [silentSwitchPhones setState:add_silent_phones];
    [silentSwitchDiphones setState:add_silent_diphones];

    return self;
}



void update_synth_ptr(void)
{
  synth_read_ptr += vm_page_size;
}

static void write_table_to_page()
{
    float  freq, table_inc, rc_scale, a, b, c, d;

    /*  CONVERT EACH TABLE TO APPROPRIATE DSP VALUES, WRITE TO VM  */
    /*  VOICING OSCILLATOR FREQUENCY  */
    freq = convert_to_frequency(center_pitch+parameter[1].value);
    table_inc = (float)(WAVE_TABLE_SIZE * freq)/SAMPLE_RATE;
    *(page_index++) = DSPIntToFix24((int)table_inc);
    *(page_index++) = DSPFloatToFix24(table_inc - (float)((int)table_inc));
    rc_scale = scale_rc / (2.0 * sin(freq * PI_DIV_SR));
    *(page_index++) = DSPIntToFix24((int)rc_scale);
    *(page_index++) = DSPFloatToFix24(rc_scale - (float)((int)rc_scale));
    
    /*  VOICING OSCILLATOR VOLUME  */
    *(page_index++) = DSPFloatToFix24(parameter[0].value/AMPLITUDE_SCALE);
    
    /*  MASTER VOLUME  */
    *(page_index++) = DSPFloatToFix24(parameter[17].value/AMPLITUDE_SCALE);
    
    /*  ASPIRATION VOLUME  */
    *(page_index++) = DSPFloatToFix24(parameter[2].value/AMPLITUDE_SCALE);
    
    /*  FRICATION VOLUME  */
    *(page_index++) = DSPFloatToFix24(parameter[3].value/AMPLITUDE_SCALE);
    
    /*  BYPASS REGISTER  */
    *(page_index++) = DSPIntToFix24((int)rint(parameter[19].value));
    
    /*  STEREO BALANCE  */
    *(page_index++) = DSPFloatToFix24((parameter[18].value * 0.5) + 0.5);
    
    /*  NASAL BYPASS  */
    *(page_index++) = DSPFloatToFix24(parameter[6].value);
    
    /*  R1 FREQUENCY AND BANDWIDTH  */
    *(page_index++) = DSPFloatToFix24(parameter[9].value/SAMPLE_RATE);
    *(page_index++) = DSPFloatToFix24(parameter[10].value/SAMPLE_RATE); 
    
    /*  R2 FREQUENCY AND BANDWIDTH  */
    *(page_index++) = DSPFloatToFix24(parameter[11].value/SAMPLE_RATE);
    *(page_index++) = DSPFloatToFix24(parameter[12].value/SAMPLE_RATE);
    
    /*  R3 FREQUENCY AND BANDWIDTH  */
    *(page_index++) = DSPFloatToFix24(parameter[13].value/SAMPLE_RATE);
    *(page_index++) = DSPFloatToFix24(parameter[14].value/SAMPLE_RATE);
    
    /*  R4 FREQUENCY AND BANDWIDTH  */
    *(page_index++) = DSPFloatToFix24(parameter[15].value/SAMPLE_RATE);
    *(page_index++) = DSPFloatToFix24(parameter[16].value/SAMPLE_RATE);
    
    /*  FRICATION RESONATOR FREQUENCY AND BANDWIDTH  */
    *(page_index++) = DSPFloatToFix24(parameter[4].value/SAMPLE_RATE);
    *(page_index++) = DSPFloatToFix24(parameter[5].value/SAMPLE_RATE);
    
    /*  NASAL NOTCH FILTER FREQUENCY AND BANDWIDTH  */
    set_notch_filter_coefficients(parameter[7].value,parameter[8].value,&a,&b,&c,&d);
    *(page_index++) = DSPFloatToFix24(a);
    *(page_index++) = DSPFloatToFix24(b);
    *(page_index++) = DSPFloatToFix24(c);
    *(page_index++) = DSPFloatToFix24(d);
    
    /*  SET BALANCE OF TABLE TO ZERO  */
    *(page_index++) = DSPIntToFix24(0);
    *(page_index++) = DSPIntToFix24(0);
    *(page_index++) = DSPIntToFix24(0);
    *(page_index++) = DSPIntToFix24(0);
    *(page_index++) = DSPIntToFix24(0);
    *(page_index++) = DSPIntToFix24(0);
    *(page_index++) = DSPIntToFix24(0);
}


phoneListPtr new_phoneList_node()
{
    return( (phoneListPtr) malloc(sizeof(phoneListType)) );
}

void free_phoneList_node(phoneListPtr node_ptr)
{
    free(node_ptr);
}

diphoneListPtr new_diphoneList_node()
{
    return( (diphoneListPtr) malloc(sizeof(diphoneList)) );
}

void free_diphoneList_node(diphoneListPtr node_ptr)
{
    free(node_ptr);
}

filterParamPtr new_displayParameter()
{
     return( (filterParamPtr) malloc(sizeof(filterParam)) );
}

void free_displayParameter(filterParamPtr displayParameter)
{
    free(displayParameter);
}


@end
