
/* Generated by Interface Builder */

#import "Rule.h"
#import "Template.h"
#import "Categories.h"
#import "PhoneDescription.h"
#import "TransitionView.h"
#import "SpecialEventView.h"
#import "parse.h"
#import "evaluate.h"
#import <appkit/appkit.h>


@implementation Rule

- appDidInit:sender
{
    char *temp;
    specifierStructPtr new_specifierStruct();
    int i, nint();

    /*  SET ALL INTERVAL BOXES TO NIL  */
    for (i = 0; i < INTERVALS_MAX; i++)
	intervalBox[i] = nil;

    /*  CREATE SYMBOL SEPARATORS W SPECIAL ARROW  */
    separator1[0] = separator2[0] = ']';
    		    separator2[1] = ' ';
    separator1[1] = separator2[2] = -69;
    		    separator2[3] = ' ';
    separator1[2] = separator2[4] = '[';
    separator1[3] = separator2[5] = '\0';

    /*  CREATE THE INITIAL SPECIFIER "PHONE->PHONE"  */
    specifierHead = new_specifierStruct();
    specifierHead->next = NULL;
    temp = (char *)calloc(strlen(SPECIFIER_DEF)+1,sizeof(char));
    strcpy(temp,SPECIFIER_DEF);
    specifierHead->category1 = temp;
    temp = (char *)calloc(strlen(SPECIFIER_DEF)+1,sizeof(char));
    strcpy(temp,SPECIFIER_DEF);
    specifierHead->category2 = temp;
    /*  GIVE THE SPECIFIER DEFAULT TRANSITION INTERVALS  */
    specifierHead->number_of_t_intervals = 0;
    specifierHead->t_interval_mode = SLOPE_RATIO_MODE;
    specifierHead->split_mode = SPLIT_MODE_ARBITRARY;
    [self defaultTransition:specifierHead];
    specifierCurrentRow = number_of_specifiers = 1;
    /*  INITIALIZE POINTERS TO SPECIALEVENT LIST  */
    specifierHead->specialEventHead = NULL;
    specifierHead->number_of_special_events = 0;
    currentSEPtr = oldSEPtr = NULL;
    /*  SET DURATION DEFAULTS  */
    specifierHead->duration.rule = DUR_RULE_NORMAL;
    specifierHead->duration.fixed_length = 
	nint((float)DUR_FIXED_DEF/(float)[template sampleValue]) * [template sampleValue];

    /*  SET NUMBER OF SPECIFIERS TO ONE  */
    [specifierTotal setIntValue:number_of_specifiers];

    /*  SET NUMBER OF SPECIALEVENTS TO ZERO  */
    [specialEventTotal setIntValue:specifierHead->number_of_special_events];

    /*  SET TARGET AND ACTION OF SPECIFIER BROWSER  */
    [specifierList setTarget:self];
    [specifierList setAction:(SEL)(@selector(specifierBrowserHit:))];
    [specifierList setDoubleAction:(SEL)(@selector(specifierBrowserDoubleHit:))];

    /*  SET TARGET AND ACTION OF SPECIALEVENT BROWSER  */
    [specialEventList setTarget:self];
    [specialEventList setAction:(SEL)(@selector(specialEventBrowserHit:))];
    [specialEventList setDoubleAction:(SEL)(@selector(specialEventBrowserDoubleHit:))];
    specialEventCurrentRow = 0;

    /*  SET TARGET AND ACTION OF addSpecialEvent BROWSER  */
    [addSpecialEventList setTarget:self];
    [addSpecialEventList setAction:(SEL)(@selector(addSpecialEventBrowserHit:))];
    [addSpecialEventList setDoubleAction:(SEL)(@selector(addSpecialEventBrowserDoubleHit:))];
    addSpecialEventCurrentRow = 0;
    [seAddButton setEnabled:0];

    /*  SET FONT OF PHONE AND SPECIALEVENT BROWSERS  */
    fontObj = [Font newFont:FONTNAME size:FONTSIZE];
    [[specifierList matrixInColumn:0] setFont:fontObj];
    [[specialEventList matrixInColumn:0] setFont:fontObj];
    [[addSpecialEventList matrixInColumn:0] setFont:fontObj];

    /*  RELOAD LIST INTO BROWSER  */
    [specifierList loadColumnZero];

    /*  SCROLL TO LATEST ITEM, SO IT CAN BE SEEN  */
    [[specifierList matrixInColumn:0] scrollCellToVisible:0 :0];

    /*  SELECT THE LATEST ITEM  */
    currentSpecifierPtr = NULL;
    [[specifierList matrixInColumn:0] selectCellAt:0 :0];
    [self specifierBrowserHit:specifierList];

    return self;
}



- setTitleBar:(char *)currentPath
{
    char buffer[MAXPATHLEN+36];

    /*  ADD FILENAME TO TITLE OF EACH WINDOW  */
    strcpy(buffer,"Rule Specification:   ");
    strcat(buffer,currentPath);
    [ruleWindow setTitle:(const char *)buffer];

    strcpy(buffer,"Transition Profile Inspector:   ");
    strcat(buffer,currentPath);
    [tProfileWindow setTitle:(const char *)buffer];

    strcpy(buffer,"Special Event Profile Inspector:   ");
    strcat(buffer,currentPath);
    [seProfileWindow setTitle:(const char *)buffer];

    return self;
}



- specifierBrowserHit:sender
{
    int i;
    char string[1024];

    /*  KEEP OLD SPECIFIER AROUND  */
    oldSpecifierPtr = currentSpecifierPtr;

    /*  SET VARIABLE TO INDICATE SELECTED ROW  */
    specifierCurrentRow = [[sender matrixInColumn:0] selectedRow] + 1;

    /*  SET CURRENT SPECIFIER  */
    currentSpecifierPtr = specifierHead;
    for (i = 1; i < specifierCurrentRow; i++)
	currentSpecifierPtr = currentSpecifierPtr->next;

    /*  IF THIS HIT HAS ALREADY BEEN HIT JUST PREVIOUSLY,
	RETURN TO SAVE TIME (SINCE DISPLAY ALREADY UPDATED)  */
    if (currentSpecifierPtr == oldSpecifierPtr)
	return self;

    /*  UPDATE CURRENT SPECIFIER DISPLAY  */
    strcpy(string,"[");
    strcat(string,currentSpecifierPtr->category1);
    strcat(string,separator2);
    strcat(string,currentSpecifierPtr->category2);
    strcat(string,"]");
    [currentSpecifier setStringValue:string];

    /*  SET THE MODE BUTTON CORRECTLY  */
    if (currentSpecifierPtr->t_interval_mode == FIXED_RISE_MODE)
    	[modeSwitch setTitle:"Fixed Rise"];
    else if (currentSpecifierPtr->t_interval_mode == SLOPE_RATIO_MODE)
       	[modeSwitch setTitle:"Slope Ratio"];

    /*  SET THE SPLIT MODE AND ASSOCIATED BUTTONS CORRECTLY  */
    if (currentSpecifierPtr->split_mode == SPLIT_MODE_ARBITRARY) {
	/*  SET SPLIT MODE BUTTON  */
	[splitModeButton setTitle:"Arbitrary Split"];
	/*  ENABLE DURATION RULE BUTTONS  */
	[durSwitch setEnabled:1];
	/*  ENABLE OTHER BUTTONS  */
	[splitIntervalButton setEnabled:1];
	[deleteIntervalButton setEnabled:1];
	[defaultButton setEnabled:1];
    }
    else {
	/*  SET SPLIT MODE BUTTON  */
	[splitModeButton setTitle:"Formula Split"];
	/*  DISABLE CERTAIN DURATION RULE BUTTONS  */
	[[durSwitch cellAt:DUR_RULE_P1:0] setEnabled:0];
	[[durSwitch cellAt:DUR_RULE_P2:0] setEnabled:0];
	[[durSwitch cellAt:DUR_RULE_AVG:0] setEnabled:0];
	[[durSwitch cellAt:DUR_RULE_FIXED:0] setEnabled:0];
	/*  DISABLE OTHER BUTTONS  */
	[splitIntervalButton setEnabled:0];
	[deleteIntervalButton setEnabled:0];
	[defaultButton setEnabled:0];
    }

    /*  MAKE SURE THE CURRENT TRANSITION IS DISPLAYED  */
    [self displayTransition];
    [self displayIntervalBoxes];

    /*  UPDATE NUMBER OF SPECIAL EVENTS, AND SPECIAL EVENT LIST  */
    [specialEventTotal setIntValue:currentSpecifierPtr->number_of_special_events];
    [specialEventList loadColumnZero];
    specialEventCurrentRow = 0;

    /*  BLANK OUT SPECIAL EVENT DISPLAY  */
    [self displaySpecialEvent:NO_DISPLAY:0];
    currentSEPtr = oldSEPtr = NULL;

    /*  DISABLE SPECIAL EVENT PROFILE BUTTONS  */
    [sepDeleteButton setEnabled:0];
    [sepInspectButton setEnabled:0];

    /*  UPDATE DURATION RULE INSPECTOR  */
    [durSwitch selectCellAt:currentSpecifierPtr->duration.rule:0];
    [self durSwitchHit:durSwitch];

    return self;
}



- specifierBrowserDoubleHit:sender
{
    /*  SAME AS USING THE MODIFY BUTTON  */
    [self specifierModify:self];
    return self;
}



- specialEventBrowserHit:sender
{
    int i;

    /*  SET VARIABLE TO INDICATE SELECTED ROW  */
    specialEventCurrentRow = [[sender matrixInColumn:0] selectedRow] + 1;

    /*  SET CURRENT SPECIAL EVENT POINTER  */
    currentSEPtr = currentSpecifierPtr->specialEventHead;
    for (i = 1; i < specialEventCurrentRow; i++)
	currentSEPtr = currentSEPtr->next;

    /*  IF THIS HIT HAS ALREADY BEEN HIT JUST PREVIOUSLY,
	RETURN TO SAVE TIME (SINCE DISPLAY ALREADY UPDATED)  */
    if (currentSEPtr == oldSEPtr)
	return self;

    /*  KEEP OLD SPECIAL EVENT POINTER AROUND  */
    oldSEPtr = currentSEPtr;

    /*  ENABLE SPECIAL EVENT PROFILE BUTTONS  */
    [sepDeleteButton setEnabled:1];
    [sepInspectButton setEnabled:1];

    /*  UPDATE THE SPECIAL EVENT INSPECTOR  */
    [self displaySpecialEvent:ZOOM_OUT:0];

    return self;
}



- specialEventBrowserDoubleHit:sender
{
    /*  SAME AS USING THE INSPECT BUTTON  */
    [self specialEventInspect:self];
    return self;
}



- addSpecialEventBrowserHit:sender
{
    /*  SET VARIABLE TO INDICATE SELECTED ROW  */
    addSpecialEventCurrentRow = [[sender matrixInColumn:0] selectedRow] + 1;

    /*  PUT SELECTED PARAMETER INTO DISPLAY  */
    [addSpecialEventForm setStringValue:[template parameterSymbol:addSpecialEventCurrentRow]];

    /*  ENABLE ADD BUTTON  */
    [seAddButton setEnabled:1];

    return self;
}



- addSpecialEventBrowserDoubleHit:sender
{
    /*  SAME AS USING THE ADD BUTTON  */
    [self specialEventAddOK:self];
    return self;
}



- (int)browser:sender fillMatrix:matrix inColumn:(int)column
{
    /*  DELEGATE METHOD FOR NXBROWSER  */
    /*  MERELY UPDATE THE BROWSER WITH THE NUMBER OF ITEMS  */
    if (sender == specifierList) {
	return(number_of_specifiers);
    }
    else if (sender == specialEventList) {
      	return(currentSpecifierPtr->number_of_special_events);
    }
    else if (sender == addSpecialEventList) {
	return([template numberOfParameters]);
    }
    else
    	return(0);
}

- browser:sender loadCell:cell atRow:(int)row inColumn:(int)column
{
    /*  NXBROWSER DELEGATE METHOD WHICH UPDATES PARTICULAR CELLS
        FROM THE DATA STORED IN LINKED LISTS  */
    int i, len, length1, length2;

    if (sender == specifierList) {
        specifierStructPtr current_ptr;
	char string[ROW_NUMBER_MAX+SPECIFIER_LENGTH_MAX+1];

	/*  SEARCH THROUGH LIST TILL ITEM FOUND  */
	current_ptr = specifierHead;
	for (i = 0; i < row; i++)
	  current_ptr = current_ptr->next;
	/*  PUT ROW NUMBER IN CELL  */
	sprintf(string,"%-d.",row+1);
        len = strlen(string);
        for (i = 0; i < (ROW_NUMBER_MAX-len); i++)
	    strcat(string," ");
	/*  PUT CAT1 AND CAT2 INTO SPECIFIER FORMAT  */
	length1 = strlen(current_ptr->category1);
	length2 = strlen(current_ptr->category2);
	if ((length1+length2) <= (SPECIFIER_LENGTH_MAX-5)) {
	    strcat(string,"[");
	    strcat(string,current_ptr->category1);
	    strcat(string,separator1);
	    strcat(string,current_ptr->category2);
	    strcat(string,"]");
	}
	else {
	    strcat(string,"[");
	    if (length1 > (SPECIFIER_LENGTH_MAX-5)/2) {
		strncat(string, current_ptr->category1,((SPECIFIER_LENGTH_MAX-5)/2)-3);
		strcat(string,"...");
	    }
	    else {
		strcat(string,current_ptr->category1);
	    }
	    strcat(string,separator1);
	    if (length2 > (SPECIFIER_LENGTH_MAX-5)/2) {
		strncat(string, current_ptr->category2,((SPECIFIER_LENGTH_MAX-5)/2)-3);
		strcat(string,"...");
	    }
	    else {
		strcat(string,current_ptr->category2);
	    }
	    strcat(string,"]");
        }
        [cell setStringValue:string];
    }
    else if (sender == specialEventList) {
        specialEventStructPtr current_ptr;
	char string[ROW_NUMBER_MAX+SYMBOL_LENGTH_MAX+1];

	/*  SEARCH THROUGH LIST TILL ITEM FOUND  */
	current_ptr = currentSpecifierPtr->specialEventHead;
	for (i = 0; i < row; i++)
	  current_ptr = current_ptr->next;

	/*  PUT ROW NUMBER, SYMBOL AND VALUES IN CELL  */
	sprintf(string,"%-d.",row+1);
        len = strlen(string);
        for (i = 0; i < (ROW_NUMBER_MAX-len); i++)
	    strcat(string," ");
	strcat(string,current_ptr->symbol);

        [cell setStringValue:string];
    }
    else if (sender == addSpecialEventList) {
	char string[ROW_NUMBER_MAX+SYMBOL_LENGTH_MAX+1];
	int i;
	specialEventStructPtr currentPtr;

	/*  PUT ROW NUMBER AND SYMBOL IN CELL  */
	sprintf(string,"%-d.",row+1);
        len = strlen(string);
        for (i = 0; i < (ROW_NUMBER_MAX-len); i++)
	    strcat(string," ");
	strcat(string,[template parameterSymbol:row+1]);
        [cell setStringValue:string];

	/*  DISABLE ITEM IF ALREADY SELECTED AS A SPECIAL EVENT  */
	currentPtr = currentSpecifierPtr->specialEventHead;
	for (i = 0; i < currentSpecifierPtr->number_of_special_events; i++) {
	    if (!strcmp([template parameterSymbol:row+1],currentPtr->symbol)) {
		[cell setEnabled:0];
		break;
	    }
	    currentPtr = currentPtr->next;
	}
    }
    /*  INDICATE THAT THE CELL IS A LEAF NODE  */
    [cell setLeaf:YES];
    return self;
}



- specifierAdd:sender
{
    /*  PUT IN DEFAULT VALUES INTO CATEGORY FIELDS  */
    [addTransitionForm setStringValue:CAT1_DEF at:CAT1];
    [addTransitionForm setStringValue:CAT2_DEF at:CAT2];

    /*  PUT IN DEFAULT FOR ORDER  */
    [addTransitionOrder setIntValue:specifierCurrentRow at:0];

    /*  PUT CURSOR IN FIRST FIELD  */
    [addTransitionForm selectTextAt:CAT1];

    /*  PUT PANEL IN PROPER RELATION TO TEMPLATE WINDOW  */
    [ruleWindow getFrame:(NXRect *)&r];
    [addTransitionPanel moveTo:(NXCoord)r.origin.x+CAT_X_OFFSET
			 :(NXCoord)r.origin.y+CAT_Y_OFFSET];

    /*  MAKE PANEL VISIBLE  */
    [addTransitionPanel makeKeyAndOrderFront:self];

    /*  MAKE SURE PANEL IS MODAL  */
    [NXApp runModalFor:addTransitionPanel];

    return self;
}



- specifierModify:sender
{
    /*  MAKE SURE A SPECIFIER HAS BEEN SELECTED  */
    if (currentSpecifierPtr == NULL)
	return self;

    /*  PUT IN DEFAULT VALUES INTO CATEGORY FIELDS  */
    [modTransitionForm setStringValue:currentSpecifierPtr->category1 at:CAT1];
    [modTransitionForm setStringValue:currentSpecifierPtr->category2 at:CAT2];

    /*  PUT IN DEFAULT FOR ORDER  */
    [modTransitionOrder setIntValue:specifierCurrentRow at:0];

    /*  PUT CURSOR IN FIRST FIELD, UNLESS "PHONE->PHONE" CHOSEN  */
    if (!strcmp(currentSpecifierPtr->category1,SPECIFIER_DEF) &&
		!strcmp(currentSpecifierPtr->category2,SPECIFIER_DEF)) {
	[modTransitionOrder selectTextAt:0];
    }
    else {
	[modTransitionForm selectTextAt:CAT1];
    }

    /*  PUT PANEL IN PROPER RELATION TO TEMPLATE WINDOW  */
    [ruleWindow getFrame:(NXRect *)&r];
    [modTransitionPanel moveTo:(NXCoord)r.origin.x+CAT_X_OFFSET
			 :(NXCoord)r.origin.y+CAT_Y_OFFSET];

    /*  MAKE PANEL VISIBLE  */
    [modTransitionPanel makeKeyAndOrderFront:self];

    /*  MAKE SURE PANEL IS MODAL  */
    [NXApp runModalFor:modTransitionPanel];

    return self;
}



- transitionInspect:sender
{
    [tProfileWindow makeKeyAndOrderFront:self];
    return self;
}



- specialEventAdd:sender
{
    /*  UPDATE THE BROWSER IN THE addSpecialEventPanel BROWSER  */
    [addSpecialEventList loadColumnZero];

    /*  PUT PANEL IN PROPER RELATION TO TEMPLATE WINDOW  */
    [ruleWindow getFrame:(NXRect *)&r];
    [addSpecialEventPanel moveTo:(NXCoord)r.origin.x+SPECIAL_X_OFFSET
			 :(NXCoord)r.origin.y+SPECIAL_Y_OFFSET];

    /*  MAKE PANEL VISIBLE  */
    [addSpecialEventPanel makeKeyAndOrderFront:self];

    /*  MAKE SURE PANEL IS MODAL  */
    [NXApp runModalFor:addSpecialEventPanel];

    return self;
}



- specialEventDelete:sender
{
    specialEventStructPtr current_ptr = NULL, temp_ptr = NULL;
    int i;
    void free_specialEventStruct();

    /*  MAKE SURE A SPECIAL EVENT HAS BEEN SELECTED  */
    if (specialEventCurrentRow == 0) {
	NXBeep();
	return self;
    }

    /*  TAKE ITEM OUT OF LIST BY ADJUSTING POINTERS  */
    if (specialEventCurrentRow == 1) {
	temp_ptr = currentSpecifierPtr->specialEventHead;
	currentSpecifierPtr->specialEventHead = temp_ptr->next;
    }
    else {
        current_ptr = currentSpecifierPtr->specialEventHead;
        for (i = 1; i < specialEventCurrentRow; i++) {
	    if (i == specialEventCurrentRow-1) {
		temp_ptr = current_ptr->next;
		current_ptr->next = current_ptr->next->next;
		break;
	    }
	    current_ptr = current_ptr->next;
	}
    }

    /*  FREE SPECIAL EVENT STRUCT, AND ALL ASSOCIATED MEMORY  */
    free_specialEventStruct(temp_ptr,currentSpecifierPtr);

    /*  UPDATE NUMBER OF SPECIAL EVENTS IN THIS SPECIFIER  */
    currentSpecifierPtr->number_of_special_events -= 1;

    /*  SET THE ROW NUMBER TO ZERO  */
    specialEventCurrentRow = 0;
    currentSEPtr = oldSEPtr = NULL;

    /*  UPDATE SPECIAL EVENT LIST  */
    [specialEventList loadColumnZero];

    /*  UPDATE NUMBER OF SPECIAL EVENTS DISPLAY  */
    [specialEventTotal setIntValue:currentSpecifierPtr->number_of_special_events];

    /*  BLANK THE SPECIAL EVENT INSPECTOR  */
    [self displaySpecialEvent:NO_DISPLAY:0];

    /*  DISABLE SPECIAL EVENT PROFILE BUTTONS  */
    [sepDeleteButton setEnabled:0];
    [sepInspectButton setEnabled:0];

    return self;
}



- specialEventInspect:sender
{
    /*  MAKE SURE THAT A SPECIAL EVENT HAS BEEN SELECTED  */
    if (specialEventCurrentRow == 0) {
	NXBeep();
	return self;
    }

    /*  MAKE THE INSPECTOR VISIBLE  */
    [seProfileWindow makeKeyAndOrderFront:self];
    return self;
}


- specialEventAddCancel:sender
{
    /*  BLANK THE DISPLAY  */
    [addSpecialEventForm setStringValue:""];

    /*  DISABLE ADD BUTTON  */
    [seAddButton setEnabled:0];

    /*  CLOSE THE PANEL  */
    [addSpecialEventPanel close];
    [NXApp stopModal];
    return self;
}

- specialEventAddOK:sender
{
    specialEventStructPtr current_ptr, new_specialEventStruct();
    int i;

    /*  MAKE SURE THAT A SPECIAL EVENT HAS BEEN CHOSEN  */
    if (!strcmp([addSpecialEventForm stringValue],"")) {
	NXBeep();
	return self;
    }

    /*  CREATE A NEW SPECIAL EVENT STRUCTURE, AND ADD IT TO END OF LIST  */
    if (currentSpecifierPtr->number_of_special_events == 0) {
	currentSpecifierPtr->specialEventHead = new_specialEventStruct();
	currentSpecifierPtr->specialEventHead->next = NULL;
	strcpy(currentSpecifierPtr->specialEventHead->symbol,[addSpecialEventForm stringValue]);
	currentSEPtr = currentSpecifierPtr->specialEventHead;
    }
    else {
	current_ptr = currentSpecifierPtr->specialEventHead;
	for (i = 1; i < currentSpecifierPtr->number_of_special_events; i++)
	    current_ptr = current_ptr->next;
	current_ptr->next = new_specialEventStruct();
	current_ptr->next->next = NULL;
	strcpy(current_ptr->next->symbol,[addSpecialEventForm stringValue]);
	currentSEPtr = current_ptr->next;
    }

    /*  CREATE DEFAULT SPECIAL EVENT PROFILE  */
    [self defaultSpecialEventProfile:currentSEPtr];

    /*  UPDATE NUMBER OF SPECIAL EVENTS IN THIS SPECIFIER  */
    currentSpecifierPtr->number_of_special_events += 1;

    /*  UPDATE SPECIAL EVENT LIST  */
    [specialEventList loadColumnZero];

    /*  UPDATE NUMBER OF SPECIAL EVENTS DISPLAY  */
    [specialEventTotal setIntValue:currentSpecifierPtr->number_of_special_events];

    /*  DISABLE ADD BUTTON  */
    [seAddButton setEnabled:0];

    /*  UPDATE addSpecialEvent BROWSER  */
    [addSpecialEventList loadColumnZero];

    /*  BLANK THE DISPLAY  */
    [addSpecialEventForm setStringValue:""];

    /*  BLANK THE SPECIAL EVENT INSPECTOR  */
    [self displaySpecialEvent:NO_DISPLAY:0];
    oldSEPtr = NULL;

    return self;
}



- addTransitionCancel:sender
{
    /*  CLOSE THE PANEL  */
    [addTransitionPanel close];
    [NXApp stopModal];
    return self;
}



- addTransitionOK:sender
{
    int order, i, len, nint();
    specifierStructPtr temp_next, current_ptr, new_specifierStruct();
    char *temp1, *temp2, *parse_message;

    /*  GET DESIRED ORDER OF SPECIFIER  */
    order = [addTransitionOrder intValueAt:0];

    /*  MAKE SURE ORDER IS IN RANGE  */
    if (order > (number_of_specifiers + 1) )
	order = number_of_specifiers + 1;
    else if (order <= 0)
	order = 1;

    /*  MAKE SURE THIS SPECIFIER IS NOT ALREADY ENTERED  */
    current_ptr = specifierHead;
    for (i = 0; i < number_of_specifiers; i++) {
	if (!strcmp(current_ptr->category1,[addTransitionForm stringValueAt:CAT1]) &&
		!strcmp(current_ptr->category2,[addTransitionForm stringValueAt:CAT2])) {
	    NXBeep();
	    NXRunAlertPanel("Illegal",
		"This transition specifier has already\nbeen entered at position %-d.\n",
	        "OK", NULL, NULL, i+1);
	    /*  PUT CURSOR AT FIELD  */
	    [addTransitionForm selectTextAt:0];
	    return self;
	}
	current_ptr = current_ptr->next;
    }

    /*  GET CATEGORY 1, MAKE SURE IT IS A LEGAL STATEMENT  */
    len = strlen([addTransitionForm stringValueAt:CAT1]);
    temp1 = (char *)calloc(len+1,sizeof(char));
    strcpy(temp1,[addTransitionForm stringValueAt:CAT1]);
    /*  PARSE THE CATEGORY AND MAKE SURE IT IS LEGAL  */
    if ((parse_message = parse(temp1,self)) != NULL) {
	NXBeep();
        NXRunAlertPanel("Syntax Error",parse_message,"OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[addTransitionForm selectTextAt:CAT1];
	/*  FREE TEMPORARY MEMORY  */
	cfree(temp1);
	return self;
    }

    /*  GET CATEGORY 2, MAKE SURE IT IS A LEGAL STATEMENT  */
    len = strlen([addTransitionForm stringValueAt:CAT2]);
    temp2 = (char *)calloc(len+1,sizeof(char));
    strcpy(temp2,[addTransitionForm stringValueAt:CAT2]);
    /*  PARSE THE CATEGORY AND MAKE SURE IT IS LEGAL  */
    if ((parse_message = parse(temp2,self)) != NULL) {
	NXBeep();
        NXRunAlertPanel("Syntax Error",parse_message,"OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[addTransitionForm selectTextAt:CAT2];
	/*  FREE TEMPORARY MEMORY  */
	cfree(temp2);
	return self;
    }


    /*  ADD NEW SPECIFIER INTO LINKED LIST  */
    if (order == 1) {
	temp_next = specifierHead;
	specifierHead = new_specifierStruct();
        specifierHead->next = temp_next;
	specifierHead->category1 = temp1;
	specifierHead->category2 = temp2;
    	specifierHead->specialEventHead = NULL;
    	specifierHead->number_of_special_events = 0;

	/*  CREATE DEFAULT TRANSITION PROFILE  */
	specifierHead->number_of_t_intervals = 0;
	specifierHead->t_interval_mode = SLOPE_RATIO_MODE;
	specifierHead->split_mode = SPLIT_MODE_ARBITRARY;
	[self defaultTransition:(specifierStructPtr)specifierHead];

	/*  SET TO DEFAULT DURATION VALUES  */
	specifierHead->duration.rule = DUR_RULE_NORMAL;
	specifierHead->duration.fixed_length = 
	    nint((float)DUR_FIXED_DEF/(float)[template sampleValue]) * [template sampleValue];
    }
    else {
	current_ptr = specifierHead;
	for (i = 1; i < order; i++) {
	    if (i == (order-1)) {
		temp_next = current_ptr->next;
		current_ptr->next = new_specifierStruct();
		current_ptr->next->next = temp_next;
		current_ptr->next->category1 = temp1;
		current_ptr->next->category2 = temp2;
	    	current_ptr->next->specialEventHead = NULL;
    		current_ptr->next->number_of_special_events = 0;
		/*  CREATE DEFAULT TRANSITION PROFILE  */
		current_ptr->next->number_of_t_intervals = 0;
		current_ptr->next->t_interval_mode = SLOPE_RATIO_MODE;
		current_ptr->next->split_mode = SPLIT_MODE_ARBITRARY;
		[self defaultTransition:(specifierStructPtr)(current_ptr->next)];
		/*  SET TO DEFAULT DURATION VALUES  */
		current_ptr->next->duration.rule = DUR_RULE_NORMAL;
		current_ptr->next->duration.fixed_length = 
		    nint((float)DUR_FIXED_DEF/(float)[template sampleValue]) 
			* [template sampleValue];
		break;
	    }
	    current_ptr = current_ptr->next;
 	}
    }

    /*  UPDATE TOTAL NUMBER OF SPECIFIERS  */
    [specifierTotal setIntValue:++number_of_specifiers];
    specifierCurrentRow = 0;

    /*  RELOAD LIST INTO BROWSER  */
    [specifierList loadColumnZero];

    /*  SCROLL TO LATEST ITEM, SO IT CAN BE SEEN  */
    [[specifierList matrixInColumn:0] scrollCellToVisible:order-1 :0];

    /*  SELECT THE LATEST ITEM  */
    [[specifierList matrixInColumn:0] selectCellAt:order-1 :0];
    [self specifierBrowserHit:specifierList];

    /*  CLOSE THE PANEL  */
    [addTransitionPanel close];
    [NXApp stopModal];
    return self;
}



- modTransitionCancel:sender
{
    /*  CLOSE THE PANEL  */
    [modTransitionPanel close];
    [NXApp stopModal];
    return self;
}



- modTransitionDelete:sender
{
    int i, j;
    specifierStructPtr next_temp, current_ptr;
    t_intervalPtr current_t_intervalPtr, temp_t_intervalPtr;
    specialEventStructPtr current_special_event_ptr, temp_special_event_ptr;
    void free_specialEventStruct();

    /*  MAKE SURE THE "PHONE->PHONE" SPECIFIER IS NOT DELETED  */
    if (!strcmp(currentSpecifierPtr->category1,SPECIFIER_DEF) &&
	     !strcmp(currentSpecifierPtr->category2,SPECIFIER_DEF)) {
	NXBeep();
	NXRunAlertPanel("Illegal",
		"This transition specifier cannot be deleted.",
	        "OK", NULL, NULL);
	return self;
    }

    /*  GO TO STRUCT JUST BEFORE THE ONE TO DELETE,
        FREE STRUCT AND ADJUST LINKED LIST  */
    if (specifierCurrentRow == 1) {
        next_temp = specifierHead;
	specifierHead = specifierHead->next;
        /*  FREE ALL DEPENDENT MEMORY  */
        cfree(next_temp->category1);
	cfree(next_temp->category2);
	/*  FREE ALL TRANSITION INTERVALS  */
	current_t_intervalPtr = next_temp->t_intervalHead;
	for (j = 0; j < next_temp->number_of_t_intervals; j++) {
	    temp_t_intervalPtr = current_t_intervalPtr;
	    current_t_intervalPtr = current_t_intervalPtr->next;
	    free(temp_t_intervalPtr);
	}
	/*  FREE ALL SPECIAL EVENTS  */
	current_special_event_ptr = next_temp->specialEventHead;
	for (j = 0; j < next_temp->number_of_special_events; j++) {
	    temp_special_event_ptr = current_special_event_ptr;
	    current_special_event_ptr = current_special_event_ptr->next;
	    free_specialEventStruct(temp_special_event_ptr,next_temp);
	}
	/*  FREE SPECIFIER ITSELF  */
        free(next_temp);
    }
    else {
	current_ptr = specifierHead;
        for (i = 1; i < specifierCurrentRow; i++) {
	    if (i == specifierCurrentRow-1) {
		next_temp = current_ptr->next;
		current_ptr->next = current_ptr->next->next;
	        /*  FREE ALL DEPENDENT MEMORY  */
        	cfree(next_temp->category1);
		cfree(next_temp->category2);
		/*  FREE ALL TRANSITION INTERVALS  */
		current_t_intervalPtr = next_temp->t_intervalHead;
		for (j = 0; j < next_temp->number_of_t_intervals; j++) {
		    temp_t_intervalPtr = current_t_intervalPtr;
		    current_t_intervalPtr = current_t_intervalPtr->next;
		    free(temp_t_intervalPtr);
		}
		/*  FREE ALL SPECIAL EVENTS  */
		current_special_event_ptr = next_temp->specialEventHead;
		for (j = 0; j < next_temp->number_of_special_events; j++) {
		    temp_special_event_ptr = current_special_event_ptr;
		    current_special_event_ptr = current_special_event_ptr->next;
		    free_specialEventStruct(temp_special_event_ptr,next_temp);
		}
		/*  FREE SPECIFIER ITSELF  */
        	free(next_temp);
		break;
	    }
            current_ptr = current_ptr->next;
        }
    }


    /*  DECREMENT TOTAL NUMBER OF SPECIFIERS  */
    [specifierTotal setIntValue:--number_of_specifiers];
    i = specifierCurrentRow;
    if (i > number_of_specifiers)
	i--;
    specifierCurrentRow = 0;

    /*  SET CURRENT SPECIFIER TO NULL  */
    currentSpecifierPtr = NULL;

    /*  RELOAD LIST INTO BROWSER  */
    [specifierList loadColumnZero];

    /*  SCROLL TO ROW WHERE DELETION OCCURRED  */
    [[specifierList matrixInColumn:0] scrollCellToVisible:i-1 :0];

    /*  SELECT THE ITEM WHERE DELETION OCCURRED  */
    [[specifierList matrixInColumn:0] selectCellAt:i-1 :0];
    [self specifierBrowserHit:specifierList];

    /*  CLOSE THE PANEL  */
    [modTransitionPanel close];
    [NXApp stopModal];
    return self;
}



- modTransitionOK:sender
{
    int i, order, len;
    specifierStructPtr next_temp, current_ptr, item_ptr = NULL;
    char *temp1, *temp2, *parse_message;

    /*  MAKE SURE "PHONE->PHONE" NOT ALTERED OTHER THAN FOR ORDER  */
    if (!strcmp(currentSpecifierPtr->category1,SPECIFIER_DEF) &&
		!strcmp(currentSpecifierPtr->category2,SPECIFIER_DEF)) {
	if (strcmp([modTransitionForm stringValueAt:CAT1],SPECIFIER_DEF) ||
			strcmp([modTransitionForm stringValueAt:CAT2],SPECIFIER_DEF)) {
	    NXBeep();
	    NXRunAlertPanel("Illegal",
		"This transition specifier cannot be\naltered, except for order.\n",
	        "OK", NULL, NULL);
	    /*  PUT IN DEFAULT VALUES INTO CATEGORY FIELDS, SELECT ORDER  */
	    [modTransitionForm setStringValue:currentSpecifierPtr->category1 at:CAT1];
	    [modTransitionForm setStringValue:currentSpecifierPtr->category2 at:CAT2];
	    [modTransitionOrder selectTextAt:0];
	    return self;
	}
    }

    /*  MAKE SURE THIS SPECIFIER IS NOT ALREADY ENTERED  */
    current_ptr = specifierHead;
    for (i = 0; i < number_of_specifiers; i++) {
      if (current_ptr != currentSpecifierPtr) {
	if (!strcmp(current_ptr->category1,[modTransitionForm stringValueAt:CAT1]) &&
		!strcmp(current_ptr->category2,[modTransitionForm stringValueAt:CAT2])) {
	    NXBeep();
	    NXRunAlertPanel("Illegal",
		"This transition specifier has already\nbeen entered at position %-d.\n",
	        "OK", NULL, NULL, i+1);
	    /*  PUT CURSOR AT FIELD WITH ORIGINAL VALUES  */
	    /*  PUT IN DEFAULT VALUES INTO CATEGORY FIELDS  */
	    [modTransitionForm setStringValue:currentSpecifierPtr->category1 at:CAT1];
	    [modTransitionForm setStringValue:currentSpecifierPtr->category2 at:CAT2];
	    [modTransitionForm selectTextAt:0];
	    return self;
	}
      }
      current_ptr = current_ptr->next;
    }

    /*  GET CATEGORY 1, MAKE SURE IT IS A LEGAL STATEMENT  */
    len = strlen([modTransitionForm stringValueAt:CAT1]);
    temp1 = (char *)calloc(len+1,sizeof(char));
    strcpy(temp1,[modTransitionForm stringValueAt:CAT1]);
    /*  PARSE THE CATEGORY AND MAKE SURE IT IS LEGAL  */
    if ((parse_message = parse(temp1,self)) != NULL) {
	NXBeep();
        NXRunAlertPanel("Syntax Error",parse_message,"OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[modTransitionForm selectTextAt:CAT1];
	/*  FREE TEMPORARY MEMORY  */
	cfree(temp1);
	return self;
    }


    /*  GET CATEGORY 2, MAKE SURE IT IS A LEGAL STATEMENT  */
    len = strlen([modTransitionForm stringValueAt:CAT2]);
    temp2 = (char *)calloc(len+1,sizeof(char));
    strcpy(temp2,[modTransitionForm stringValueAt:CAT2]);
    /*  PARSE THE CATEGORY AND MAKE SURE IT IS LEGAL  */
    if ((parse_message = parse(temp2,self)) != NULL) {
	NXBeep();
        NXRunAlertPanel("Syntax Error",parse_message,"OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[modTransitionForm selectTextAt:CAT2];
	/*  FREE TEMPORARY MEMORY  */
	cfree(temp2);
	return self;
    }


    /*  TAKE OUT ITEM FROM LIST  */
    if (specifierCurrentRow == 1) {
        item_ptr = specifierHead;
	specifierHead = specifierHead->next;
    }
    else {
	current_ptr = specifierHead;
        for (i = 1; i < specifierCurrentRow; i++) {
	    if (i == specifierCurrentRow-1) {
		item_ptr = current_ptr->next;
		current_ptr->next = current_ptr->next->next;
		break;
	    }
            current_ptr = current_ptr->next;
        }
    }

    /*  GET DESIRED ORDER OF SPECIFIER  */
    order = [modTransitionOrder intValueAt:0];

    /*  MAKE SURE ORDER IS IN RANGE  */
    if (order > number_of_specifiers)
	order = number_of_specifiers;
    else if (order <= 0)
	order = 1;

    /*  ADD SPECIFIER BACK INTO LINKED LIST USING NEW VALUES  */
    if (order == 1) {
	next_temp = specifierHead;
	specifierHead = item_ptr;
        specifierHead->next = next_temp;
	/*  DELETE OLD CATEGORIES  */
	cfree(specifierHead->category1);
	cfree(specifierHead->category2);
	/*  USE NEW CATEGORIES  */
	specifierHead->category1 = temp1;
	specifierHead->category2 = temp2;
    }
    else {
	current_ptr = specifierHead;
	for (i = 1; i < order; i++) {
	    if (i == (order-1)) {
		next_temp = current_ptr->next;
		current_ptr->next = item_ptr;
		current_ptr->next->next = next_temp;
		/*  DELETE OLD CATEGORIES  */
		cfree(current_ptr->next->category1);
		cfree(current_ptr->next->category2);
		/*  USE NEW CATEGORIES  */
		current_ptr->next->category1 = temp1;
		current_ptr->next->category2 = temp2;
		break;
	    }
	    current_ptr = current_ptr->next;
 	}
    }

    /*  RELOAD LIST INTO BROWSER  */
    [specifierList loadColumnZero];

    /*  SCROLL TO CELL, SO IT CAN BE SEEN  */
    [[specifierList matrixInColumn:0] scrollCellToVisible:order-1 :0];

    /*  SELECT THE ITEM WHERE DELETION OCCURRED  */
    [[specifierList matrixInColumn:0] selectCellAt:order-1 :0];
    [self specifierBrowserHit:specifierList];

    /*  MAKE SURE THE CURRENT TRANSITION IS DISPLAYED  */
    [self displayTransition];
    [self displayIntervalBoxes];

    /*  CLOSE THE PANEL  */
    [modTransitionPanel close];
    [NXApp stopModal];
    return self;
}



- splitInterval:sender
{
    /*  PUT CURSOR IN FIRST FIELD  */
    [splitIntervalForm selectText:self];

    /*  PUT PANEL IN PROPER RELATION TO TEMPLATE WINDOW  */
    [tProfileWindow getFrame:(NXRect *)&r];
    [splitIntervalPanel moveTo:(NXCoord)r.origin.x+SPLIT_INTERVAL_X_OFFSET
			 :(NXCoord)r.origin.y+SPLIT_INTERVAL_Y_OFFSET];

    /*  MAKE PANEL VISIBLE  */
    [splitIntervalPanel makeKeyAndOrderFront:self];

    /*  MAKE SURE PANEL IS MODAL  */
    [NXApp runModalFor:splitIntervalPanel];
    return self;
}



- deleteInterval:sender
{
    /*  PUT CURSOR IN FIRST FIELD  */
    [deleteIntervalForm selectText:self];

    /*  PUT PANEL IN PROPER RELATION TO TEMPLATE WINDOW  */
    [tProfileWindow getFrame:(NXRect *)&r];
    [deleteIntervalPanel moveTo:(NXCoord)r.origin.x+DELETE_INTERVAL_X_OFFSET
			 :(NXCoord)r.origin.y+DELETE_INTERVAL_Y_OFFSET];

    /*  MAKE PANEL VISIBLE  */
    [deleteIntervalPanel makeKeyAndOrderFront:self];

    /*  MAKE SURE PANEL IS MODAL  */
    [NXApp runModalFor:deleteIntervalPanel];
    return self;
}



- splitIntervalCancel:sender
{
    /*  CLOSE THE PANEL  */
    [splitIntervalPanel close];
    [NXApp stopModal];
    return self;
}



- splitIntervalOK:sender
{
    int split_interval, split_interval_proportional;
    t_intervalPtr current_interval_ptr = NULL, split_interval_ptr = NULL;
    float split_interval_rise = 0.0, split_interval_slope = 0.0, excess = 0.0;
    union _split_interval_duration {
	int ival;
	float fval;
    } split_interval_duration;


    /*  ALLOW ONLY MAXIMUM NUMBER OF INTERVALS  */
    if (currentSpecifierPtr->number_of_t_intervals >= INTERVALS_MAX) {
	NXBeep();
	NXRunAlertPanel("Illegal",
	    "Only a maximum of %-d intervals allowed.",
	    "OK", NULL, NULL, INTERVALS_MAX);
	/*  PUT CURSOR AT FIELD  */
	[splitIntervalForm selectText:self];
	return self;
    }

    /*  GET INTERVAL TO SPLIT, MAKE SURE IT IS IN RANGE  */
    split_interval = [splitIntervalForm intValue];
    if ((split_interval < 1) ||
		(split_interval > currentSpecifierPtr->number_of_t_intervals)) {
	NXBeep();
	NXRunAlertPanel("Illegal",
	    "No such interval.","OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[splitIntervalForm selectText:self];
	return self;
    }

    /*  GET THE SPLIT INTERVAL POINTER  */
    split_interval_ptr = [self intervalPointer:currentSpecifierPtr:split_interval-1];

    /*  GET THE SPLIT INTERVAL'S PERCENTAGE RISE OR SLOPE, DEPENDING ON MODE.
	DIVIDE IN HALF FOR DISTRIBUTION BETWEEN THE TWO RESULTING INTERVALS,
	IF RISE;  USE SAME SLOPE FOR BOTH INTERVALS IF IN SLOPE RATIO MODE  */
    if (currentSpecifierPtr->t_interval_mode == FIXED_RISE_MODE)
	split_interval_rise = split_interval_ptr->rise / 2.0;
    else if (currentSpecifierPtr->t_interval_mode == SLOPE_RATIO_MODE)
	split_interval_slope = split_interval_ptr->slope_ratio;

    /*  DETERMINE WHETHER PROPORTIONAL OR NOT  */
    split_interval_proportional = split_interval_ptr->proportional;

    /*  DETERMINE SPLIT INTERVAL DURATION, DIVIDE IN HALF FOR FURTHER
	DISTRIBUTION, KEEPING IN MIND THE MINIMUM VALUES ALLOWED  */
    if (split_interval_proportional) {
	excess = 0.0;
	split_interval_duration.fval = split_interval_ptr->duration.fval / 2.0;
	if (split_interval_duration.fval < PROPORTION_MIN) {
	    excess = (PROPORTION_MIN - split_interval_duration.fval) * 2.0;
	    split_interval_duration.fval = PROPORTION_MIN;
	}
    }
    else if (!split_interval_proportional) {
	int sample_value, nint();
        sample_value = [template sampleValue];
	split_interval_duration.ival = nint((float)split_interval_ptr->duration.ival / 2.0);
	/*  MAKE SURE VALUE IS MULTIPLE OF SAMPLE VALUE  */
	split_interval_duration.ival = 
	    nint((float)(split_interval_ptr->duration.ival / 2.0) /
		  (float)sample_value) * sample_value;
	if (split_interval_duration.ival < sample_value) {
	    split_interval_duration.ival = sample_value;
	}
    }

    /*  DO PROPORTIONAL INTERVAL SPLIT  */
    if (split_interval_proportional) {
	t_intervalPtr new_interval_ptr, temp_interval_ptr, new_t_interval();
	/*  SET SPLIT INTERVAL TO NEW RISE OR SLOPE, AND DURATION  */
	if (currentSpecifierPtr->t_interval_mode == FIXED_RISE_MODE)
	    split_interval_ptr->rise = split_interval_rise;
	else if (currentSpecifierPtr->t_interval_mode == SLOPE_RATIO_MODE)
	    split_interval_ptr->slope_ratio = split_interval_slope;
	split_interval_ptr->duration.fval = split_interval_duration.fval;
	/*  APPLY EXCESS PROPORTIONAL VALUE FIRST TO RIGHT, THEN LEFT  */
	if (excess > 0.0) {
	    /*  TO RIGHT  */
	    current_interval_ptr = split_interval_ptr->next;
	    while ((excess > 0.0) && (current_interval_ptr != NULL)) {
	        if (current_interval_ptr->proportional) {
		    float length;
		    length = current_interval_ptr->duration.fval - excess;
		    length = (length < PROPORTION_MIN) ? PROPORTION_MIN : length;
		    excess -= (current_interval_ptr->duration.fval - length);
		    current_interval_ptr->duration.fval = length;
		}
		current_interval_ptr = current_interval_ptr->next;
	    }
	    /*  TO LEFT  */
	    current_interval_ptr = split_interval_ptr->previous;
	    while ((excess > 0.0) && (current_interval_ptr != NULL)) {
	        if (current_interval_ptr->proportional) {
		    float length;
		    length = current_interval_ptr->duration.fval - excess;
		    length = (length < PROPORTION_MIN) ? PROPORTION_MIN : length;
		    excess -= (current_interval_ptr->duration.fval - length);
		    current_interval_ptr->duration.fval = length;
		}
		current_interval_ptr = current_interval_ptr->previous;
	    }
	}
	/*  CREATE NEW INTERVAL  */
	new_interval_ptr = new_t_interval();
	/*  SET VALUES OF NEW INTERVAL  */
	if (currentSpecifierPtr->t_interval_mode == FIXED_RISE_MODE)
	    new_interval_ptr->rise = split_interval_rise;
	else if (currentSpecifierPtr->t_interval_mode == SLOPE_RATIO_MODE)
	    new_interval_ptr->slope_ratio = split_interval_slope;
	new_interval_ptr->duration.fval = split_interval_duration.fval;
	new_interval_ptr->proportional = split_interval_proportional;
	new_interval_ptr->regression = split_interval_ptr->regression;
	/*  INSERT INTO LIST;  SET FORWARD POINTERS  */
	temp_interval_ptr = split_interval_ptr->next;
	split_interval_ptr->next = new_interval_ptr;
	new_interval_ptr->next = temp_interval_ptr;
	/*  SET BACKWARDS POINTERS  */
	if (new_interval_ptr->next != NULL)
	    new_interval_ptr->next->previous = new_interval_ptr;
	new_interval_ptr->previous = split_interval_ptr;
	/*  UPDATE NUMBER OF INTERVALS FOR TRANSITION SPECIFIER  */
	currentSpecifierPtr->number_of_t_intervals++;
    }
    /*  DO FIXED INTERVAL SPLIT  */
    else if (!split_interval_proportional) {
	t_intervalPtr new_interval_ptr, temp_interval_ptr, new_t_interval();
	/*  SET SPLIT INTERVAL TO NEW RISE OR SLOPE, AND DURATION  */
	if (currentSpecifierPtr->t_interval_mode == FIXED_RISE_MODE)
	    split_interval_ptr->rise = split_interval_rise;
	else if (currentSpecifierPtr->t_interval_mode == SLOPE_RATIO_MODE)
	    split_interval_ptr->slope_ratio = split_interval_slope;
	split_interval_ptr->duration.ival = split_interval_duration.ival;
	/*  CREATE NEW INTERVAL  */
	new_interval_ptr = new_t_interval();
	/*  SET VALUES OF NEW INTERVAL  */
	if (currentSpecifierPtr->t_interval_mode == FIXED_RISE_MODE)
	    new_interval_ptr->rise = split_interval_rise;
	else if (currentSpecifierPtr->t_interval_mode == SLOPE_RATIO_MODE)
	    new_interval_ptr->slope_ratio = split_interval_slope;
	new_interval_ptr->duration.ival = split_interval_duration.ival;
	new_interval_ptr->proportional = split_interval_proportional;
	new_interval_ptr->regression = split_interval_ptr->regression;
	/*  INSERT INTO LIST;  SET FORWARD POINTERS  */
	temp_interval_ptr = split_interval_ptr->next;
	split_interval_ptr->next = new_interval_ptr;
	new_interval_ptr->next = temp_interval_ptr;
	/*  SET BACKWARDS POINTERS  */
	if (new_interval_ptr->next != NULL)
	    new_interval_ptr->next->previous = new_interval_ptr;
	new_interval_ptr->previous = split_interval_ptr;
	/*  UPDATE NUMBER OF INTERVALS FOR TRANSITION SPECIFIER  */
	currentSpecifierPtr->number_of_t_intervals++;
    }

    /*  MAKE SURE THE CURRENT TRANSITION IS DISPLAYED  */
    [self displayTransition];
    [self displayIntervalBoxes];

    /*  PROPAGATE THE SPLIT TO ALL SPECIAL EVENTS  */
    [self propagateSplit:split_interval];

    /*  CLOSE THE PANEL  */
    [splitIntervalPanel close];
    [NXApp stopModal];
    return self;
}



- deleteIntervalCancel:sender
{
    /*  CLOSE THE PANEL  */
    [deleteIntervalPanel close];
    [NXApp stopModal];
    return self;
}



- deleteIntervalOK:sender
{
    int i, delete_interval, proportional_intervals = 0;
    t_intervalPtr current_interval_ptr = NULL, delete_interval_ptr = NULL;

    /*  GET INTERVAL TO DELETE, MAKE SURE IT IS IN RANGE  */
    delete_interval = [deleteIntervalForm intValue];
    if ((delete_interval < 1) ||
		(delete_interval > currentSpecifierPtr->number_of_t_intervals)) {
	NXBeep();
	NXRunAlertPanel("Illegal",
	    "No such interval.","OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[deleteIntervalForm selectText:self];
	return self;
    }

    /*  WHEN DELETING, MAKE SURE THERE ARE 2 OR MORE INTERVALS  */
    if (currentSpecifierPtr->number_of_t_intervals < 2) {
	NXBeep();
	NXRunAlertPanel("Illegal",
	    "There must be at least one interval remaining.",
	    "OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[deleteIntervalForm selectText:self];
	return self;
    }

    /*  MAKE SURE THAT AT LEAST ONE PROPORTIONAL INTERVAL REMAINS  */
    current_interval_ptr = currentSpecifierPtr->t_intervalHead;
    proportional_intervals = 0;
    for (i = 0; i < currentSpecifierPtr->number_of_t_intervals; i++) {
	if ((current_interval_ptr->proportional)  && (i != delete_interval-1))
	    proportional_intervals++;
	current_interval_ptr = current_interval_ptr->next;
    }
    if (proportional_intervals < 1) {
	NXBeep();
	NXRunAlertPanel("Illegal",
	    "There must be at least one proportional\ninterval remaining after deletion.",
	    "OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[deleteIntervalForm selectText:self];
	return self;
    }

    /*  FIND POINTER FOR DELETE INTERVAL, AND WHETHER FIXED OR PROPORTIONAL  */
    current_interval_ptr = currentSpecifierPtr->t_intervalHead;
    for (i = 0; i < currentSpecifierPtr->number_of_t_intervals; i++) {
	if (i == delete_interval-1) {
	    delete_interval_ptr = current_interval_ptr;
	    break;
	}
	current_interval_ptr = current_interval_ptr->next;
    }

    /*  ACTUAL DELETION FOR FIXED INTERVAL  */
    if (!(delete_interval_ptr->proportional)) {
	/*  TAKE INTERVAL OUT OF LIST BY ADJUSTING ADJACENT POINTERS  */
	/*  ADJUST RISE TO LEFT OF DELETE INTERVAL, UNLESS IT IS THE 1ST INTERVAL  */
	if (delete_interval == 1) {
	    currentSpecifierPtr->t_intervalHead = delete_interval_ptr->next;
	    delete_interval_ptr->next->previous = NULL;
	    currentSpecifierPtr->t_intervalHead->rise += delete_interval_ptr->rise;
	}
	else {
	    delete_interval_ptr->previous->next = delete_interval_ptr->next;
	    if (delete_interval_ptr->next != NULL) {
		delete_interval_ptr->next->previous = delete_interval_ptr->previous;
	    }
	    delete_interval_ptr->previous->rise += delete_interval_ptr->rise;

	}
	currentSpecifierPtr->number_of_t_intervals--;

	/*  FREE MEMORY OF DELETE INTERVAL  */
	free(delete_interval_ptr);
    }
    /*  ACTUAL DELETION FOR PROPORTIONAL INTERVAL  */
    else if (delete_interval_ptr->proportional) {
	t_intervalPtr forward_interval_ptr = NULL, backward_interval_ptr = NULL;
	int index;
	int forward_index = 1000000;
	int backward_index = 1000000;

	/*  FIND NEAREST FORWARD PROPORTIONAL INTERVAL  */
	index = 0;
	current_interval_ptr = delete_interval_ptr;
	while (current_interval_ptr->next != NULL) {
	    current_interval_ptr = current_interval_ptr->next;
	    index++;
	    if (current_interval_ptr->proportional) {
		forward_index = index;
		forward_interval_ptr = current_interval_ptr;
		break;
	    }
	}

	/*  FIND NEAREST BACKWARD PROPORTIONAL INTERVAL  */
	index = 0;
	current_interval_ptr = delete_interval_ptr;
	while (current_interval_ptr->previous != NULL) {
	    current_interval_ptr = current_interval_ptr->previous;
	    index++;
	    if (current_interval_ptr->proportional) {
		backward_index = index;
		backward_interval_ptr = current_interval_ptr;
		break;
	    }
	}

        /*  CHOOSE THE NEAREST PROPORITONAL INTERVAL, IF TIED, CHOOSE LEFT ONE  */
	if (backward_index <= forward_index) {
	    current_interval_ptr = backward_interval_ptr;
	}
	else {
	    current_interval_ptr = forward_interval_ptr;
	}

        /*  ADD THE PROPORTIONAL LENGTH OF DELETE INTERVAL TO THE CHOSEN INTERVAL  */
	current_interval_ptr->duration.fval += delete_interval_ptr->duration.fval;

	/*  TAKE INTERVAL OUT OF LIST BY ADJUSTING ADJACENT POINTERS  */
	/*  ADJUST RISE TO LEFT OF DELETE INTERVAL, UNLESS IT IS THE 1ST INTERVAL  */
	if (delete_interval == 1) {
	    currentSpecifierPtr->t_intervalHead = delete_interval_ptr->next;
	    delete_interval_ptr->next->previous = NULL;
	    currentSpecifierPtr->t_intervalHead->rise += delete_interval_ptr->rise;
	}
	else {
	    delete_interval_ptr->previous->next = delete_interval_ptr->next;
	    if (delete_interval_ptr->next != NULL) {
		delete_interval_ptr->next->previous = delete_interval_ptr->previous;
	    }
	    delete_interval_ptr->previous->rise += delete_interval_ptr->rise;

	}
	currentSpecifierPtr->number_of_t_intervals--;

	/*  FREE MEMORY OF DELETE INTERVAL  */
	free(delete_interval_ptr);
    }

    /*  MAKE SURE THE CURRENT TRANSITION IS DISPLAYED  */
    [self displayTransition];
    [self displayIntervalBoxes];

    /*  PROPAGATE THE DELETION TO ALL SPECIAL EVENTS  */
    [self propagateDeletion:delete_interval];

    /*  CLOSE THE PANEL  */
    [deleteIntervalPanel close];
    [NXApp stopModal];
    return self;
}



- tProfileDefault:sender
{
    /*  RESET TRANSITION PROFILE TO DEFAULT STATE  */
    [self defaultTransition:currentSpecifierPtr];
    [self displayTransition];
    [self displayIntervalBoxes];

    /*  RESET ANY SPECIAL EVENTS AS WELL  */
    [self propagateDefaultToSEProfiles];

    return self;
}



- tProfileCopy:sender
{
    return self;
}



- defaultTransition:(specifierStructPtr)specifierPtr
{
    int i;
    t_intervalPtr current_interval_ptr, temp_interval_ptr, new_t_interval();

    /*  FIRST FREE ANY INTERVALS THAT EXIST  */
    current_interval_ptr = specifierPtr->t_intervalHead;
    for (i = 0; i < specifierPtr->number_of_t_intervals; i++) {
	temp_interval_ptr = current_interval_ptr->next;
	free(current_interval_ptr);
	current_interval_ptr = temp_interval_ptr;
    }

    /*  IF FIXED RISE MODE, ADD THREE INTERVALS  */
    if (specifierPtr->t_interval_mode == FIXED_RISE_MODE) {
    	/*  ADD THREE INTERVALS  */
	current_interval_ptr = specifierPtr->t_intervalHead = new_t_interval();
    	current_interval_ptr->proportional = YES;
    	current_interval_ptr->regression = YES;
    	current_interval_ptr->duration.fval = 0.333333;
    	current_interval_ptr->rise = 0.125;
    	current_interval_ptr->next = new_t_interval();
    	current_interval_ptr->previous = NULL;

    	current_interval_ptr->next->previous = current_interval_ptr;
    	current_interval_ptr = current_interval_ptr->next;
    	current_interval_ptr->proportional = YES;
    	current_interval_ptr->regression = NO;
    	current_interval_ptr->duration.fval = 0.333334;
    	current_interval_ptr->rise = 0.75;
    	current_interval_ptr->next = new_t_interval();

    	current_interval_ptr->next->previous = current_interval_ptr;
    	current_interval_ptr = current_interval_ptr->next;
    	current_interval_ptr->proportional = YES;
    	current_interval_ptr->regression = YES;
    	current_interval_ptr->duration.fval = 0.333333;
    	current_interval_ptr->rise = 0.125;
    	current_interval_ptr->next = NULL;

	/*  SPECIFIER HAS THREE INTERVALS  */
    	specifierPtr->number_of_t_intervals = 3;
    }
    /*  IF SLOPE RATIO MODE, ADD THREE INTERVALS  */
    else if (specifierPtr->t_interval_mode == SLOPE_RATIO_MODE) {
    	/*  ADD THREE INTERVALS  */
	current_interval_ptr = specifierPtr->t_intervalHead = new_t_interval();
    	current_interval_ptr->proportional = YES;
    	current_interval_ptr->regression = YES;
    	current_interval_ptr->duration.fval = 0.333333;
	current_interval_ptr->slope_ratio = 1.0;
    	current_interval_ptr->next = new_t_interval();
    	current_interval_ptr->previous = NULL;

    	current_interval_ptr->next->previous = current_interval_ptr;
    	current_interval_ptr = current_interval_ptr->next;
    	current_interval_ptr->proportional = YES;
    	current_interval_ptr->regression = NO;
    	current_interval_ptr->duration.fval = 0.333334;
	current_interval_ptr->slope_ratio = 6.0;
    	current_interval_ptr->next = new_t_interval();

    	current_interval_ptr->next->previous = current_interval_ptr;
    	current_interval_ptr = current_interval_ptr->next;
    	current_interval_ptr->proportional = YES;
    	current_interval_ptr->regression = YES;
    	current_interval_ptr->duration.fval = 0.333333;
	current_interval_ptr->slope_ratio = 1.0;
    	current_interval_ptr->next = NULL;

	/*  SPECIFIER HAS THREE INTERVALS  */
    	specifierPtr->number_of_t_intervals = 3;
    }

    return self;
}



- displayIntervalBoxes
{
    int i;
    t_intervalPtr current_t_interval;

    /*  FREE ALL NON-NIL BOXES  */
    for (i = 0; i < INTERVALS_MAX; i++) {
	if (intervalBox[i] != nil) {
	    [intervalBox[i] free];     /*  frees all subviews  */
	    intervalBox[i] = nil;      /*  set to nil  */
	}
    }

    /*  ADD REQUIRED NUMBER OF BOXES (ASSUMES OLD BOXES ALREADY FREED)  */
    current_t_interval = currentSpecifierPtr->t_intervalHead;
    for (i = 0; i < currentSpecifierPtr->number_of_t_intervals; i++) {
	[self addIntervalBox:current_t_interval:i:currentSpecifierPtr->t_interval_mode];
	current_t_interval = current_t_interval->next;
    }

    /*  DISPLAY ALL BOXES  */
    [tProfileWindow display];

    return self;
}



- addIntervalBox:(t_intervalPtr)intervalPtr:(int)interval_number:(short int)mode
{
    char string[12];

    /*  ADD BOX  */
    r.origin.x = I_BOX_X + (interval_number * I_BOX_X_OFFSET);
    r.origin.y = I_BOX_Y;
    r.size.width = I_BOX_WIDTH;
    r.size.height = I_BOX_HEIGHT;
    intervalBox[interval_number] = [[Box alloc] initFrame:&r];

    sprintf(string,"Interval %-d\n",interval_number+1);
    [intervalBox[interval_number] setTitle:string];
    [intervalBox[interval_number] setTitlePosition:NX_BELOWTOP];
    [intervalBox[interval_number] setBorderType:NX_GROOVE];
    [intervalBox[interval_number] setOffsets:0.0:0.0];
    [[intervalBox[interval_number] contentView] sizeTo:I_BOX_WIDTH:I_BOX_HEIGHT];
    [[intervalBox[interval_number] contentView] moveTo:0.0:0.0];


    /*  ADD SWITCH 1  */
    r.origin.x = SWITCH1_X;
    r.origin.y = SWITCH1_Y;
    r.size.width = SWITCH1_WIDTH;
    r.size.height = SWITCH1_HEIGHT;
    IB_switch1[interval_number] = [[Matrix alloc] initFrame:&r mode:NX_RADIOMODE
				cellClass:[ButtonCell class] numRows:2 numCols:1];
    /*  SET TAG  */
    [IB_switch1[interval_number] setTag:interval_number];

    /*  MAKE SURE EACH CELL IS RIGHT HEIGHT  */
    r.size.height = SWITCH1_HEIGHT / 2.0;
    [IB_switch1[interval_number] setCellSize:&r.size];
    /*  ADD TO BOXES CONTENT VIEW  */
    [[intervalBox[interval_number] contentView] addSubview:IB_switch1[interval_number]];
    /*  SET SWITCH1 CELLS TO INITIAL VALUES  */  /*  change to read list  */
    [[IB_switch1[interval_number] cellAt:PROP:0] setIconPosition:NX_ICONLEFT];
    [[IB_switch1[interval_number] cellAt:PROP:0] setBordered:NO];
    [[IB_switch1[interval_number] cellAt:PROP:0] setIcon:"NXradio"];
    [[IB_switch1[interval_number] cellAt:PROP:0] setAltIcon:"NXradioH"];
    [[IB_switch1[interval_number] cellAt:PROP:0] setTitle:"Proportional"];
    [[IB_switch1[interval_number] cellAt:PROP:0] setAlignment:NX_LEFTALIGNED];
    [[IB_switch1[interval_number] cellAt:PROP:0] setShowsStateBy:NX_CONTENTS];
    [[IB_switch1[interval_number] cellAt:PROP:0] setHighlightsBy:NX_CONTENTS];
    [[IB_switch1[interval_number] cellAt:PROP:0] setAction:(SEL)@selector(switch1Hit:)];
    [[IB_switch1[interval_number] cellAt:PROP:0] setTarget:self];
	
    [[IB_switch1[interval_number] cellAt:RISE:0] setIconPosition:NX_ICONLEFT];
    [[IB_switch1[interval_number] cellAt:RISE:0] setBordered:NO];
    [[IB_switch1[interval_number] cellAt:RISE:0] setIcon:"NXradio"];
    [[IB_switch1[interval_number] cellAt:RISE:0] setAltIcon:"NXradioH"];
    [[IB_switch1[interval_number] cellAt:RISE:0] setTitle:"Fixed"];
    [[IB_switch1[interval_number] cellAt:RISE:0] setAlignment:NX_LEFTALIGNED];
    [[IB_switch1[interval_number] cellAt:RISE:0] setShowsStateBy:NX_CONTENTS];
    [[IB_switch1[interval_number] cellAt:RISE:0] setHighlightsBy:NX_CONTENTS];
    [[IB_switch1[interval_number] cellAt:RISE:0] setAction:(SEL)@selector(switch1Hit:)];
    [[IB_switch1[interval_number] cellAt:RISE:0] setTarget:self];
    /*  SET SWITCH ACCORDING TO INTERVAL STATE  */
    if (intervalPtr->proportional) {
        [IB_switch1[interval_number] selectCellAt:PROP:0];
    }
    else {
        [IB_switch1[interval_number] selectCellAt:FIXED:0];
    }
    /*  DISABLE SWITCH IF SPECIFIER IS FORMULA SPLIT, ELSE ENABLE IT  */
    if (currentSpecifierPtr->split_mode == SPLIT_MODE_FORMULA)
	[IB_switch1[interval_number] setEnabled:0];
    else
	[IB_switch1[interval_number] setEnabled:1];

    /*  ADD SWITCH 2  */
    r.origin.x = SWITCH2_X;
    r.origin.y = SWITCH2_Y;
    r.size.width = SWITCH2_WIDTH;
    r.size.height = SWITCH2_HEIGHT;
    IB_switch2[interval_number] = [[Button alloc] initFrame:&r];
    /*  SET TARGET AND ACTION  */
    [IB_switch2[interval_number] setAction:(SEL)@selector(switch2Hit:)];
    [IB_switch2[interval_number] setTarget:self];
    /*  SET TAG  */
    [IB_switch2[interval_number] setTag:interval_number];
    /*  ADD TO BOXES CONTENT VIEW  */
    [[intervalBox[interval_number] contentView] addSubview:IB_switch2[interval_number]];
    /*  SET SWITCH2 TO INITIAL VALUES  */
    [IB_switch2[interval_number] setType:NX_SWITCH];
    [IB_switch2[interval_number] setIconPosition:NX_ICONLEFT];
    [IB_switch2[interval_number] setTitle:"Stretch"];
    [IB_switch2[interval_number] setAlignment:NX_LEFTALIGNED];
    /*  SET SWITCH ACCORDING TO INTERVAL STATE  */
    [IB_switch2[interval_number] setState:intervalPtr->regression];

    /*  ADD FORM  */
    r.origin.x = FORM_X;
    r.origin.y = FORM_Y;
    r.size.width = FORM_WIDTH;
    r.size.height = FORM_HEIGHT;
    IB_form[interval_number] = [[Form alloc] initFrame:&r];
    /*  ADD TWO ITEMS WITH TITLES  */
    [[IB_form[interval_number] addEntry:"Length:"] setAlignment:NX_LEFTALIGNED];
    if (mode == FIXED_RISE_MODE)
    	[[IB_form[interval_number] addEntry:"Rise:"] setAlignment:NX_LEFTALIGNED];
    else if (mode == SLOPE_RATIO_MODE)
    	[[IB_form[interval_number] addEntry:"Ratio:"] setAlignment:NX_LEFTALIGNED];
    /*  SET FLOATING POINT FORMAT  */
    if (!intervalPtr->proportional) {
	[[IB_form[interval_number] cellAt:LENGTH:0] setFloatingPointFormat:NO left:3 right:0];
	[[IB_form[interval_number] cellAt:RISE:0] setFloatingPointFormat:NO left:3 right:2];
    }
    else {
	[[IB_form[interval_number] cellAt:LENGTH:0] setFloatingPointFormat:NO left:3 right:2];
	[[IB_form[interval_number] cellAt:RISE:0] setFloatingPointFormat:NO left:3 right:2];
    }

    [[intervalBox[interval_number] contentView] addSubview:IB_form[interval_number]];
    /*  SET LENGTH ACCORDING TO INTERVAL STATE AND SPLIT MODE  */
    if (currentSpecifierPtr->split_mode == SPLIT_MODE_ARBITRARY) {
	if (intervalPtr->proportional)
	    [IB_form[interval_number] setFloatValue:(intervalPtr->duration.fval*100.0) at:LENGTH];
	else
	    [IB_form[interval_number] setFloatValue:intervalPtr->duration.ival at:LENGTH];
	[[IB_form[interval_number] cellAt:LENGTH:0] setEnabled:1];
    }
    else {
	[IB_form[interval_number] setStringValue:"formula" at:LENGTH];
	[[IB_form[interval_number] cellAt:LENGTH:0] setEnabled:0];
    }

    /*  SET RISE OR RATIO, DEPENDING UPON MODE  */
    if (mode == FIXED_RISE_MODE)
    	[IB_form[interval_number] setFloatValue:(intervalPtr->rise*100.0) at:RISE];
    else if (mode == SLOPE_RATIO_MODE)
	[IB_form[interval_number] setFloatValue:(intervalPtr->slope_ratio) at:RISE];


    /*  ADD % AND ms TEXT  */
    r.origin.x = TEXT_X;
    r.origin.y = TEXT_Y;
    r.size.width = TEXT_WIDTH;
    r.size.height = TEXT_HEIGHT;
    IB_text[interval_number] = [[Matrix alloc] initFrame:&r mode:NX_TRACKMODE
				cellClass:[TextFieldCell class] numRows:2 numCols:1];
    /*  MAKE SURE EACH CELL IS RIGHT HEIGHT  */
    r.size.height = TEXT_HEIGHT / 2.0;
    [IB_text[interval_number] setCellSize:&r.size];
    /*  ADD TO BOXES CONTENT VIEW  */
    [[intervalBox[interval_number] contentView] addSubview:IB_text[interval_number]];
    /*  SET TEXT CELLS TO INITIAL VALUES  */
    if (currentSpecifierPtr->split_mode == SPLIT_MODE_ARBITRARY) {
	if (intervalPtr->proportional)
	    [[IB_text[interval_number] cellAt:LENGTH:0] setStringValue:"%"];
	else
	    [[IB_text[interval_number] cellAt:LENGTH:0] setStringValue:"ms"];
    }
    else
	[[IB_text[interval_number] cellAt:LENGTH:0] setStringValue:""];

    /*  USE % SIGN ONLY WHEN FIXED RISE MODE  */
    if (mode == FIXED_RISE_MODE)
    	[[IB_text[interval_number] cellAt:RISE:0] setStringValue:"%"];
    else if (mode == SLOPE_RATIO_MODE)
    	[[IB_text[interval_number] cellAt:RISE:0] setStringValue:""];

    /*  ADD RESET_BUTTON  */
    r.origin.x = RESET_BUTTON_X;
    r.origin.y = RESET_BUTTON_Y;
    r.size.width = RESET_BUTTON_WIDTH;
    r.size.height = RESET_BUTTON_HEIGHT;
    IB_reset_button[interval_number] = [[Button alloc] initFrame:&r title:"Cancel"
					tag:interval_number
					target:self action:(SEL)(@selector(intervalReset:))
					key:0 enabled:YES];
    /*  SET TAG  */
    [IB_reset_button[interval_number] setTag:interval_number];

    [[intervalBox[interval_number] contentView] addSubview:IB_reset_button[interval_number]];


    /*  ADD SET_BUTTON  */
    r.origin.x = SET_BUTTON_X;
    r.origin.y = SET_BUTTON_Y;
    r.size.width = SET_BUTTON_WIDTH;
    r.size.height = SET_BUTTON_HEIGHT;
    IB_set_button[interval_number] = [[Button alloc] initFrame:&r title:"Set" tag:interval_number
					target:self action:(SEL)(@selector(intervalSet:))
					 key:0 enabled:YES];
    /*  ADD RETURN SIGN ICON  */
    [IB_set_button[interval_number] setIcon:"NXreturnSign" position:NX_ICONRIGHT];
    /*  SET TAG  */
    [IB_set_button[interval_number] setTag:interval_number];
    [[intervalBox[interval_number] contentView] addSubview:IB_set_button[interval_number]];
    /*  MAKE THIS THE TARGET OF FORM RETURN STROKE  */
    [IB_form[interval_number] setTarget:IB_set_button[interval_number]];
    [IB_form[interval_number] setAction:(SEL)(@selector(performClick:))];

    [[tProfileWindow contentView] addSubview:intervalBox[interval_number]];


    return self;
}



- intervalReset:sender
{
    int interval_number;
    t_intervalPtr intervalPtr;

    /*  GET INTERVAL NUMBER OF SENDER  */
    interval_number = [sender tag];

    /*  GET PROPER INTERVAL POINTER  */
    intervalPtr = [self intervalPointer:currentSpecifierPtr:interval_number];

    /*  SET SWITCH 1 ACCORDING TO INTERVAL STATE  */
    if (intervalPtr->proportional) {
        [IB_switch1[interval_number] selectCellAt:PROP:0];
    }
    else {
        [IB_switch1[interval_number] selectCellAt:FIXED:0];
    }

    /*  SET SWITCH 2 ACCORDING TO INTERVAL STATE  */
    [IB_switch2[interval_number] setState:intervalPtr->regression];

    /*  SET FLOATING POINT FORMAT  */
    if (!intervalPtr->proportional) {
	[[IB_form[interval_number] cellAt:LENGTH:0] setFloatingPointFormat:NO left:3 right:0];
	[[IB_form[interval_number] cellAt:RISE:0] setFloatingPointFormat:NO left:3 right:2];
    }
    else {
	[[IB_form[interval_number] cellAt:LENGTH:0] setFloatingPointFormat:NO left:3 right:2];
	[[IB_form[interval_number] cellAt:RISE:0] setFloatingPointFormat:NO left:3 right:2];
    }

    /*  SET LENGTH AND RISE ACCORDING TO INTERVAL STATE, IF ARBITRARY  */
    if (currentSpecifierPtr->split_mode == SPLIT_MODE_ARBITRARY) {
	if (intervalPtr->proportional)
	    [IB_form[interval_number] setFloatValue:(intervalPtr->duration.fval*100.0) at:LENGTH];
	else
	    [IB_form[interval_number] setIntValue:intervalPtr->duration.ival at:LENGTH];
    }
    else
	[IB_form[interval_number] setStringValue:"formula" at:LENGTH];
    
    /*  SET RISE OR SLOPE RATIO ACCORDING TO TRANSITION MODE  */
    if (currentSpecifierPtr->t_interval_mode == FIXED_RISE_MODE)
	[IB_form[interval_number] setFloatValue:(intervalPtr->rise*100.0) at:RISE];
    else if (currentSpecifierPtr->t_interval_mode == SLOPE_RATIO_MODE)
	[IB_form[interval_number] setFloatValue:(intervalPtr->slope_ratio) at:RISE];
    
    /*  SET TEXT CELLS TO PROPER VALUES  */
    if (currentSpecifierPtr->split_mode == SPLIT_MODE_ARBITRARY) {
	if (intervalPtr->proportional)
	    [[IB_text[interval_number] cellAt:LENGTH:0] setStringValue:"%"];
	else
	    [[IB_text[interval_number] cellAt:LENGTH:0] setStringValue:"ms"];
    }
    else
	[[IB_text[interval_number] cellAt:LENGTH:0] setStringValue:""];
    
    return self;
}



- intervalSet:sender
{
    int interval_number, nint();
    t_intervalPtr intervalPtr, current_interval_ptr;
    float current_rise, new_rise;
    
    int old_value = 0, new_value = 0, length_changed = NO;
    
    /*  GET INTERVAL NUMBER FROM SENDER  */
    interval_number = [sender tag];
    
    /*  GET PROPER INTERVAL POINTER  */
    intervalPtr = [self intervalPointer:currentSpecifierPtr:interval_number];
    
    /*  SET LENGTH, ONLY IF ARBITRARY SPLIT  */
    if (currentSpecifierPtr->split_mode == SPLIT_MODE_ARBITRARY) {
	/*  FIXED INTERVAL  */
	if (!intervalPtr->proportional) {
	    int fixed_value;
	    int sample_value;
	    
	    /*  GET DESIRED VALUE AND SAMPLE VALUE  */
	    fixed_value = [IB_form[interval_number] intValueAt:0];
	    sample_value = [template sampleValue];
	    
	    /*  MAKE SURE VALUE IS NO LESS THAN SAMPLE VALUE  */
	    fixed_value = (fixed_value < sample_value) ? sample_value : fixed_value;
	    /*  MAKE SURE VALUE IS MULTIPLE OF SAMPLE VALUE  */
	    fixed_value = nint((float)fixed_value/(float)sample_value) * sample_value;
	    /*  should do a check to make sure duration not too long  */
	    /*  SEE IF LENGTH ACTUALLY CHANGED  */
	    old_value = intervalPtr->duration.ival;
	    if (old_value != fixed_value)
		length_changed = YES;
	    else
		length_changed = NO;
	    /*  SET THE DURATION IN LIST  */
	    intervalPtr->duration.ival = fixed_value;
	    new_value = fixed_value;
	}
	/*  PROPORTIONAL INTERVAL  */
	else {
	    int i, number_of_p_intervals = 0;
	    float new_proportion, other_proportion_min, proportion_ceiling;
	    float old_proportion, proportion_change;
	    
	    /*  GET DESIRED PROPORTION  */
	    new_proportion = [IB_form[interval_number] floatValueAt:0] / 100.0;
	    
	    /*  IF THE ONLY PROPORTIONAL INTERVAL, THEN SET TO 100%  */
	    current_interval_ptr = currentSpecifierPtr->t_intervalHead;
	    for (i = 0; i < currentSpecifierPtr->number_of_t_intervals; i++) {
		if (current_interval_ptr->proportional)
		    number_of_p_intervals++;
		current_interval_ptr = current_interval_ptr->next;
	    }
	    if (number_of_p_intervals == 1)
		new_proportion = 1.0;
	    
	    /*  MAKE SURE THE PROPORTION IS NOT BELOW MINIMUM  */
	    new_proportion = (new_proportion < PROPORTION_MIN) ? PROPORTION_MIN : new_proportion;
	    /*  LIMIT PROPORTIONAL INTERVAL SO THAT ALL OTHER PROPORTIONAL
		INTERVALS NEVER FALL BELOW THE MINIMUM  */
	    other_proportion_min = (float)(number_of_p_intervals-1) * PROPORTION_MIN;
	    proportion_ceiling = 1.0 - other_proportion_min;
	    new_proportion =
		(new_proportion > proportion_ceiling) ? proportion_ceiling : new_proportion;
	    
	    /*  GET OLD INTERVAL PROPORTION  */
	    old_proportion = intervalPtr->duration.fval;
	    /*  CALCULATE CHANGE OF INTERVAL SIZE  */
	    proportion_change = new_proportion - old_proportion;
	    /*  SEE IF LENGTH ACTUALLY CHANGED  */
	    if (proportion_change != 0.0)
		length_changed = YES;
	    else
		length_changed = NO;
	    
	    
	    /*  SET THE CURRENT INTERVAL TO LIMITED PROPORTION  */
	    intervalPtr->duration.fval = new_proportion;
	    
	    /*  DISTRIBUTE CHANGE OF INTERVAL SIZE FIRST TO RIGHT, THEN LEFT  */
	    current_interval_ptr = intervalPtr->next;
	    i = 0;
	    while ((proportion_change != 0.0) && (current_interval_ptr != NULL)) {
		float old_interval_proportion;
		
		i++;
		if (current_interval_ptr->proportional) {
		    old_interval_proportion = current_interval_ptr->duration.fval;
		    current_interval_ptr->duration.fval -= proportion_change;
		    if (current_interval_ptr->duration.fval < PROPORTION_MIN)
			current_interval_ptr->duration.fval = PROPORTION_MIN;
		    /*  RESET INTERVAL BOX FOR CHANGED INTERVAL  */
		    [self intervalReset:IB_reset_button[interval_number+i]];
		    proportion_change -= 
			(old_interval_proportion - current_interval_ptr->duration.fval);
		}
		current_interval_ptr = current_interval_ptr->next;
	    }
	    
	    current_interval_ptr = intervalPtr->previous;
	    i = 0;
	    while ((proportion_change != 0.0) && (current_interval_ptr != NULL)) {
		float old_interval_proportion;
		
		i++;
		if (current_interval_ptr->proportional) {
		    old_interval_proportion = current_interval_ptr->duration.fval;
		    current_interval_ptr->duration.fval -= proportion_change;
		    if (current_interval_ptr->duration.fval < PROPORTION_MIN)
			current_interval_ptr->duration.fval = PROPORTION_MIN;
		    /*  RESET INTERVAL BOX FOR CHANGED INTERVAL  */
		    [self intervalReset:IB_reset_button[interval_number-i]];
		    proportion_change -= 
			(old_interval_proportion - current_interval_ptr->duration.fval);
		}
		current_interval_ptr = current_interval_ptr->previous;
	    }
	}
    }

    /*  SET RISE OR SLOPE RATIO  */
    if (currentSpecifierPtr->t_interval_mode == FIXED_RISE_MODE) {
	/*  SET RISE  */
	current_rise = intervalPtr->rise;
	new_rise = [IB_form[interval_number] floatValueAt:RISE] / 100.0;
	/*  IF ONLY ONE INTERVAL, THEN SET TO 100%  */
	if (currentSpecifierPtr->number_of_t_intervals == 1) {
	    intervalPtr->rise = 1.0;
	}
	else {
	    /*  SUBTRACT INCREASE IN RISE FROM NEXT INTERVAL, UNLESS IT IS LAST ONE  */
	    if (intervalPtr->next != NULL) {
		intervalPtr->rise = new_rise;
		(intervalPtr->next->rise) -= (new_rise - current_rise);
		/*  RESET INTERVAL BOX FOR CHANGED INTERVAL  */
		[self intervalReset:IB_reset_button[interval_number+1]];
	    }
	    else {
		intervalPtr->rise = new_rise;
		(intervalPtr->previous->rise) -= (new_rise - current_rise);
		/*  RESET INTERVAL BOX FOR CHANGED INTERVAL  */
		[self intervalReset:IB_reset_button[interval_number-1]];
	    }
	}
    }
    else if (currentSpecifierPtr->t_interval_mode == SLOPE_RATIO_MODE) {
	/*  SET SLOPE RATIO  */
	intervalPtr->slope_ratio = [IB_form[interval_number] floatValueAt:RISE];
	/*  IF ONLY ONE INTERVAL, THEN SET TO 1  */
	if (currentSpecifierPtr->number_of_t_intervals == 1)
	    intervalPtr->slope_ratio = 1.0;
    }

    /*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
    [self intervalReset:IB_reset_button[interval_number]];

    /*  DISPLAY CHANGES  */
    [self displayTransition];

    /*  IF NECESSARY, PROPAGATE CHANGE OF LENGTH TO ALL SPECIAL EVENTS  */
    if (length_changed)
	[self propagateLengthChange:(interval_number+1)
	                           :(intervalPtr->proportional)
	                           :old_value
	                           :new_value];

    return self;
}



- switch1Hit:sender
{
    int interval_number, nint();
    t_intervalPtr intervalPtr, current_interval_ptr;

    /*  GET INTERVAL NUMBER  */
    interval_number = [sender tag];

    /*  GET PROPER INTERVAL POINTER  */
    intervalPtr = [self intervalPointer:currentSpecifierPtr:interval_number];

    /*  SET LENGTH  */
    /*  FIXED TO PROPORTIONAL  */
    if (!intervalPtr->proportional && ([sender selectedRow] == 0)) {
	t_intervalPtr forward_interval_ptr = NULL, backward_interval_ptr = NULL;
	int index;
	int forward_index = 1000000;
	int backward_index = 1000000;

	/*  SET FORM TO SHOW PERCENTAGE  */
	[[IB_text[interval_number] cellAt:PROP:0] setStringValue:"%"];

	/*  ROB 1/2 OF DURATION FROM NEAREST PROPORTIONAL INTERVAL  */
	/*  FIND NEAREST FORWARD PROPORTIONAL INTERVAL  */
	index = 0;
	current_interval_ptr = intervalPtr;
	while (current_interval_ptr->next != NULL) {
	    current_interval_ptr = current_interval_ptr->next;
	    index++;
	    if (current_interval_ptr->proportional) {
		forward_index = index;
		forward_interval_ptr = current_interval_ptr;
		break;
	    }
	}

	/*  FIND NEAREST BACKWARD PROPORTIONAL INTERVAL  */
	index = 0;
	current_interval_ptr = intervalPtr;
	while (current_interval_ptr->previous != NULL) {
	    current_interval_ptr = current_interval_ptr->previous;
	    index++;
	    if (current_interval_ptr->proportional) {
		backward_index = index;
		backward_interval_ptr = current_interval_ptr;
		break;
	    }
	}

        /*  CHOOSE THE NEAREST PROPORTIONAL INTERVAL, IF TIED, CHOOSE RIGHT ONE  */
	if (forward_index <= backward_index) {
	    current_interval_ptr = forward_interval_ptr;
	    index = forward_index;
	}
	else {
	    current_interval_ptr = backward_interval_ptr;
	    index = -backward_index;
	}

	/*  CUT THAT PROPORTIONAL INTERVAL'S DURATION IN HALF  */
	current_interval_ptr->duration.fval *= 0.5;

	/*  RESET THE INTERVAL BOX OF CHANGED INTERVAL  */
	[self intervalReset:IB_reset_button[interval_number+index]];

	/*  SET PRESENT INTERVAL TO SAME VALUE AS ALTERED INTERVAL  */
	intervalPtr->duration.fval = current_interval_ptr->duration.fval;

	/*  SET PRESENT INTERVAL TO PROPORTIONAL  */
	intervalPtr->proportional = YES;

    	/*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
    	[self intervalReset:IB_reset_button[interval_number]];

    	/*  DISPLAY CHANGES  */
  	[self displayTransition];

	/*  PROPAGATE CHANGE TO ANY SPECIAL EVENTS  */
	[self propagateModeChange:(int)interval_number];
    }
    /*  PROPORTIONAL TO FIXED  */
    else if (intervalPtr->proportional && ([sender selectedRow] == 1)) {
	int number_of_p_intervals, i, done;
	float old_proportion;

	/*  MUST BE AT LEAST ONE PROPORTIONAL INTERVAL  */
	current_interval_ptr = currentSpecifierPtr->t_intervalHead;
	number_of_p_intervals = 0;
	for (i = 0; i < currentSpecifierPtr->number_of_t_intervals; i++) {
	    if (current_interval_ptr->proportional)
		number_of_p_intervals++;
	    current_interval_ptr = current_interval_ptr->next;
	}
	if (number_of_p_intervals <= 1) {
	    NXBeep();
	    NXRunAlertPanel("Illegal",
		"There must be at least one proportional interval.",
	        "OK", NULL, NULL);
	    /*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
    	    [self intervalReset:IB_reset_button[interval_number]];
	    return self;
	}

	/*  GET OLD PROPORTION  */
	old_proportion = intervalPtr->duration.fval;

	/*  SET FORM TO SHOW MILLISECONDS  */
	[[IB_text[interval_number] cellAt:PROP:0] setStringValue:"ms"];

	/*  SET THE DURATION IN LIST TO DEFAULT  */
	/*  default should be multiple of sample size  */
	intervalPtr->duration.ival = FIXED_DURATION_DEF;

	/*  SET PRESENT INTERVAL TO FIXED  */
	intervalPtr->proportional = NO;

	/*  DISTRIBUTE OLD PROPORTION TO RIGHT, UNLESS LAST PROPORTIONAL INTERVAL  */
	done = NO; i = 0;
	current_interval_ptr = intervalPtr->next;
	while (!done && (current_interval_ptr != NULL)) {
	     i++;
	     if (current_interval_ptr->proportional) {
		(current_interval_ptr->duration.fval) += old_proportion;
		/*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
	    	[self intervalReset:IB_reset_button[interval_number+i]];
		done = YES;
	     }
	     current_interval_ptr = current_interval_ptr->next;
	}
	i = 0;
	current_interval_ptr = intervalPtr->previous;
	while (!done && (current_interval_ptr != NULL)) {
	     i++;
	     if (current_interval_ptr->proportional) {
		(current_interval_ptr->duration.fval) += old_proportion;
		/*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
	    	[self intervalReset:IB_reset_button[interval_number-i]];
		done = YES;
	     }
	     current_interval_ptr = current_interval_ptr->previous;
	}

    	/*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
    	[self intervalReset:IB_reset_button[interval_number]];

    	/*  DISPLAY CHANGES  */
    	[self displayTransition];

	/*  PROPAGATE CHANGE TO ANY SPECIAL EVENTS  */
	[self propagateModeChange:(int)interval_number];
    }

    return self;
}



- switch2Hit:sender
{
    t_intervalPtr intervalPtr;

    /*  GET PROPER INTERVAL POINTER  */
    intervalPtr = [self intervalPointer:currentSpecifierPtr:[sender tag]];

    /*  SET REGRESSION  */
    intervalPtr->regression = [sender state];

    /*  DISPLAY CHANGES  */
    [self displayTransition];
    [self displaySpecialEvent:specialEventStatus:specialEventSubInterval];

    return self;
}



- (t_intervalPtr)intervalPointer:(specifierStructPtr)specifierPtr:(int)interval_number
{
    t_intervalPtr current_t_interval;
    int i;

    current_t_interval = specifierPtr->t_intervalHead;
    for (i = 0; i < interval_number; i++)
	current_t_interval = current_t_interval->next;

    return current_t_interval;
}



- (BOOL)validCategory:(char *)symbol
{
    /*  CHECK CATEGORIES, TEMPLATE AND PHONE FOR VALID CATEGORY  */
    if ([categories usedAsCategorySymbol:symbol])
	return(YES);
    else if ([template usedAsPhoneSymbol:symbol])
	return(YES);
    else if (!strcmp(symbol,SPECIFIER_DEF))
	return(YES);
    else
	return(NO);
}



- fixedRiseMode:sender
{
    /*  IF ALREADY FIXED RISE MODE, DO NOTHING  */
    if (currentSpecifierPtr->t_interval_mode == FIXED_RISE_MODE)
	return self;

    /*  SET THE MODE FOR THE CURRENT SPECIFIER  */
    currentSpecifierPtr->t_interval_mode = FIXED_RISE_MODE;

    /*  DO BEST FIT CONVERSION OF SLOPE_RATIO TO FIXED_RISE  */
    [self convertRatioToRise:currentSpecifierPtr];

    /*  REDISPLAY BOTH INTERVAL BOXES AND GRAPHICS  */
    [self displayTransition];
    [self displayIntervalBoxes];

    return self;
}



- slopeRatioMode:sender
{
    /*  IF ALREADY SLOPE RATIO MODE, DO NOTHING  */
    if (currentSpecifierPtr->t_interval_mode == SLOPE_RATIO_MODE)
	return self;

    /*  SET THE MODE FOR THE CURRENT SPECIFIER  */
    currentSpecifierPtr->t_interval_mode = SLOPE_RATIO_MODE;

    /*  DO BEST FIT CONVERSION OF FIXED_RISE TO SLOPE_RATIO */
    [self convertRiseToRatio:currentSpecifierPtr];

    /*  REDISPLAY BOTH INTERVAL BOXES AND GRAPHICS  */
    [self displayTransition];
    [self displayIntervalBoxes];

    return self;
}



- arbitrarySplit:sender
{
    /*  IF NO CHANGE OF STATE, RETURN IMMEDIATELY  */
    if (currentSpecifierPtr->split_mode == SPLIT_MODE_ARBITRARY)
	return self;

    /*  STORE THE NEW SPLIT MODE IN THE SPECIFIER  */
    currentSpecifierPtr->split_mode = SPLIT_MODE_ARBITRARY;

    /*  ENABLE DURATION RULE BUTTONS  */
    [durSwitch setEnabled:1];

    /*  ENABLE OTHER BUTTONS  */
    [splitIntervalButton setEnabled:1];
    [deleteIntervalButton setEnabled:1];
    [defaultButton setEnabled:1];
    
    /*  REDISPLAY INTERVAL BOXES  */
    [self displayIntervalBoxes];

    return self;
}



- formulaSplit:sender
{
    /*  IF NO CHANGE OF STATE, RETURN IMMEDIATELY  */
    if (currentSpecifierPtr->split_mode == SPLIT_MODE_FORMULA)
	return self;

    /*  STORE THE NEW SPLIT MODE IN THE SPECIFIER  */
    currentSpecifierPtr->split_mode = SPLIT_MODE_FORMULA;

    /*  DISABLE CERTAIN DURATION RULE BUTTONS  */
    [[durSwitch cellAt:DUR_RULE_P1:0] setEnabled:0];
    [[durSwitch cellAt:DUR_RULE_P2:0] setEnabled:0];
    [[durSwitch cellAt:DUR_RULE_AVG:0] setEnabled:0];
    [[durSwitch cellAt:DUR_RULE_FIXED:0] setEnabled:0];

    /*  DISABLE OTHER BUTTONS  */
    [splitIntervalButton setEnabled:0];
    [deleteIntervalButton setEnabled:0];
    [defaultButton setEnabled:0];

    /*  RESET TO DEFAULT SETTINGS (3 PART SPLIT)  */
    [self tProfileDefault:self];

    return self;
}



- convertRatioToRise:(specifierStructPtr)specifier
{
    int i, total_intervals, number_of_p_intervals = 0;
    int number_of_f_intervals = 0, fixed_total_duration = 0;
    float proportional_space, fixed_space, m_ref, sum = 0.0;
    t_intervalPtr current_interval_ptr = NULL;

    /*  GET TOTAL NUMBER OF INTERVALS  */
    total_intervals = specifier->number_of_t_intervals;

    /*  FIND FIXED AND PROPORTIONAL SPACE AND NUMBER OF INTERVALS  */
    current_interval_ptr = specifier->t_intervalHead;
    for (i = 0; i < total_intervals; i++) {
	if (current_interval_ptr->proportional)
	    number_of_p_intervals++;
	else {
	    number_of_f_intervals++;
	    fixed_total_duration += current_interval_ptr->duration.ival;
	}
        current_interval_ptr = current_interval_ptr->next;
    }
    proportional_space = ((float)number_of_p_intervals/(float)total_intervals);
    fixed_space = ((float)number_of_f_intervals/(float)total_intervals);

    /*  FIND REFERENCE SLOPE GIVEN THE SLOPE RATIOS AND INTERVAL LENGTHS  */
    current_interval_ptr = specifier->t_intervalHead;
    for (i = 0; i < total_intervals; i++) {
	if (current_interval_ptr->proportional) {
	    sum += (current_interval_ptr->slope_ratio *
		    (current_interval_ptr->duration.fval * proportional_space));
	}
	else {
	    sum += (current_interval_ptr->slope_ratio * 
		    ((float)current_interval_ptr->duration.ival/(float)fixed_total_duration) *
		    fixed_space);
	}

        current_interval_ptr = current_interval_ptr->next;
    }
    m_ref = 1.0 / sum;

    /*  CALCULATE THE EQUIVALENT RISE FOR EACH INTERVAL  */
    current_interval_ptr = specifier->t_intervalHead;
    for (i = 0; i < total_intervals; i++) {
	if (current_interval_ptr->proportional) {
	    current_interval_ptr->rise = (current_interval_ptr->slope_ratio *
					  m_ref *
		    (current_interval_ptr->duration.fval * proportional_space));
	}
	else {
	    current_interval_ptr->rise = (current_interval_ptr->slope_ratio * 
					  m_ref *
		    ((float)current_interval_ptr->duration.ival/(float)fixed_total_duration) *
		    fixed_space);
	}
        current_interval_ptr = current_interval_ptr->next;
    }

    return self;
}



- convertRiseToRatio:(specifierStructPtr)specifier
{
    int i, total_intervals, number_of_p_intervals = 0;
    int number_of_f_intervals = 0, fixed_total_duration = 0;
    float proportional_space, fixed_space;
    double abs_slope, smallest_slope = 1000000.0;
    t_intervalPtr current_interval_ptr = NULL;

    /*  GET TOTAL NUMBER OF INTERVALS  */
    total_intervals = specifier->number_of_t_intervals;

    /*  FIND FIXED AND PROPORTIONAL SPACE AND NUMBER OF INTERVALS  */
    current_interval_ptr = specifier->t_intervalHead;
    for (i = 0; i < total_intervals; i++) {
	if (current_interval_ptr->proportional)
	    number_of_p_intervals++;
	else {
	    number_of_f_intervals++;
	    fixed_total_duration += current_interval_ptr->duration.ival;
	}
        current_interval_ptr = current_interval_ptr->next;
    }
    proportional_space = ((float)number_of_p_intervals/(float)total_intervals);
    fixed_space = ((float)number_of_f_intervals/(float)total_intervals);

    /*  CALCULATE THE EQUIVALENT SLOPE FOR EACH INTERVAL  */
    current_interval_ptr = specifier->t_intervalHead;
    for (i = 0; i < total_intervals; i++) {
	if (current_interval_ptr->proportional) {
	    current_interval_ptr->slope_ratio = current_interval_ptr->rise /
		    (current_interval_ptr->duration.fval * proportional_space);
	}
	else {
	    current_interval_ptr->slope_ratio = current_interval_ptr->rise /
		    (((float)current_interval_ptr->duration.ival/(float)fixed_total_duration) *
		    fixed_space);
	}
	/*  KEEP TRACK OF SMALLEST SLOPE, UNLESS VERY CLOSE TO ZERO  */
	abs_slope = fabs(current_interval_ptr->slope_ratio);
	if ((abs_slope > 0.05) && (abs_slope < smallest_slope))
	    smallest_slope = abs_slope;

        current_interval_ptr = current_interval_ptr->next;
    }

    /*  SCALE ALL THE SLOPES SO THAT THE SMALLEST SLOPE = 1.0  */
    current_interval_ptr = specifier->t_intervalHead;
    for (i = 0; i < total_intervals; i++) {
	current_interval_ptr->slope_ratio /= smallest_slope;
        current_interval_ptr = current_interval_ptr->next;
    }
    
    return self;
}



- displayTransition
{
    /*  IF SPECIFIER IN SLOPE FORM, DO SLOPE TO RISE CONVERSION
	SO THAT THE GRAPH CAN BE DISPLAYED  */
    if (currentSpecifierPtr->t_interval_mode == SLOPE_RATIO_MODE)
	[self convertRatioToRise:currentSpecifierPtr];

    /*  DO ACTUAL DRAWING OF TRANSITION  */
    [transitionView displayTransition:currentSpecifierPtr];

    return self;
}



- displaySpecialEvent:(int)status:(int)intervalNumber
{
    float range;
    int i;

    /*  SET SPECIAL EVENT STATUS  */
    specialEventStatus = status;
    specialEventSubInterval = intervalNumber;

    if (status == NO_DISPLAY) {
    	/*  SET ALL THE BUTTONS OFF  */
    	[seZoomButton setEnabled:0];
    	[seSplitButton setEnabled:0];
    	[seDeleteButton setEnabled:0];
    	[seModeSwitch setEnabled:0];
    	[seDefaultButton setEnabled:0];
    	[seCopyButton setEnabled:0];

	/*  BLANK DISPLAY  */
	[specialEventView blankDisplay];

	/*  FREE ALL NON-NIL BOXES  */
	for (i = 0; i < SUB_INTERVALS_MAX; i++) {
	    if (subIntervalBox[i] != nil) {
		[subIntervalBox[i] free];     /*  frees all subviews  */
		subIntervalBox[i] = nil;      /*  set to nil  */
	    }
	}

	/*  REDISPLAY  */
	[seProfileWindow display];
    }
    else if (status == ZOOM_OUT) {
    	/*  SET ALL THE BUTTONS PROPERLY  */
    	[seZoomButton setEnabled:1];
    	[seZoomButton setState:ZOOM_OUT];
    	[seSplitButton setEnabled:0];
    	[seDeleteButton setEnabled:0];
    	[seModeSwitch setEnabled:1];
    	[seDefaultButton setEnabled:1];
    	[seCopyButton setEnabled:1];

	/*  SET UP BACKGROUND DISPLAY OF THE INSPECTOR  */
    	range = [template parameterSymMaximum:currentSEPtr->symbol] - 
		[template parameterSymMinimum:currentSEPtr->symbol];
    	[specialEventView createbackground:range];

	/*  DISPLAY CURRENT SPECIAL EVENT  */
    	[specialEventView zoomOutDisplay:currentSpecifierPtr:currentSEPtr];

	/*  FREE ALL NON-NIL BOXES  */
	for (i = 0; i < SUB_INTERVALS_MAX; i++) {
	    if (subIntervalBox[i] != nil) {
		[subIntervalBox[i] free];     /*  frees all subviews  */
		subIntervalBox[i] = nil;      /*  set to nil  */
	    }
	}

	/*  REDISPLAY  */
	[seProfileWindow display];
    }
    else if (status == ZOOM_IN) {
	int i;
	t_intervalPtr current_t_interval_ptr;

	/*  DISABLE SOME BUTTONS, ENABLE OTHERS  */
	[seSplitButton setEnabled:1];
	[seDeleteButton setEnabled:1];
	[seModeSwitch setEnabled:0];
	[seDefaultButton setEnabled:0];
	[seCopyButton setEnabled:0];

	/*  DISPLAY CURRENT SPECIAL EVENT  */
	current_t_interval_ptr = currentSpecifierPtr->t_intervalHead;
	for (i = 1; i < intervalNumber; i++)
	    current_t_interval_ptr = current_t_interval_ptr->next;


	/*  DISPLAY GRAPH  */
	[specialEventView zoomInDisplay:currentSpecifierPtr:currentSEPtr:
	                                currentSEIntervalPtr:
	                                current_t_interval_ptr->regression];

	/*  DISPLAY SUB INTERVAL BOXES  */
	[self displaySubIntervalBoxes];
    }

    return self;
}



- seProfileDefault:sender
{
    /*  RESET THE CURRENT SPECIAL EVENT TO DEFAULT STATE  */
    [self setSEPToDefault:currentSEPtr];

    /*  RE-DISPLAY SPECIAL EVENT  */
    [self displaySpecialEvent:specialEventStatus:specialEventSubInterval];

    return self;
}


- propagateDefaultToSEProfiles
{
    int i;
    specialEventStructPtr current_SEPtr;

    /*  SET ALL SPECIAL EVENTS TO DEFAULT STATE  */
    current_SEPtr = currentSpecifierPtr->specialEventHead;
    for (i = 0; i < currentSpecifierPtr->number_of_special_events; i++) {
	[self setSEPToDefault:current_SEPtr];
	current_SEPtr = current_SEPtr->next;
    }

    /*  RE-DISPLAY SPECIAL EVENT, IF NECESSARY  */
    if (currentSpecifierPtr->number_of_special_events > 0) {
	if (specialEventStatus == ZOOM_IN)
	    [self displaySpecialEvent:ZOOM_OUT:0];
	else
	    [self displaySpecialEvent:specialEventStatus:specialEventSubInterval];
    }

    return self;
}

- setSEPToDefault:(specialEventStructPtr)current_SEPtr
{
    se_intervalPtr current_se_interval_ptr, temp_se_interval_ptr;
    void free_se_interval();

    /*  FIRST ERASE ANY OLD SPECIAL EVENT PROFILE MEMORY, IF IT EXISTS  */
    if (current_SEPtr != NULL) {
	current_se_interval_ptr = current_SEPtr->se_intervalHead;
	while (current_se_interval_ptr != NULL) {
	    temp_se_interval_ptr = current_se_interval_ptr->next;
	    free_se_interval(current_se_interval_ptr);
	    current_se_interval_ptr = temp_se_interval_ptr;
	}
    }

    /*  SET UP DEFAULT SPECIAL EVENT PROFILE  */
    [self defaultSpecialEventProfile:current_SEPtr];

    return self;
}



- defaultSpecialEventProfile:(specialEventStructPtr)current_SEPtr
{
    se_intervalPtr new_se_interval();
    sub_intervalPtr new_sub_interval();    
    se_intervalPtr current_se_interval_ptr;
    t_intervalPtr current_t_interval_ptr;
    int i;

    /*  CREATE PROPER NUMBER OF SPECIAL EVENT INTERVALS (SAME # AS T_INTERVALS)  */
    current_se_interval_ptr = current_SEPtr->se_intervalHead = new_se_interval();
    current_se_interval_ptr->next = NULL;
    current_se_interval_ptr->previous = NULL;
    for (i = 1; i < currentSpecifierPtr->number_of_t_intervals; i++) {
	current_se_interval_ptr->next = new_se_interval();
	current_se_interval_ptr->next->next = NULL;
	current_se_interval_ptr->next->previous = current_se_interval_ptr;
	current_se_interval_ptr = current_se_interval_ptr->next;
    }

    /*  CREATE ONE SUBINTERVAL FOR EACH SPECIAL EVENT INTERVAL, INITIALIZE  */
    current_se_interval_ptr = current_SEPtr->se_intervalHead;
    current_t_interval_ptr = currentSpecifierPtr->t_intervalHead;
    for (i = 0; i < currentSpecifierPtr->number_of_t_intervals; i++) {
	current_se_interval_ptr->sub_intervalHead = new_sub_interval();
	current_se_interval_ptr->sub_intervalHead->next = NULL;
	current_se_interval_ptr->sub_intervalHead->previous = NULL;
	current_se_interval_ptr->number_of_sub_intervals = 1;

	/*  THE SUBINTERVAL WILL BE THE SAME AS THE TRANSITION INTERVAL  */
        current_se_interval_ptr->sub_intervalHead->proportional = 
		current_t_interval_ptr->proportional;
        /*  IF ONLY ONE PROPORTIONAL INTERVAL, ITS LENGTH IS 100%  */
	if (current_se_interval_ptr->sub_intervalHead->proportional)
	    current_se_interval_ptr->sub_intervalHead->duration.fval = 1.0;
	/*  IF ONLY ONE ABSOLUTE VALUE INTERVAL, ITS LENGTH IS SAME AS T_INTERVAL  */
	else
	    current_se_interval_ptr->sub_intervalHead->duration.ival =
		current_t_interval_ptr->duration.ival;

	/*  DEFAULT RISE OF 0  */
        current_se_interval_ptr->sub_intervalHead->rise = 0.0;

	current_se_interval_ptr = current_se_interval_ptr->next;
	current_t_interval_ptr = current_t_interval_ptr->next;
    }

    
    return self;
}



- seZoom:sender
{
    if ([sender state] == ZOOM_OUT) {
	/*  BLANK OUT SUBINTERVAL BOXES  */
	[self displaySpecialEvent:ZOOM_OUT:0];
    }
    else {      /*  ZOOM_IN  */
	/*  PUT CURSOR IN FORM FIELD  */
	[zoomInForm selectText:sender];
	
	/*  PUT PANEL IN PROPER RELATION TO TEMPLATE WINDOW  */
	[seProfileWindow getFrame:(NXRect *)&r];
	[zoomInPanel moveTo:(NXCoord)r.origin.x+ZOOM_X_OFFSET
	 :(NXCoord)r.origin.y+ZOOM_Y_OFFSET];
	
	/*  MAKE PANEL VISIBLE  */
	[zoomInPanel makeKeyAndOrderFront:self];
	
	/*  MAKE SURE PANEL IS MODAL  */
	[NXApp runModalFor:zoomInPanel];
    }

    return self;
}




- zoomInOK:sender
{
    int interval_number, i;
    t_intervalPtr current_t_interval_ptr;

    /*  MAKE SURE THE NUMBER CHOSEN IS IN RANGE  */
    interval_number = [zoomInForm intValue];
    if ((interval_number < 1) || (interval_number > currentSpecifierPtr->number_of_t_intervals)) {
	NXBeep();
	NXRunAlertPanel("Illegal",
	    "No such interval.","OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[zoomInForm selectText:self];
	return self;
    }
    /*  ELSE, ZOOM IN ON DESIRED INTERVAL  */
    else {
	/*  SET CURRENT SE INTERVAL POINTER, AND FIXED FLAG  */
	current_t_interval_ptr = currentSpecifierPtr->t_intervalHead;
	currentSEIntervalPtr = currentSEPtr->se_intervalHead;
	for (i = 1; i < interval_number; i++) {
	    currentSEIntervalPtr = currentSEIntervalPtr->next;
	    current_t_interval_ptr = current_t_interval_ptr->next;
	}
	currentSEIntervalProp = current_t_interval_ptr->proportional;

	/*  DISPLAY GRAPH AND SUB INTERVAL BOXES  */
	[self displaySpecialEvent:ZOOM_IN:interval_number];
    }

    /*  CLOSE THE PANEL  */
    [zoomInPanel close];
    [NXApp stopModal];
    return self;

}



- zoomInCancel:sender
{
    /*  RESET BUTTON TO ZOOM_OUT STATE  */
    [seZoomButton setState:ZOOM_OUT];

    /*  CLOSE THE PANEL  */
    [zoomInPanel close];
    [NXApp stopModal];
    return self;
}




- displaySubIntervalBoxes
{
    int i;
    sub_intervalPtr current_sub_interval;

    /*  FREE ALL NON-NIL BOXES  */
    for (i = 0; i < SUB_INTERVALS_MAX; i++) {
	if (subIntervalBox[i] != nil) {
	    [subIntervalBox[i] free];     /*  FREES ALL SUBVIEWS  */
	    subIntervalBox[i] = nil;      /*  SET TO nil  */
	}
    }

    /*  ADD REQUIRED NUMBER OF BOXES (ASSUMES OLD BOXES ALREADY FREED)  */
    current_sub_interval = currentSEIntervalPtr->sub_intervalHead;
    for (i = 0; i < currentSEIntervalPtr->number_of_sub_intervals; i++) {
	/*  INDICATE ANCHOR POINT, IF NECESSARY  */
	if ( (currentSEIntervalPtr->next == NULL) && (current_sub_interval->next == NULL) )
	    [self addSubIntervalBox:current_sub_interval:i:YES];
	else
	    [self addSubIntervalBox:current_sub_interval:i:NO];

	current_sub_interval = current_sub_interval->next;
    }

    /*  DISPLAY ALL BOXES  */
    [seProfileWindow display];

    return self;
}



- addSubIntervalBox:(sub_intervalPtr)intervalPtr:(int)interval_number:(int)anchor
{
    char string[16];

    /*  ADD BOX  */
    r.origin.x = I_BOX_X + (interval_number * I_BOX_X_OFFSET);
    r.origin.y = I_BOX_Y;
    r.size.width = I_BOX_WIDTH;
    r.size.height = SI_BOX_HEIGHT;
    subIntervalBox[interval_number] = [[Box alloc] initFrame:&r];

    sprintf(string,"Sub-Interval %-d\n",interval_number+1);
    [subIntervalBox[interval_number] setTitle:string];
    [subIntervalBox[interval_number] setTitlePosition:NX_BELOWTOP];
    [subIntervalBox[interval_number] setBorderType:NX_GROOVE];
    [subIntervalBox[interval_number] setOffsets:0.0:0.0];
    [[subIntervalBox[interval_number] contentView] sizeTo:I_BOX_WIDTH:I_BOX_HEIGHT];
    [[subIntervalBox[interval_number] contentView] moveTo:0.0:0.0];


    /*  ADD SWITCH 1  */
    r.origin.x = SWITCH1_X;
    r.origin.y = SI_SWITCH1_Y;
    r.size.width = SWITCH1_WIDTH;
    r.size.height = SWITCH1_HEIGHT;
    SIB_switch1[interval_number] = [[Matrix alloc] initFrame:&r mode:NX_RADIOMODE
				cellClass:[ButtonCell class] numRows:2 numCols:1];
    /*  SET TAG  */
    [SIB_switch1[interval_number] setTag:interval_number];

    /*  MAKE SURE EACH CELL IS RIGHT HEIGHT  */
    r.size.height = SWITCH1_HEIGHT / 2.0;
    [SIB_switch1[interval_number] setCellSize:&r.size];
    /*  ADD TO BOXES CONTENT VIEW  */
    [[subIntervalBox[interval_number] contentView] addSubview:SIB_switch1[interval_number]];
    /*  SET SWITCH1 CELLS TO INITIAL VALUES  */  /*  change to read list  */
    [[SIB_switch1[interval_number] cellAt:PROP:0] setIconPosition:NX_ICONLEFT];
    [[SIB_switch1[interval_number] cellAt:PROP:0] setBordered:NO];
    [[SIB_switch1[interval_number] cellAt:PROP:0] setIcon:"NXradio"];
    [[SIB_switch1[interval_number] cellAt:PROP:0] setAltIcon:"NXradioH"];
    [[SIB_switch1[interval_number] cellAt:PROP:0] setTitle:"Proportional"];
    [[SIB_switch1[interval_number] cellAt:PROP:0] setAlignment:NX_LEFTALIGNED];
    [[SIB_switch1[interval_number] cellAt:PROP:0] setShowsStateBy:NX_CONTENTS];
    [[SIB_switch1[interval_number] cellAt:PROP:0] setHighlightsBy:NX_CONTENTS];
    [[SIB_switch1[interval_number] cellAt:PROP:0] setAction:(SEL)@selector(subSwitch1Hit:)];
    [[SIB_switch1[interval_number] cellAt:PROP:0] setTarget:self];
	
    [[SIB_switch1[interval_number] cellAt:RISE:0] setIconPosition:NX_ICONLEFT];
    [[SIB_switch1[interval_number] cellAt:RISE:0] setBordered:NO];
    [[SIB_switch1[interval_number] cellAt:RISE:0] setIcon:"NXradio"];
    [[SIB_switch1[interval_number] cellAt:RISE:0] setAltIcon:"NXradioH"];
    [[SIB_switch1[interval_number] cellAt:RISE:0] setTitle:"Fixed"];
    [[SIB_switch1[interval_number] cellAt:RISE:0] setAlignment:NX_LEFTALIGNED];
    [[SIB_switch1[interval_number] cellAt:RISE:0] setShowsStateBy:NX_CONTENTS];
    [[SIB_switch1[interval_number] cellAt:RISE:0] setHighlightsBy:NX_CONTENTS];
    [[SIB_switch1[interval_number] cellAt:RISE:0] setAction:(SEL)@selector(subSwitch1Hit:)];
    [[SIB_switch1[interval_number] cellAt:RISE:0] setTarget:self];
    /*  SET SWITCH ACCORDING TO INTERVAL STATE  */
    if (intervalPtr->proportional) {
        [SIB_switch1[interval_number] selectCellAt:PROP:0];
    }
    else {
        [SIB_switch1[interval_number] selectCellAt:FIXED:0];
    }
    /*  DISABLE SWITCH IF SE INTERVAL IS FIXED  */
    if (!currentSEIntervalProp)
	[SIB_switch1[interval_number] setEnabled:0];

    /*  ADD FORM  */
    r.origin.x = FORM_X;
    r.origin.y = FORM_Y;
    r.size.width = FORM_WIDTH;
    r.size.height = FORM_HEIGHT;
    SIB_form[interval_number] = [[Form alloc] initFrame:&r];
    /*  ADD TWO ITEMS WITH TITLES  */
    [[SIB_form[interval_number] addEntry:"Length:"] setAlignment:NX_LEFTALIGNED];
    [[SIB_form[interval_number] addEntry:"Value:"] setAlignment:NX_LEFTALIGNED];
    /*  SET FLOATING POINT FORMAT  */
    if (!intervalPtr->proportional) {
	[[SIB_form[interval_number] cellAt:LENGTH:0] setFloatingPointFormat:NO left:3 right:0];
	[[SIB_form[interval_number] cellAt:RISE:0] setFloatingPointFormat:NO left:3 right:2];
    }
    else {
	[[SIB_form[interval_number] cellAt:LENGTH:0] setFloatingPointFormat:NO left:3 right:2];
	[[SIB_form[interval_number] cellAt:RISE:0] setFloatingPointFormat:NO left:3 right:2];
    }

    [[subIntervalBox[interval_number] contentView] addSubview:SIB_form[interval_number]];
    /*  SET LENGTH ACCORDING TO INTERVAL STATE  */
    if (intervalPtr->proportional)
        [SIB_form[interval_number] setFloatValue:(intervalPtr->duration.fval*100.0) at:LENGTH];
    else
	[SIB_form[interval_number] setFloatValue:intervalPtr->duration.ival at:LENGTH];

    /*  SET RISE ABSOLUTE VALUE  */
    [SIB_form[interval_number] setFloatValue:(intervalPtr->rise) at:RISE];

    /*  IF ANCHOR POINT, DISABLE THE RISE FORM CELL  */
    if (anchor)
	[[SIB_form[interval_number] cellAt:RISE:0] setEnabled:0];

    /*  ADD % AND ms TEXT  */
    r.origin.x = TEXT_X;
    r.origin.y = TEXT_Y;
    r.size.width = TEXT_WIDTH;
    r.size.height = TEXT_HEIGHT;
    SIB_text[interval_number] = [[Matrix alloc] initFrame:&r mode:NX_TRACKMODE
				cellClass:[TextFieldCell class] numRows:2 numCols:1];
    /*  MAKE SURE EACH CELL IS RIGHT HEIGHT  */
    r.size.height = TEXT_HEIGHT / 2.0;
    [SIB_text[interval_number] setCellSize:&r.size];
    /*  ADD TO BOXES CONTENT VIEW  */
    [[subIntervalBox[interval_number] contentView] addSubview:SIB_text[interval_number]];
    /*  SET TEXT CELLS TO INITIAL VALUES  */
    if (intervalPtr->proportional)
        [[SIB_text[interval_number] cellAt:LENGTH:0] setStringValue:"%"];
    else
        [[SIB_text[interval_number] cellAt:LENGTH:0] setStringValue:"ms"];

    [[SIB_text[interval_number] cellAt:RISE:0] setStringValue:""];

    /*  ADD RESET_BUTTON  */
    r.origin.x = RESET_BUTTON_X;
    r.origin.y = RESET_BUTTON_Y;
    r.size.width = RESET_BUTTON_WIDTH;
    r.size.height = RESET_BUTTON_HEIGHT;
    SIB_reset_button[interval_number] = [[Button alloc] initFrame:&r title:"Cancel"
					tag:interval_number
					target:self action:(SEL)(@selector(subIntervalReset:))
					key:0 enabled:YES];
    /*  SET TAG  */
    [SIB_reset_button[interval_number] setTag:interval_number];

    [[subIntervalBox[interval_number] contentView] addSubview:SIB_reset_button[interval_number]];


    /*  ADD SET_BUTTON  */
    r.origin.x = SET_BUTTON_X;
    r.origin.y = SET_BUTTON_Y;
    r.size.width = SET_BUTTON_WIDTH;
    r.size.height = SET_BUTTON_HEIGHT;
    SIB_set_button[interval_number] = [[Button alloc] initFrame:&r title:"Set" tag:interval_number
					target:self action:(SEL)(@selector(subIntervalSet:))
					 key:0 enabled:YES];
    /*  ADD RETURN SIGN ICON  */
    [SIB_set_button[interval_number] setIcon:"NXreturnSign" position:NX_ICONRIGHT];
    /*  SET TAG  */
    [SIB_set_button[interval_number] setTag:interval_number];
    [[subIntervalBox[interval_number] contentView] addSubview:SIB_set_button[interval_number]];
    /*  MAKE THIS THE TARGET OF FORM RETURN STROKE  */
    [SIB_form[interval_number] setTarget:SIB_set_button[interval_number]];
    [SIB_form[interval_number] setAction:(SEL)(@selector(performClick:))];

    [[seProfileWindow contentView] addSubview:subIntervalBox[interval_number]];


    return self;
}

- subIntervalReset:sender
{
    int interval_number, i;
    sub_intervalPtr sub_interval_ptr;

    /*  GET INTERVAL NUMBER OF SENDER  */
    interval_number = [sender tag];

    /*  GET PROPER SUB-INTERVAL POINTER  */
    sub_interval_ptr = currentSEIntervalPtr->sub_intervalHead;
    for (i = 0; i < interval_number; i++)
	sub_interval_ptr = sub_interval_ptr->next;

    /*  SET SWITCH 1 ACCORDING TO INTERVAL STATE  */
    if (sub_interval_ptr->proportional) {
        [SIB_switch1[interval_number] selectCellAt:PROP:0];
    }
    else {
        [SIB_switch1[interval_number] selectCellAt:FIXED:0];
    }

    /*  DISABLE SWITCH IF SE INTERVAL IS FIXED  */
    if (!currentSEIntervalProp)
	[SIB_switch1[interval_number] setEnabled:0];

    /*  SET FLOATING POINT FORMAT  */
    if (!sub_interval_ptr->proportional) {
	[[SIB_form[interval_number] cellAt:LENGTH:0] setFloatingPointFormat:NO left:3 right:0];
	[[SIB_form[interval_number] cellAt:RISE:0] setFloatingPointFormat:NO left:3 right:2];
    }
    else {
	[[SIB_form[interval_number] cellAt:LENGTH:0] setFloatingPointFormat:NO left:3 right:2];
	[[SIB_form[interval_number] cellAt:RISE:0] setFloatingPointFormat:NO left:3 right:2];
    }

    /*  SET LENGTH AND RISE ACCORDING TO INTERVAL STATE  */
    if (sub_interval_ptr->proportional)
       [SIB_form[interval_number] setFloatValue:(sub_interval_ptr->duration.fval*100.0) at:LENGTH];
    else
       [SIB_form[interval_number] setIntValue:sub_interval_ptr->duration.ival at:LENGTH];

    /*  SET RISE VALUE  */
    [SIB_form[interval_number] setFloatValue:(sub_interval_ptr->rise) at:RISE];

    /*  SET TEXT CELLS TO PROPER VALUES  */
    if (sub_interval_ptr->proportional)
        [[SIB_text[interval_number] cellAt:LENGTH:0] setStringValue:"%"];
    else
        [[SIB_text[interval_number] cellAt:LENGTH:0] setStringValue:"ms"];

    return self;
}

- subIntervalSet:sender
{
    int interval_number, nint(), i;
    sub_intervalPtr intervalPtr, current_interval_ptr;
    float new_rise, range;
    t_intervalPtr current_t_interval_ptr;

    /*  GET INTERVAL NUMBER FROM SENDER  */
    interval_number = [sender tag];

    /*  GET PROPER SUB-INTERVAL POINTER  */
    intervalPtr = currentSEIntervalPtr->sub_intervalHead;
    for (i = 0; i < interval_number; i++)
	intervalPtr = intervalPtr->next;

    /*  SET RISE  */
    new_rise = [SIB_form[interval_number] floatValueAt:RISE];
    range = [template parameterSymMaximum:currentSEPtr->symbol] - 
	[template parameterSymMinimum:currentSEPtr->symbol];
    /*  MAKE SURE RISE IS NOT BEYOND ALLOWABLE RANGE  */
    if (new_rise > range) {
	NXBeep();
	new_rise = range;
    }
    else if (new_rise < (-range)) {
	NXBeep();
	new_rise = (-range);
    }
    intervalPtr->rise = new_rise;

    /*  SET LENGTH  */
    /*  FIXED INTERVAL  */
    if (!intervalPtr->proportional) {
	int fixed_value;
	int sample_value;
	int old_duration;
	    
	/*  GET OLD INTERVAL DURATION  */
	old_duration = intervalPtr->duration.ival;

 	/*  GET DESIRED VALUE AND SAMPLE VALUE  */
	fixed_value = [SIB_form[interval_number] intValueAt:0];
	sample_value = [template sampleValue];

	/*  MAKE SURE VALUE IS NO LESS THAN SAMPLE VALUE  */
	if (fixed_value < sample_value) {
	    NXBeep();
	    fixed_value = sample_value;
	}

	/*  MAKE SURE VALUE IS MULTIPLE OF SAMPLE VALUE  */
	fixed_value = nint((float)fixed_value/(float)sample_value) * sample_value;

	/*  IF ONLY ONE SUB-INTERVAL, THEN DO NOT ALLOW CHANGE  */
	if ((currentSEIntervalPtr->number_of_sub_intervals <= 1) &&
	    (fixed_value != old_duration)) {
	    NXBeep();
	    goto end;
	}

	/*  IF FIXED SE INTERVAL, THEN DO SOME CHECKS  */
	if (!currentSEIntervalProp) {
	    int max_value = 0;
	    int interval_change;

	    /*  DETERMINE MAXIMUM ALLOWED VALUE  */
	    current_interval_ptr = currentSEIntervalPtr->sub_intervalHead;
	    for (i = 0; i < currentSEIntervalPtr->number_of_sub_intervals; i++) {
		max_value += current_interval_ptr->duration.ival;
		current_interval_ptr = current_interval_ptr->next;
	    }
	    max_value -=
		((currentSEIntervalPtr->number_of_sub_intervals - 1) * sample_value);

	    /*  MAKE SURE DURATION DOES NOT EXCEED MAXIMUM  */
	    if (fixed_value > max_value) {
		NXBeep();
		fixed_value = max_value;
	    }

	    /*  CALCULATE CHANGE OF INTERVAL SIZE  */
	    interval_change = fixed_value - old_duration;

	    /*  DISTRIBUTE CHANGE OF INTERVAL SIZE FIRST TO RIGHT, THEN LEFT  */
	    current_interval_ptr = intervalPtr->next;
	    i = 0;
	    while ((interval_change != 0) && (current_interval_ptr != NULL)) {
		int old_interval_duration;
		
		i++;
		old_interval_duration = current_interval_ptr->duration.ival;
		current_interval_ptr->duration.ival -= interval_change;
		if (current_interval_ptr->duration.ival < sample_value)
		    current_interval_ptr->duration.ival = sample_value;
		/*  RESET INTERVAL BOX FOR CHANGED INTERVAL  */
		[self subIntervalReset:SIB_reset_button[interval_number+i]];
		interval_change -= 
		    (old_interval_duration - current_interval_ptr->duration.ival);
		current_interval_ptr = current_interval_ptr->next;
	    }
	    
	    current_interval_ptr = intervalPtr->previous;
	    i = 0;
	    while ((interval_change != 0) && (current_interval_ptr != NULL)) {
		int old_interval_duration;
		
		i++;
		old_interval_duration = current_interval_ptr->duration.ival;
		current_interval_ptr->duration.ival -= interval_change;
		if (current_interval_ptr->duration.ival < sample_value)
		    current_interval_ptr->duration.ival = sample_value;
		/*  RESET INTERVAL BOX FOR CHANGED INTERVAL  */
		[self subIntervalReset:SIB_reset_button[interval_number-i]];
		interval_change -= 
		    (old_interval_duration - current_interval_ptr->duration.ival);
		current_interval_ptr = current_interval_ptr->previous;
	    }
	}
	/*  SET THE DURATION IN LIST  */
	intervalPtr->duration.ival = fixed_value;
    }
    /*  PROPORTIONAL INTERVAL  */
    else {
	int i, number_of_p_intervals = 0;
	float new_proportion, other_proportion_min, proportion_ceiling;
	float old_proportion, proportion_change;

	/*  GET DESIRED PROPORTION  */
	new_proportion = [SIB_form[interval_number] floatValueAt:0] / 100.0;

	/*  IF THE ONLY PROPORTIONAL INTERVAL, THEN SET TO 100%  */
	current_interval_ptr = currentSEIntervalPtr->sub_intervalHead;
	for (i = 0; i < currentSEIntervalPtr->number_of_sub_intervals; i++) {
	    if (current_interval_ptr->proportional)
		number_of_p_intervals++;
	    current_interval_ptr = current_interval_ptr->next;
	}
	if (number_of_p_intervals == 1)
	    new_proportion = 1.0;

	/*  MAKE SURE THE PROPORTION IS NOT BELOW MINIMUM  */
	new_proportion = (new_proportion < PROPORTION_MIN) ? PROPORTION_MIN : new_proportion;
	/*  LIMIT PROPORTIONAL INTERVAL SO THAT ALL OTHER PROPORTIONAL
	    INTERVALS NEVER FALL BELOW THE MINIMUM  */
	other_proportion_min = (float)(number_of_p_intervals-1) * PROPORTION_MIN;
	proportion_ceiling = 1.0 - other_proportion_min;
	new_proportion =
	    (new_proportion > proportion_ceiling) ? proportion_ceiling : new_proportion;
	    
        /*  GET OLD INTERVAL PROPORTION  */
	old_proportion = intervalPtr->duration.fval;
	/*  CALCULATE CHANGE OF INTERVAL SIZE  */
	proportion_change = new_proportion - old_proportion;

	/*  SET THE CURRENT INTERVAL TO LIMITED PROPORTION  */
	intervalPtr->duration.fval = new_proportion;

	/*  DISTRIBUTE CHANGE OF INTERVAL SIZE FIRST TO RIGHT, THEN LEFT  */
	current_interval_ptr = intervalPtr->next;
	i = 0;
	while ((proportion_change != 0.0) && (current_interval_ptr != NULL)) {
	    float old_interval_proportion;

	    i++;
	    if (current_interval_ptr->proportional) {
		old_interval_proportion = current_interval_ptr->duration.fval;
		current_interval_ptr->duration.fval -= proportion_change;
		if (current_interval_ptr->duration.fval < PROPORTION_MIN)
		    current_interval_ptr->duration.fval = PROPORTION_MIN;
	        /*  RESET INTERVAL BOX FOR CHANGED INTERVAL  */
	        [self subIntervalReset:SIB_reset_button[interval_number+i]];
		proportion_change -= 
		    (old_interval_proportion - current_interval_ptr->duration.fval);
	    }
		current_interval_ptr = current_interval_ptr->next;
	}

	current_interval_ptr = intervalPtr->previous;
	i = 0;
	while ((proportion_change != 0.0) && (current_interval_ptr != NULL)) {
	    float old_interval_proportion;

	    i++;
	    if (current_interval_ptr->proportional) {
		old_interval_proportion = current_interval_ptr->duration.fval;
		current_interval_ptr->duration.fval -= proportion_change;
		if (current_interval_ptr->duration.fval < PROPORTION_MIN)
		    current_interval_ptr->duration.fval = PROPORTION_MIN;
	        /*  RESET INTERVAL BOX FOR CHANGED INTERVAL  */
	        [self subIntervalReset:SIB_reset_button[interval_number-i]];
		proportion_change -= 
		    (old_interval_proportion - current_interval_ptr->duration.fval);
	    }
	    current_interval_ptr = current_interval_ptr->previous;
	}
    }

    end:
    /*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
    [self subIntervalReset:SIB_reset_button[interval_number]];

    /*  DISPLAY CURRENT SPECIAL EVENT  */
    /*  FIND IF REGRESSION  */
    current_t_interval_ptr = currentSpecifierPtr->t_intervalHead;
    for (i = 1; i < specialEventSubInterval; i++)
	current_t_interval_ptr = current_t_interval_ptr->next;
    /*  DISPLAY CHANGED GRAPH  */
    [specialEventView zoomInDisplay:currentSpecifierPtr:currentSEPtr:
                                    currentSEIntervalPtr:
                                    current_t_interval_ptr->regression];
    
    return self;
}

- subSwitch1Hit:sender
{
    int interval_number, nint(), i;
    sub_intervalPtr intervalPtr, current_interval_ptr;
    t_intervalPtr current_t_interval_ptr;

    /*  GET INTERVAL NUMBER FROM SENDER  */
    interval_number = [sender tag];

    /*  GET PROPER SUB-INTERVAL POINTER  */
    intervalPtr = currentSEIntervalPtr->sub_intervalHead;
    for (i = 0; i < interval_number; i++)
	intervalPtr = intervalPtr->next;

    /*  SET LENGTH  */
    /*  FIXED TO PROPORTIONAL  */
    if (!intervalPtr->proportional && ([sender selectedRow] == 0)) {
	sub_intervalPtr forward_interval_ptr = NULL, backward_interval_ptr = NULL;
	int index;
	int forward_index = 1000000;
	int backward_index = 1000000;

	/*  SET FORM TO SHOW PERCENTAGE  */
	[[SIB_text[interval_number] cellAt:PROP:0] setStringValue:"%"];

	/*  ROB 1/2 OF DURATION FROM NEAREST PROPORTIONAL INTERVAL  */
	/*  FIND NEAREST FORWARD PROPORTIONAL INTERVAL  */
	index = 0;
	current_interval_ptr = intervalPtr;
	while (current_interval_ptr->next != NULL) {
	    current_interval_ptr = current_interval_ptr->next;
	    index++;
	    if (current_interval_ptr->proportional) {
		forward_index = index;
		forward_interval_ptr = current_interval_ptr;
		break;
	    }
	}

	/*  FIND NEAREST BACKWARD PROPORTIONAL INTERVAL  */
	index = 0;
	current_interval_ptr = intervalPtr;
	while (current_interval_ptr->previous != NULL) {
	    current_interval_ptr = current_interval_ptr->previous;
	    index++;
	    if (current_interval_ptr->proportional) {
		backward_index = index;
		backward_interval_ptr = current_interval_ptr;
		break;
	    }
	}

        /*  CHOOSE THE NEAREST PROPORTIONAL INTERVAL, IF TIED, CHOOSE RIGHT ONE  */
	if (forward_index <= backward_index) {
	    current_interval_ptr = forward_interval_ptr;
	    index = forward_index;
	}
	else {
	    current_interval_ptr = backward_interval_ptr;
	    index = -backward_index;
	}

	/*  CUT THAT PROPORTIONAL INTERVAL'S DURATION IN HALF  */
	current_interval_ptr->duration.fval *= 0.5;

	/*  RESET THE INTERVAL BOX OF CHANGED INTERVAL  */
	[self subIntervalReset:SIB_reset_button[interval_number+index]];

	/*  SET PRESENT INTERVAL TO SAME VALUE AS ALTERED INTERVAL  */
	intervalPtr->duration.fval = current_interval_ptr->duration.fval;

	/*  SET PRESENT INTERVAL TO PROPORTIONAL  */
	intervalPtr->proportional = YES;

    	/*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
    	[self subIntervalReset:SIB_reset_button[interval_number]];

	/*  DISPLAY CURRENT SPECIAL EVENT  */
	/*  FIND IF REGRESSION  */
	current_t_interval_ptr = currentSpecifierPtr->t_intervalHead;
	for (i = 1; i < specialEventSubInterval; i++)
	    current_t_interval_ptr = current_t_interval_ptr->next;
	/*  DISPLAY CHANGED GRAPH  */
	[specialEventView zoomInDisplay:currentSpecifierPtr:currentSEPtr:
                                        currentSEIntervalPtr:
	                                current_t_interval_ptr->regression];

    }
    /*  PROPORTIONAL TO FIXED  */
    else if (intervalPtr->proportional && ([sender selectedRow] == 1)) {
	int number_of_p_intervals, i, done;
	float old_proportion;

	/*  MUST BE AT LEAST ONE PROPORTIONAL SUB INTERVAL  */
	current_interval_ptr = currentSEIntervalPtr->sub_intervalHead;
	number_of_p_intervals = 0;
	for (i = 0; i < currentSEIntervalPtr->number_of_sub_intervals; i++) {
	    if (current_interval_ptr->proportional)
		number_of_p_intervals++;
	    current_interval_ptr = current_interval_ptr->next;
	}
	if (number_of_p_intervals <= 1) {
	    NXBeep();
	    NXRunAlertPanel("Illegal",
		"There must be at least one proportional sub-interval.",
	        "OK", NULL, NULL);
	    /*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
    	    [self subIntervalReset:SIB_reset_button[interval_number]];
	    return self;
	}

	/*  GET OLD PROPORTION  */
	old_proportion = intervalPtr->duration.fval;

	/*  SET FORM TO SHOW MILLISECONDS  */
	[[SIB_text[interval_number] cellAt:PROP:0] setStringValue:"ms"];

	/*  SET THE DURATION IN LIST TO DEFAULT  */
	/*  default should be multiple of sample size  */
	intervalPtr->duration.ival = FIXED_DURATION_DEF;

	/*  SET PRESENT INTERVAL TO FIXED  */
	intervalPtr->proportional = NO;

	/*  DISTRIBUTE OLD PROPORTION TO RIGHT, UNLESS LAST PROPORTIONAL INTERVAL  */
	done = NO; i = 0;
	current_interval_ptr = intervalPtr->next;
	while (!done && (current_interval_ptr != NULL)) {
	     i++;
	     if (current_interval_ptr->proportional) {
		(current_interval_ptr->duration.fval) += old_proportion;
		/*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
	    	[self subIntervalReset:SIB_reset_button[interval_number+i]];
		done = YES;
	     }
	     current_interval_ptr = current_interval_ptr->next;
	}
	i = 0;
	current_interval_ptr = intervalPtr->previous;
	while (!done && (current_interval_ptr != NULL)) {
	     i++;
	     if (current_interval_ptr->proportional) {
		(current_interval_ptr->duration.fval) += old_proportion;
		/*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
	    	[self subIntervalReset:SIB_reset_button[interval_number-i]];
		done = YES;
	     }
	     current_interval_ptr = current_interval_ptr->previous;
	}

    	/*  DO RESET TO MAKE INTERVAL BOX LOOK STANDARD  */
    	[self subIntervalReset:SIB_reset_button[interval_number]];

	/*  DISPLAY CURRENT SPECIAL EVENT  */
	/*  FIND IF REGRESSION  */
	current_t_interval_ptr = currentSpecifierPtr->t_intervalHead;
	for (i = 1; i < specialEventSubInterval; i++)
	    current_t_interval_ptr = current_t_interval_ptr->next;
	/*  DISPLAY CHANGED GRAPH  */
	[specialEventView zoomInDisplay:currentSpecifierPtr:currentSEPtr:
                                        currentSEIntervalPtr:
	                                current_t_interval_ptr->regression];

    }

    return self;
}



- splitSubInterval:sender
{
    /*  PUT CURSOR IN FIRST FIELD  */
    [splitSubIntervalForm selectText:self];

    /*  PUT PANEL IN PROPER RELATION TO TEMPLATE WINDOW  */
    [seProfileWindow getFrame:(NXRect *)&r];
    [splitSubIntervalPanel moveTo:(NXCoord)r.origin.x+SPLIT_S_INTERVAL_X_OFFSET
			 :(NXCoord)r.origin.y+SPLIT_S_INTERVAL_Y_OFFSET];

    /*  MAKE PANEL VISIBLE  */
    [splitSubIntervalPanel makeKeyAndOrderFront:self];

    /*  MAKE SURE PANEL IS MODAL  */
    [NXApp runModalFor:splitSubIntervalPanel];
    return self;
}



- deleteSubInterval:sender;
{
    /*  PUT CURSOR IN FIRST FIELD  */
    [deleteSubIntervalForm selectText:self];

    /*  PUT PANEL IN PROPER RELATION TO TEMPLATE WINDOW  */
    [seProfileWindow getFrame:(NXRect *)&r];
    [deleteSubIntervalPanel moveTo:(NXCoord)r.origin.x+DELETE_S_INTERVAL_X_OFFSET
			 :(NXCoord)r.origin.y+DELETE_S_INTERVAL_Y_OFFSET];

    /*  MAKE PANEL VISIBLE  */
    [deleteSubIntervalPanel makeKeyAndOrderFront:self];

    /*  MAKE SURE PANEL IS MODAL  */
    [NXApp runModalFor:deleteSubIntervalPanel];
    return self;
}



- splitSubIntervalCancel:sender;
{
    /*  CLOSE THE PANEL  */
    [splitSubIntervalPanel close];
    [NXApp stopModal];
    return self;
}



- splitSubIntervalOK:sender;
{
    int i;
    int split_interval, split_interval_proportional;
    sub_intervalPtr current_interval_ptr = NULL, split_interval_ptr = NULL;
    float split_interval_rise = 0.0, excess = 0.0;
    float p_split_interval_rise = 0.0;
    union _split_interval_duration {
	int ival;
	float fval;
    } split_interval_duration;
    union _p_split_interval_duration {
	int ival;
	float fval;
    } p_split_interval_duration;


    /*  ALLOW ONLY MAXIMUM NUMBER OF INTERVALS  */
    if (currentSEIntervalPtr->number_of_sub_intervals >= INTERVALS_MAX) {
	NXBeep();
	NXRunAlertPanel("Illegal",
	    "Only a maximum of %-d sub-intervals allowed.",
	    "OK", NULL, NULL, INTERVALS_MAX);
	/*  PUT CURSOR AT FIELD  */
	[splitSubIntervalForm selectText:self];
	return self;
    }

    /*  GET INTERVAL TO SPLIT, MAKE SURE IT IS IN RANGE  */
    split_interval = [splitSubIntervalForm intValue];
    if ((split_interval < 1) ||
		(split_interval > currentSEIntervalPtr->number_of_sub_intervals)) {
	NXBeep();
	NXRunAlertPanel("Illegal",
	    "No such sub-interval.","OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[splitSubIntervalForm selectText:self];
	return self;
    }

    /*  GET THE SPLIT INTERVAL POINTER  */
    split_interval_ptr = currentSEIntervalPtr->sub_intervalHead;
    for (i = 1; i < split_interval; i++)
	split_interval_ptr = split_interval_ptr->next;

    /*  GET THE SPLIT INTERVAL'S RISE, AS WELL AS THE PREVIOUS INTERVALS RISE  */
    if (split_interval_ptr->previous == NULL) {
	if (currentSEIntervalPtr->previous != NULL) {
	    current_interval_ptr = currentSEIntervalPtr->previous->sub_intervalHead;
	    for (i = 1; i < currentSEIntervalPtr->previous->number_of_sub_intervals; i++)
		current_interval_ptr = current_interval_ptr->next;
	    p_split_interval_rise = current_interval_ptr->rise;
	}
	else
	    p_split_interval_rise = 0.0;
    }
    else {
	p_split_interval_rise = split_interval_ptr->previous->rise;
    }
    split_interval_rise = split_interval_ptr->rise;



    /*  DETERMINE WHETHER PROPORTIONAL OR NOT  */
    split_interval_proportional = split_interval_ptr->proportional;

    /*  DETERMINE SPLIT INTERVAL DURATION, DIVIDE IN HALF FOR FURTHER
	DISTRIBUTION, KEEPING IN MIND THE MINIMUM VALUES ALLOWED  */
    if (split_interval_proportional) {
	excess = 0.0;
	split_interval_duration.fval = split_interval_ptr->duration.fval / 2.0;
	if (split_interval_duration.fval < PROPORTION_MIN) {
	    excess = (PROPORTION_MIN - split_interval_duration.fval) * 2.0;
	    split_interval_duration.fval = PROPORTION_MIN;
	}
    }
    else if (!split_interval_proportional) {
	int sample_value, nint();
        sample_value = [template sampleValue];
	/*  MAKE SURE INTERVAL IS LARGE ENOUGH TO BE SPLIT  */
	if (split_interval_ptr->duration.ival < (2 * sample_value)) {
	    NXBeep();
	    NXRunAlertPanel("Illegal",
			    "This sub-interval is too small to be split.",
			    "OK", NULL, NULL);
	    /*  PUT CURSOR AT FIELD  */
	    [splitSubIntervalForm selectText:self];
	    return self;
	}
	/*  CALCULATE SIZE OF BOTH INTERVALS  */
	/*  MAKE SURE VALUE IS MULTIPLE OF SAMPLE VALUE  */
	split_interval_duration.ival = 
	    nint((float)(split_interval_ptr->duration.ival / 2.0) /
		  (float)sample_value) * sample_value;
	if (split_interval_duration.ival < sample_value) {
	    split_interval_duration.ival = sample_value;
	}
	p_split_interval_duration.ival = 
	    split_interval_ptr->duration.ival - split_interval_duration.ival;
    }

    /*  DO PROPORTIONAL INTERVAL SPLIT  */
    if (split_interval_proportional) {
	sub_intervalPtr new_interval_ptr, temp_interval_ptr, new_sub_interval();
	/*  SET SPLIT INTERVAL TO NEW RISE AND DURATION  */
	split_interval_ptr->rise = (p_split_interval_rise + split_interval_rise)/2.0;
	split_interval_ptr->duration.fval = split_interval_duration.fval;
	/*  APPLY EXCESS PROPORTIONAL VALUE FIRST TO RIGHT, THEN LEFT  */
	if (excess > 0.0) {
	    /*  TO RIGHT  */
	    current_interval_ptr = split_interval_ptr->next;
	    while ((excess > 0.0) && (current_interval_ptr != NULL)) {
	        if (current_interval_ptr->proportional) {
		    float length;
		    length = current_interval_ptr->duration.fval - excess;
		    length = (length < PROPORTION_MIN) ? PROPORTION_MIN : length;
		    excess -= (current_interval_ptr->duration.fval - length);
		    current_interval_ptr->duration.fval = length;
		}
		current_interval_ptr = current_interval_ptr->next;
	    }
	    /*  TO LEFT  */
	    current_interval_ptr = split_interval_ptr->previous;
	    while ((excess > 0.0) && (current_interval_ptr != NULL)) {
	        if (current_interval_ptr->proportional) {
		    float length;
		    length = current_interval_ptr->duration.fval - excess;
		    length = (length < PROPORTION_MIN) ? PROPORTION_MIN : length;
		    excess -= (current_interval_ptr->duration.fval - length);
		    current_interval_ptr->duration.fval = length;
		}
		current_interval_ptr = current_interval_ptr->previous;
	    }
	}
	/*  CREATE NEW INTERVAL  */
	new_interval_ptr = new_sub_interval();
	/*  SET VALUES OF NEW INTERVAL  */
	new_interval_ptr->rise = split_interval_rise;
	new_interval_ptr->duration.fval = split_interval_duration.fval;
	new_interval_ptr->proportional = split_interval_proportional;
	/*  INSERT INTO LIST;  SET FORWARD POINTERS  */
	temp_interval_ptr = split_interval_ptr->next;
	split_interval_ptr->next = new_interval_ptr;
	new_interval_ptr->next = temp_interval_ptr;
	/*  SET BACKWARDS POINTERS  */
	if (new_interval_ptr->next != NULL)
	    new_interval_ptr->next->previous = new_interval_ptr;
	new_interval_ptr->previous = split_interval_ptr;
	/*  UPDATE NUMBER OF INTERVALS FOR TRANSITION SPECIFIER  */
	currentSEIntervalPtr->number_of_sub_intervals++;
    }
    /*  DO FIXED INTERVAL SPLIT  */
    else if (!split_interval_proportional) {
	sub_intervalPtr new_interval_ptr, temp_interval_ptr, new_sub_interval();
	/*  SET SPLIT INTERVAL TO NEW RISE AND DURATION  */
	split_interval_ptr->rise = p_split_interval_rise +
	    ((split_interval_rise - p_split_interval_rise) * 
	    ((float)p_split_interval_duration.ival/(float)split_interval_ptr->duration.ival));
	split_interval_ptr->duration.ival = p_split_interval_duration.ival;
	/*  CREATE NEW INTERVAL  */
	new_interval_ptr = new_sub_interval();
	/*  SET VALUES OF NEW INTERVAL  */
	new_interval_ptr->rise = split_interval_rise;
	new_interval_ptr->duration.ival = split_interval_duration.ival;
	new_interval_ptr->proportional = split_interval_proportional;
	/*  INSERT INTO LIST;  SET FORWARD POINTERS  */
	temp_interval_ptr = split_interval_ptr->next;
	split_interval_ptr->next = new_interval_ptr;
	new_interval_ptr->next = temp_interval_ptr;
	/*  SET BACKWARDS POINTERS  */
	if (new_interval_ptr->next != NULL)
	    new_interval_ptr->next->previous = new_interval_ptr;
	new_interval_ptr->previous = split_interval_ptr;
	/*  UPDATE NUMBER OF INTERVALS FOR TRANSITION SPECIFIER  */
	currentSEIntervalPtr->number_of_sub_intervals++;
    }

    /*  MAKE SURE THE CURRENT TRANSITION IS DISPLAYED  */
    [self displaySpecialEvent:specialEventStatus:specialEventSubInterval];
    [self displaySubIntervalBoxes];

    /*  CLOSE THE PANEL  */
    [splitSubIntervalPanel close];
    [NXApp stopModal];
    return self;
}



- deleteSubIntervalCancel:sender;
{
    /*  CLOSE THE PANEL  */
    [deleteSubIntervalPanel close];
    [NXApp stopModal];
    return self;
}



- deleteSubIntervalOK:sender;
{
    int i, delete_interval, proportional_intervals = 0;
    sub_intervalPtr current_interval_ptr = NULL, delete_interval_ptr = NULL;

    /*  GET INTERVAL TO DELETE, MAKE SURE IT IS IN RANGE  */
    delete_interval = [deleteSubIntervalForm intValue];
    if ((delete_interval < 1) ||
		(delete_interval > currentSEIntervalPtr->number_of_sub_intervals)) {
	NXBeep();
	NXRunAlertPanel("Illegal",
	    "No such sub-interval.","OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[deleteSubIntervalForm selectText:self];
	return self;
    }

    /*  WHEN DELETING, MAKE SURE THERE ARE 2 OR MORE INTERVALS  */
    if (currentSEIntervalPtr->number_of_sub_intervals < 2) {
	NXBeep();
	NXRunAlertPanel("Illegal",
	    "There must be at least one interval remaining.",
	    "OK", NULL, NULL);
	/*  PUT CURSOR AT FIELD  */
	[deleteSubIntervalForm selectText:self];
	return self;
    }

    /*  MAKE SURE THAT AT LEAST ONE PROPORTIONAL INTERVAL
	REMAINS WHEN THE WHOLE SEGMENT IS PROPORTIONAL  */
    if (currentSEIntervalProp) {
	current_interval_ptr = currentSEIntervalPtr->sub_intervalHead;
	proportional_intervals = 0;
	for (i = 0; i < currentSEIntervalPtr->number_of_sub_intervals; i++) {
	    if ((current_interval_ptr->proportional)  && (i != delete_interval-1))
		proportional_intervals++;
	    current_interval_ptr = current_interval_ptr->next;
	}
	if (proportional_intervals < 1) {
	    NXBeep();
	    NXRunAlertPanel("Illegal",
		"There must be at least one proportional\ninterval remaining after deletion.",
		"OK", NULL, NULL);
	    /*  PUT CURSOR AT FIELD  */
	    [deleteSubIntervalForm selectText:self];
	    return self;
	}
    }

    /*  FIND POINTER FOR DELETE INTERVAL, AND WHETHER FIXED OR PROPORTIONAL  */
    current_interval_ptr = currentSEIntervalPtr->sub_intervalHead;
    for (i = 0; i < currentSEIntervalPtr->number_of_sub_intervals; i++) {
	if (i == delete_interval-1) {
	    delete_interval_ptr = current_interval_ptr;
	    break;
	}
	current_interval_ptr = current_interval_ptr->next;
    }

    /*  ACTUAL DELETION FOR FIXED INTERVAL  */
    if (!(delete_interval_ptr->proportional)) {
	/*  TAKE INTERVAL OUT OF LIST BY ADJUSTING ADJACENT POINTERS  */
	if (delete_interval == 1) {
	    currentSEIntervalPtr->sub_intervalHead = delete_interval_ptr->next;
	    delete_interval_ptr->next->previous = NULL;
	    if (!currentSEIntervalProp) {
		currentSEIntervalPtr->sub_intervalHead->duration.ival += 
		    delete_interval_ptr->duration.ival;
	    }
	    /*  IF ANCHOR POINT, THEN PREVIOUS INTERVAL MUST HAVE RISE OF ZERO  */
	    if ( (currentSEIntervalPtr->next == NULL) && (delete_interval_ptr->next == NULL) )
		currentSEIntervalPtr->sub_intervalHead->rise = 0.0;
	}
	else {
	    delete_interval_ptr->previous->next = delete_interval_ptr->next;
	    if (delete_interval_ptr->next != NULL) {
		delete_interval_ptr->next->previous = delete_interval_ptr->previous;
	    }
	    if (!currentSEIntervalProp) {
		delete_interval_ptr->previous->duration.ival +=
		    delete_interval_ptr->duration.ival;
	    }
	    /*  IF ANCHOR POINT, THEN PREVIOUS INTERVAL MUST HAVE RISE OF ZERO  */
	    if ( (currentSEIntervalPtr->next == NULL) && (delete_interval_ptr->next == NULL) )
		delete_interval_ptr->previous->rise = 0.0;
	}
	currentSEIntervalPtr->number_of_sub_intervals--;

	/*  FREE MEMORY OF DELETE INTERVAL  */
	free(delete_interval_ptr);
    }
    /*  ACTUAL DELETION FOR PROPORTIONAL INTERVAL  */
    else if (delete_interval_ptr->proportional) {
	sub_intervalPtr forward_interval_ptr = NULL, backward_interval_ptr = NULL;
	int index;
	int forward_index = 1000000;
	int backward_index = 1000000;

	/*  FIND NEAREST FORWARD PROPORTIONAL INTERVAL  */
	index = 0;
	current_interval_ptr = delete_interval_ptr;
	while (current_interval_ptr->next != NULL) {
	    current_interval_ptr = current_interval_ptr->next;
	    index++;
	    if (current_interval_ptr->proportional) {
		forward_index = index;
		forward_interval_ptr = current_interval_ptr;
		break;
	    }
	}

	/*  FIND NEAREST BACKWARD PROPORTIONAL INTERVAL  */
	index = 0;
	current_interval_ptr = delete_interval_ptr;
	while (current_interval_ptr->previous != NULL) {
	    current_interval_ptr = current_interval_ptr->previous;
	    index++;
	    if (current_interval_ptr->proportional) {
		backward_index = index;
		backward_interval_ptr = current_interval_ptr;
		break;
	    }
	}

        /*  CHOOSE THE NEAREST PROPORITONAL INTERVAL, IF TIED, CHOOSE LEFT ONE  */
	if (backward_index <= forward_index) {
	    current_interval_ptr = backward_interval_ptr;
	}
	else {
	    current_interval_ptr = forward_interval_ptr;
	}

        /*  ADD THE PROPORTIONAL LENGTH OF DELETE INTERVAL TO THE CHOSEN INTERVAL  */
	current_interval_ptr->duration.fval += delete_interval_ptr->duration.fval;

	/*  TAKE INTERVAL OUT OF LIST BY ADJUSTING ADJACENT POINTERS  */
	if (delete_interval == 1) {
	    currentSEIntervalPtr->sub_intervalHead = delete_interval_ptr->next;
	    delete_interval_ptr->next->previous = NULL;
	    /*  IF ANCHOR POINT, THEN PREVIOUS INTERVAL MUST HAVE RISE OF ZERO  */
	    if ( (currentSEIntervalPtr->next == NULL) && (delete_interval_ptr->next == NULL) )
		currentSEIntervalPtr->sub_intervalHead->rise = 0.0;
	}
	else {
	    delete_interval_ptr->previous->next = delete_interval_ptr->next;
	    if (delete_interval_ptr->next != NULL) {
		delete_interval_ptr->next->previous = delete_interval_ptr->previous;
	    }
	    /*  IF ANCHOR POINT, THEN PREVIOUS INTERVAL MUST HAVE RISE OF ZERO  */
	    if ( (currentSEIntervalPtr->next == NULL) && (delete_interval_ptr->next == NULL) )
		delete_interval_ptr->previous->rise = 0.0;
	}
	currentSEIntervalPtr->number_of_sub_intervals--;
	
	/*  FREE MEMORY OF DELETE INTERVAL  */
	free(delete_interval_ptr);
    }

    /*  MAKE SURE THE CURRENT TRANSITION IS DISPLAYED  */
    [self displaySpecialEvent:specialEventStatus:specialEventSubInterval];
    [self displaySubIntervalBoxes];

    /*  CLOSE THE PANEL  */
    [deleteSubIntervalPanel close];
    [NXApp stopModal];
    return self;
}




- durSwitchHit:sender
{
    int rule_chosen;

    /*  GET RULE CHOSEN  */
    rule_chosen = [sender selectedRow];

    /*  STORE DURATION RULE CHOSEN  */
    currentSpecifierPtr->duration.rule = rule_chosen;

    /*  IF DURATION FIXED, THEN ENABLE LENGTH FIELD  */
    if ((rule_chosen == DUR_RULE_FIXED) || (rule_chosen == DUR_RULE_T_MIDDLE)) {
	[durLength setEnabled:1];
	[durLength setIntValue:currentSpecifierPtr->duration.fixed_length];
	[durLength selectText:self];
    }
    else {
	[durLength setStringValue:""];
	[durLength setEnabled:0];
    }

    /*  IF CHOSEN RULE IS NOT A FORMULA TYPE, THEN MAKE ADJUSTMENTS  */
    if (rule_chosen < DUR_RULE_NORMAL || rule_chosen > DUR_RULE_T_MIDDLE) {
	/*  IF ARBITRARY SPLIT MODE, THEN DISABLE SPLIT MODE BUTTON  */
	if (currentSpecifierPtr->split_mode == SPLIT_MODE_ARBITRARY) {
	    [splitModeButton setEnabled:0];
	}
	/*  FORMULA SPLIT MODE, THEN RESET TO DEFAULT, RESET BUTTON TO
	    ARBITRARY, DISABLE BUTTON  */
	else {
	    [splitModeButton setTitle:"Arbitrary Split"];
	    [splitModeButton setEnabled:0];
	}
    }
    /*  ELSE, ENABLE SPLIT MODE BUTTON  */
    else {
	[splitModeButton setEnabled:1];
    }

    return self;
}



- durLengthEntered:sender
{
    int value;

    /*  GET VALUE ENTERED  */
    value = [sender intValue];

    /*  MAKE SURE VALUE IS A POSITIVE MULTIPLE OF SAMPLE VALUE  */
    if ( ((value % [template sampleValue]) != 0) || (value <= 0)) {
	NXBeep();
	NXRunAlertPanel("Illegal",
		"Duration must be a positive\nmultiple of the sample size (%-d).", 
	        "OK", NULL, NULL, [template sampleValue]);
	[sender selectText:self];
	return self;
    }

    /*  STORE VALUE  */
    currentSpecifierPtr->duration.fixed_length = value;
    return self;
}



- propagateModeChange:(int)t_interval
{
    int i, j;
    specialEventStructPtr current_SEPtr;
    se_intervalPtr new_se_interval();
    sub_intervalPtr new_sub_interval();
    void free_sub_interval();
    sub_intervalPtr current_sub_interval_ptr, temp_sub_interval_ptr;
    se_intervalPtr current_se_interval_ptr;
    t_intervalPtr current_t_interval_ptr;

    /*  FOR EACH SPECIAL EVENT, FIND SE_INTERVAL,
	DELETE ALL SUB-INTERVALS, THEN SET ONE DEFAULT SUB-INTERVAL  */
    current_SEPtr = currentSpecifierPtr->specialEventHead;
    for (i = 0; i < currentSpecifierPtr->number_of_special_events; i++) {

	/*  FIND CORRESPONDING SE_INTERVAL, AND T_INTERVAL  */
	current_se_interval_ptr = current_SEPtr->se_intervalHead;
	current_t_interval_ptr = currentSpecifierPtr->t_intervalHead;
	for (j = 0; j < t_interval; j++) {
	    current_se_interval_ptr = current_se_interval_ptr->next;
	    current_t_interval_ptr = current_t_interval_ptr->next;
	}

	/*  DELETE ALL SUB-INTERVALS  */
	current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
	for (j = 0; j < current_se_interval_ptr->number_of_sub_intervals; j++) {
	    temp_sub_interval_ptr = current_sub_interval_ptr->next;
	    free_sub_interval(current_sub_interval_ptr);
	    current_sub_interval_ptr = temp_sub_interval_ptr;
	}

	/*  CREATE ONE SUBINTERVAL FOR EACH SPECIAL EVENT INTERVAL, INITIALIZE  */
	current_se_interval_ptr->sub_intervalHead = new_sub_interval();
	current_se_interval_ptr->sub_intervalHead->next = NULL;
	current_se_interval_ptr->sub_intervalHead->previous = NULL;
	current_se_interval_ptr->number_of_sub_intervals = 1;
	    
	/*  THE SUBINTERVAL WILL BE THE SAME AS THE TRANSITION INTERVAL  */
	current_se_interval_ptr->sub_intervalHead->proportional = 
	    current_t_interval_ptr->proportional;
	/*  IF ONLY ONE PROPORTIONAL INTERVAL, ITS LENGTH IS 100%  */
	if (current_se_interval_ptr->sub_intervalHead->proportional)
	    current_se_interval_ptr->sub_intervalHead->duration.fval = 1.0;
	/*  IF ONLY ONE ABSOLUTE VALUE INTERVAL, ITS LENGTH IS SAME AS T_INTERVAL  */
	else
	    current_se_interval_ptr->sub_intervalHead->duration.ival =
		current_t_interval_ptr->duration.ival;
	
	/*  DEFAULT RISE OF 0  */
	current_se_interval_ptr->sub_intervalHead->rise = 0.0;
	
	/*  UPDATE TO NEXT SPECIAL EVENT  */
	current_SEPtr = current_SEPtr->next;
    }

    /*  RE-DISPLAY SPECIAL EVENT, IF NECESSARY  */
    if (currentSpecifierPtr->number_of_special_events > 0)
	[self displaySpecialEvent:specialEventStatus:specialEventSubInterval];

    return self;
}



- propagateDeletion:(int)t_interval
{
    int i, j;
    specialEventStructPtr current_SEPtr;
    se_intervalPtr current_se_interval_ptr;
    void free_se_interval();

    /*  FOR EACH SPECIAL EVENT, FIND SE_INTERVAL,
	ADJUST LINKED LIST, THEN DELETE SE_INTERVAL ITSELF  */
    current_SEPtr = currentSpecifierPtr->specialEventHead;
    for (i = 0; i < currentSpecifierPtr->number_of_special_events; i++) {

	/*  FIND CORRESPONDING SE_INTERVAL  */
	current_se_interval_ptr = current_SEPtr->se_intervalHead;
	for (j = 1; j < t_interval; j++)
	    current_se_interval_ptr = current_se_interval_ptr->next;

	/*  ADJUST LINKED LIST  */
	if (t_interval == 1) {
	    current_SEPtr->se_intervalHead = current_se_interval_ptr->next;
	    current_se_interval_ptr->next->previous = NULL;
	}
	else {
	    current_se_interval_ptr->previous->next = current_se_interval_ptr->next;
	    if (current_se_interval_ptr->next != NULL)
		current_se_interval_ptr->next->previous = 
		    current_se_interval_ptr->previous;
	}

	/*  FREE THE SE_INTERVAL ITSELF  */
	free_se_interval(current_se_interval_ptr);

	/*  MAKE SURE VERY LAST SUB-INTERVAL IN THE LAST SE_INTERVAL HAS RISE OF 0  */
	current_se_interval_ptr = current_SEPtr->se_intervalHead;
	while (current_se_interval_ptr != NULL) {
	    if (current_se_interval_ptr->next == NULL) {
		sub_intervalPtr current_sub_interval_ptr;
		current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
		while (current_sub_interval_ptr != NULL) {
		    if (current_sub_interval_ptr->next == NULL) {
			current_sub_interval_ptr->rise = 0.0;
		    }
		    current_sub_interval_ptr = current_sub_interval_ptr->next;
		}
	    }
	    current_se_interval_ptr = current_se_interval_ptr->next;
	}

	/*  UPDATE TO NEXT SPECIAL EVENT  */
	current_SEPtr = current_SEPtr->next;
    }

    /*  RE-DISPLAY SPECIAL EVENT, IF NECESSARY  */
    if (currentSpecifierPtr->number_of_special_events > 0) {
	if (specialEventStatus == ZOOM_IN)
	    [self displaySpecialEvent:ZOOM_OUT:0];
	else
	    [self displaySpecialEvent:specialEventStatus:specialEventSubInterval];
    }

    return self;
}



- propagateSplit:(int)t_interval
{
    int i, j;
    specialEventStructPtr current_SEPtr;
    se_intervalPtr current_se_interval_ptr, new_se_interval_ptr;
    se_intervalPtr new_se_interval(), temp_se_interval_ptr;
    void free_se_interval();

    t_intervalPtr current_t_interval_ptr;

    sub_intervalPtr new_sub_interval();
    void free_sub_interval();
    sub_intervalPtr current_sub_interval_ptr, temp_sub_interval_ptr;


    /*  FOR EACH SPECIAL EVENT, FIND SE_INTERVAL, DELETE ALL SUB-INTERVALS,
	HAVE JUST ONE SUB-INTERVAL;  ADD ANOTHER SE_INTERVAL WITH ONE SUB-INTERVAL,
	ADJUST LINKED LIST  */
    current_SEPtr = currentSpecifierPtr->specialEventHead;
    for (i = 0; i < currentSpecifierPtr->number_of_special_events; i++) {

	/*  FIND CORRESPONDING SE_INTERVAL, AND T_INTERVAL  */
	current_se_interval_ptr = current_SEPtr->se_intervalHead;
	current_t_interval_ptr = currentSpecifierPtr->t_intervalHead;
	for (j = 1; j < t_interval; j++) {
	    current_se_interval_ptr = current_se_interval_ptr->next;
	    current_t_interval_ptr = current_t_interval_ptr->next;
	}

	/*  DELETE ALL SUB-INTERVALS IN CURRENT SE_INTERVAL */
	current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
	for (j = 0; j < current_se_interval_ptr->number_of_sub_intervals; j++) {
	    temp_sub_interval_ptr = current_sub_interval_ptr->next;
	    free_sub_interval(current_sub_interval_ptr);
	    current_sub_interval_ptr = temp_sub_interval_ptr;
	}

	/*  CREATE ONE SUBINTERVAL FOR CURRENT SPECIAL EVENT INTERVAL, INITIALIZE  */
	current_se_interval_ptr->sub_intervalHead = new_sub_interval();
	current_se_interval_ptr->sub_intervalHead->next = NULL;
	current_se_interval_ptr->sub_intervalHead->previous = NULL;
	current_se_interval_ptr->number_of_sub_intervals = 1;
	    
	/*  THE SUBINTERVAL WILL BE THE SAME AS THE TRANSITION INTERVAL  */
	current_se_interval_ptr->sub_intervalHead->proportional = 
	    current_t_interval_ptr->proportional;
	/*  IF ONLY ONE PROPORTIONAL INTERVAL, ITS LENGTH IS 100%  */
	if (current_se_interval_ptr->sub_intervalHead->proportional)
	    current_se_interval_ptr->sub_intervalHead->duration.fval = 1.0;
	/*  IF ONLY ONE ABSOLUTE VALUE INTERVAL, ITS LENGTH IS SAME AS T_INTERVAL  */
	else
	    current_se_interval_ptr->sub_intervalHead->duration.ival =
		current_t_interval_ptr->duration.ival;
	
	/*  DEFAULT RISE OF 0  */
	current_se_interval_ptr->sub_intervalHead->rise = 0.0;


	/*  CREATE A NEW SE_INTERVAL, TO CORRESPOND TO THE NEW SPLIT INTERVAL  */
	new_se_interval_ptr = new_se_interval();

	/*  CREATE ONE SUBINTERVAL FOR NEW SPECIAL EVENT INTERVAL, INITIALIZE  */
	new_se_interval_ptr->sub_intervalHead = new_sub_interval();
	new_se_interval_ptr->sub_intervalHead->next = NULL;
	new_se_interval_ptr->sub_intervalHead->previous = NULL;
	new_se_interval_ptr->number_of_sub_intervals = 1;
	    
	/*  THE SUBINTERVAL WILL BE THE SAME AS THE CORRESPONDING TRANSITION INTERVAL  */
	new_se_interval_ptr->sub_intervalHead->proportional = 
	    current_t_interval_ptr->next->proportional;
	/*  IF ONLY ONE PROPORTIONAL INTERVAL, ITS LENGTH IS 100%  */
	if (new_se_interval_ptr->sub_intervalHead->proportional)
	    new_se_interval_ptr->sub_intervalHead->duration.fval = 1.0;
	/*  IF ONLY ONE ABSOLUTE VALUE INTERVAL, ITS LENGTH IS SAME AS T_INTERVAL  */
	else
	    new_se_interval_ptr->sub_intervalHead->duration.ival =
		current_t_interval_ptr->next->duration.ival;
	
	/*  DEFAULT RISE OF 0  */
	new_se_interval_ptr->sub_intervalHead->rise = 0.0;


	/*  ADJUST LINKED LIST:  ADD NEW SE_INTERVAL AFTER CURRENT SE_INTERVAL  */
	/*  SET FORWARD POINTERS  */
	temp_se_interval_ptr = current_se_interval_ptr->next;
	current_se_interval_ptr->next = new_se_interval_ptr;
	new_se_interval_ptr->next = temp_se_interval_ptr;
	/*  SET BACKWARDS POINTERS  */
	if (new_se_interval_ptr->next != NULL)
	    new_se_interval_ptr->next->previous = new_se_interval_ptr;
	new_se_interval_ptr->previous = current_se_interval_ptr;


	/*  UPDATE TO NEXT SPECIAL EVENT  */
	current_SEPtr = current_SEPtr->next;
    }


    /*  RE-DISPLAY SPECIAL EVENT, IF NECESSARY  */
    if (currentSpecifierPtr->number_of_special_events > 0) {
	if (specialEventStatus == ZOOM_IN)
	    [self displaySpecialEvent:ZOOM_OUT:0];
	else
	    [self displaySpecialEvent:specialEventStatus:specialEventSubInterval];
    }

    return self;
}



- propagateLengthChange:(int)t_interval:(int)proportional:(int)old_value:(int)new_value
{
    /*  IF A FIXED INTERVAL (ONLY), THEN MAKE NECESSARY ADJUSTMENTS  */
    if (!proportional) {
        int delta;
	int i, j;
	specialEventStructPtr current_SEPtr;
	se_intervalPtr current_se_interval_ptr;
	sub_intervalPtr current_sub_interval_ptr;

        /*  CALCULATE DELTA VALUE  */
	delta = new_value - old_value;

        /*  IF LENGTHENED INTERVAL, ADD DELTA TO LAST SUB-INTERVAL  */
        if (delta > 0) {
	    /*  LOOP THROUGH EVERY SPECIAL EVENT  */
	    current_SEPtr = currentSpecifierPtr->specialEventHead;
	    for (i = 0; i < currentSpecifierPtr->number_of_special_events; i++) {
		
		/*  FIND CORRESPONDING SE_INTERVAL  */
		current_se_interval_ptr = current_SEPtr->se_intervalHead;
		for (j = 1; j < t_interval; j++)
		    current_se_interval_ptr = current_se_interval_ptr->next;

		/*  ADD DELTA TO LAST SUB-INTERVAL  */
		current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
		while (current_sub_interval_ptr != NULL) {
		    if (current_sub_interval_ptr->next == NULL) {
			current_sub_interval_ptr->duration.ival += delta;
		    }
		    current_sub_interval_ptr = current_sub_interval_ptr->next;
		}
		
		/*  UPDATE TO NEXT SPECIAL EVENT  */
		current_SEPtr = current_SEPtr->next;
	    }
        }
        /*  IF SHORTENED INTERVAL, MAKE ADJUSTMENTS  */
        else {
	    /*  LOOP THROUGH EVERY SPECIAL EVENT  */
	    current_SEPtr = currentSpecifierPtr->specialEventHead;
	    for (i = 0; i < currentSpecifierPtr->number_of_special_events; i++) {
		int min;

		/*  FIND CORRESPONDING SE_INTERVAL  */
		current_se_interval_ptr = current_SEPtr->se_intervalHead;
		for (j = 1; j < t_interval; j++)
		    current_se_interval_ptr = current_se_interval_ptr->next;

		/*  IF TOO MANY SUB-INTERVALS FOR NEW LENGTH, DELETE ALL
		    SUB-INTERVALS;  CREATE JUST ONE WITH LENGTH = NEW LENGTH  */
		min = current_se_interval_ptr->number_of_sub_intervals*[template sampleValue];

		if (new_value < min) {
		    sub_intervalPtr new_sub_interval();
		    void free_sub_interval();
		    sub_intervalPtr current_sub_interval_ptr, temp_sub_interval_ptr;

		    /*  DELETE ALL SUB-INTERVALS IN CURRENT SE_INTERVAL */
		    current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
		    for (j = 0; j < current_se_interval_ptr->number_of_sub_intervals; j++) {
			temp_sub_interval_ptr = current_sub_interval_ptr->next;
			free_sub_interval(current_sub_interval_ptr);
			current_sub_interval_ptr = temp_sub_interval_ptr;
		    }

		    /*  CREATE ONE SUBINTERVAL FOR CURRENT SPECIAL EVENT INTERVAL, INITIALIZE  */
		    current_se_interval_ptr->sub_intervalHead = new_sub_interval();
		    current_se_interval_ptr->sub_intervalHead->next = NULL;
		    current_se_interval_ptr->sub_intervalHead->previous = NULL;
		    current_se_interval_ptr->number_of_sub_intervals = 1;

		    /*  THE SUBINTERVAL WILL BE THE SAME AS THE TRANSITION INTERVAL  */
		    current_se_interval_ptr->sub_intervalHead->proportional = proportional;
		    current_se_interval_ptr->sub_intervalHead->duration.ival = new_value;

		    /*  DEFAULT RISE OF 0  */
		    current_se_interval_ptr->sub_intervalHead->rise = 0.0;
		}
		/*  ELSE, SHORTEN SUB-INTERVALS RIGHT TO LEFT, AS NEEDED  */
		else {
		    sub_intervalPtr current_sub_interval_ptr;
		    int sample_value = [template sampleValue];
		    int applied_delta = delta;

		    /*  FIND LAST SUB-INTERVAL  */
		    current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
		    for (j = 1; j < current_se_interval_ptr->number_of_sub_intervals; j++)
			current_sub_interval_ptr = current_sub_interval_ptr->next;

		    /*  APPLY DELTA VALUE RIGHT TO LEFT UNTIL NONE LEFT  */
		    while ((current_sub_interval_ptr != NULL) && (applied_delta < 0)) {
			int original_length = current_sub_interval_ptr->duration.ival;
			/*  SUBTRACT DELTA VALUE FROM DURATION  */
			current_sub_interval_ptr->duration.ival += applied_delta;
			/*  MAKE SURE DURATION DOES NOT GO BELOW MINIMUM  */
			if (current_sub_interval_ptr->duration.ival < sample_value)
			    current_sub_interval_ptr->duration.ival = sample_value;
			/*  ADJUST DELTA VALUE  */
			applied_delta += 
			    (original_length - current_sub_interval_ptr->duration.ival);
			/*  GO TO PREVIOUS SUB-INTERVAL  */
			current_sub_interval_ptr = current_sub_interval_ptr->previous;
		    }
		}

	        /*  UPDATE TO NEXT SPECIAL EVENT  */
		current_SEPtr = current_SEPtr->next;
	    }
	}
    }

    /*  RE-DISPLAY SPECIAL EVENT, IF NECESSARY  */
    if (currentSpecifierPtr->number_of_special_events > 0)
	[self displaySpecialEvent:specialEventStatus:specialEventSubInterval];

    return self;
}


- findRule:sender
{
    char phone1[SYMBOL_LENGTH_MAX+1], phone2[SYMBOL_LENGTH_MAX+1];
    specifierStructPtr specifier;
    char buffer[256];

    /*  GET SYMBOLS FROM FIELDS  */
    strcpy(phone1,[gRulePhone1Field stringValue]);
    strcpy(phone2,[gRulePhone2Field stringValue]);

    /*  CHECK TO MAKE SURE PHONE SYMBOL 1 IS IN TEMPLATE  */
    if (![template usedAsPhoneSymbol:phone1]) {
	NXBeep();
	NXRunAlertPanel("Undefined phone",
			"The phone:  %s\n is not defined in the Template.\n",
			"OK", NULL, NULL, phone1);
	[gRulePhone1Field selectText:self];
	[gRuleResultField setStringValue:""];
	return self;
    }

    /*  CHECK TO MAKE SURE PHONE SYMBOL 2 IS IN TEMPLATE  */
    if (![template usedAsPhoneSymbol:phone2]) {
	NXBeep();
	NXRunAlertPanel("Undefined phone",
			"The phone:  %s\n is not defined in the Template.\n",
			"OK", NULL, NULL, phone2);
	[gRulePhone2Field selectText:self];
	[gRuleResultField setStringValue:""];
	return self;
    }

    /*  FIND THE GOVERNING RULE  */
    specifier = [self governingRule:phone1:phone2];

    /*  PRINT GOVERNING RULE TO FIELD  */
    sprintf(buffer,"[%s]>>[%s]",specifier->category1,specifier->category2);
    [gRuleResultField setStringValue:buffer];
    [gRulePhone1Field selectText:self];

    return self;
}


- (specifierStructPtr)governingRule:(char *)phone1:(char *)phone2
{
    int i;
    specifierStructPtr current_specifier_ptr;

    /*  RETURN THE GOVERNING RULE FOR THE DIPHONE:  phone1/phone2  */
    current_specifier_ptr = specifierHead;
    for (i = 0; i < number_of_specifiers; i++) {
	if (evaluate(current_specifier_ptr->category1,phone1,self) &&
	    evaluate(current_specifier_ptr->category2,phone2,self))
	  break;

	current_specifier_ptr = current_specifier_ptr->next;
    }
    /*  IF HERE, WE KNOW THIS SPECIFIER IS THE RULE FOR THE DIPHONE  */
    return(current_specifier_ptr);
}



- (int)matchPhone:(char *)phone ToCategory:(char *)category
{
    return([phone_description matchPhone:(char *)phone ToCategory:(char *)category]);
}



- writeDiphone:(char *)phone1:(char *)phone2:(specifierStructPtr)g_rule
              :(filterParamPtr)filter_paramHead:(FILE *)fp:(vm_address_t)page;
{
    f_parameterPtr new_f_parameter();
    void free_f_parameter();
    f_parameterPtr f_parameterHead = NULL;
    f_parameterPtr current_f_parameter_ptr = NULL, temp_f_parameter_ptr;
    int number_of_f_parameters = 0;

    f_intervalPtr current_f_interval_ptr = NULL, temp_next_f_interval_ptr, new_f_interval();
    filterParamPtr current_filter_ptr;
    t_intervalPtr current_t_interval_ptr;

    int i, j, k, nint();
    double begin_target, end_target, target_diff, current_value;
    int phone_length = 0, fixed_length = 0, proportional_length, excess, 
        regression_length = 0, sample_size;

    struct {
	int length;
	double regression_factor;
    } t_int[INTERVALS_MAX];

    struct {
	int length;
	double regression_factor;
	double abs_value;
	double rise;
    } t_sub_int[SUB_INTERVALS_MAX];

    specialEventStructPtr current_se_ptr;
    se_intervalPtr current_se_interval_ptr;
    sub_intervalPtr current_sub_interval_ptr;

    double delta, current_abs_value, held_abs_value = 0, previous_deviation = 0;

    start_timePtr start_timeHead, current_start_time_ptr, new_start_time(), temp_start_time_ptr;
    void free_start_time();
    int number_of_start_times;
    int coded_duration;

    int *page_offset_i;
    float *page_offset_f;

/*
    printf("\nDiphone: %s/%s\n",phone1,phone2);
    printf("  Rule: [%s] >> [%s]\n",g_rule->category1,g_rule->category2);
*/

    /*  GET SAMPLE SIZE FROM TEMPLATE  */
    sample_size = [template sampleValue];

    /*  CALCULATE DIPHONE LENGTH, DEPENDING UPON RULE  */
    if (g_rule->duration.rule == DUR_RULE_P1) {
/*	printf("  DUR_RULE_P1\n");  */
	phone_length = [phone_description getPhoneLength:phone1];
    }
    else if (g_rule->duration.rule == DUR_RULE_P2) {
/*	printf("  DUR_RULE_P2\n");  */
	phone_length = [phone_description getPhoneLength:phone2];
    }
    else if (g_rule->duration.rule == DUR_RULE_AVG) {
	float p1, p2;
/*	printf("  DUR_RULE_AVG\n");  */
	p1 = [phone_description getPhoneLength:phone1];
	p2 = [phone_description getPhoneLength:phone2];
	phone_length = nint(((p1 + p2) / 2.0) / (float)sample_size) * sample_size;
    }
    else if (g_rule->duration.rule == DUR_RULE_NORMAL) {
	float p1, p2, t1, t2;
/*	printf("  DUR_RULE_NORMAL\n");  */
	/*  GET PHONE DURATION VALUES  */
	p1 = [phone_description getPhoneLength:phone1];
	p2 = [phone_description getPhoneLength:phone2];
	/*  GET TRANSITION DURATION VALUE FOR PHONE1  */
	if ([phone_description getTransitionType:phone1] == T_DURATION_FIXED) {
	    t1 = [phone_description getTransitionDurationFixed:phone1];
	}
	else {
	    t1 = [phone_description getTransitionDurationProp:phone1] * p1;
	}
	/*  GET TRANSITION DURATION VALUE FOR PHONE2  */
	if ([phone_description getTransitionType:phone2] == T_DURATION_FIXED) {
	    t2 = [phone_description getTransitionDurationFixed:phone2];
	}
	else {
	    t2 = [phone_description getTransitionDurationProp:phone2] * p2;
	}
/*	printf("  p1 = %f  p2 = %f  t1 = %f  t2 = %f\n",p1,p2,t1,t2);  */
	/*  CALCULATE LENGTH  */
	phone_length = nint(((((p1-t1)/2.0) + t2 + ((p2-t2)/2.0))) / (float)sample_size)
	    * sample_size;
    }
    else if (g_rule->duration.rule == DUR_RULE_T_RIGHT) {
	float p1, p2, t1, t2;
/*	printf("  DUR_RULE_T_RIGHT\n");  */
	/*  GET PHONE DURATION VALUES  */
	p1 = [phone_description getPhoneLength:phone1];
	p2 = [phone_description getPhoneLength:phone2];
	/*  GET TRANSITION DURATION VALUE FOR PHONE1  */
	if ([phone_description getTransitionType:phone1] == T_DURATION_FIXED) {
	    t1 = [phone_description getTransitionDurationFixed:phone1];
	}
	else {
	    t1 = [phone_description getTransitionDurationProp:phone1] * p1;
	}
	/*  GET TRANSITION DURATION VALUE FOR PHONE2  */
	if ([phone_description getTransitionType:phone2] == T_DURATION_FIXED) {
	    t2 = [phone_description getTransitionDurationFixed:phone2];
	}
	else {
	    t2 = [phone_description getTransitionDurationProp:phone2] * p2;
	}
/*	printf("  p1 = %f  p2 = %f  t1 = %f  t2 = %f\n",p1,p2,t1,t2);  */
	/*  CALCULATE LENGTH  */
	phone_length = nint(((((p1-t1)/2.0) + t2 + (p2/2.0))) / (float)sample_size)
	    * sample_size;
    }
    else if (g_rule->duration.rule == DUR_RULE_T_LEFT) {
	float p1, p2, t1, t2;
/*	printf("  DUR_RULE_T_LEFT\n");  */
	/*  GET PHONE DURATION VALUES  */
	p1 = [phone_description getPhoneLength:phone1];
	p2 = [phone_description getPhoneLength:phone2];
	/*  GET TRANSITION DURATION VALUE FOR PHONE1  */
	if ([phone_description getTransitionType:phone1] == T_DURATION_FIXED) {
	    t1 = [phone_description getTransitionDurationFixed:phone1];
	}
	else {
	    t1 = [phone_description getTransitionDurationProp:phone1] * p1;
	}
	/*  GET TRANSITION DURATION VALUE FOR PHONE2  */
	if ([phone_description getTransitionType:phone2] == T_DURATION_FIXED) {
	    t2 = [phone_description getTransitionDurationFixed:phone2];
	}
	else {
	    t2 = [phone_description getTransitionDurationProp:phone2] * p2;
	}
/*	printf("  p1 = %f  p2 = %f  t1 = %f  t2 = %f\n",p1,p2,t1,t2);  */
	/*  CALCULATE LENGTH  */
	phone_length = nint((((p1/2.0) + t1 + ((p2-t2)/2.0))) / (float)sample_size)
	    * sample_size;
    }
    else if (g_rule->duration.rule == DUR_RULE_T_MIDDLE) {
	float p1, p2, fixed;
/*	printf("  DUR_RULE_T_MIDDLE\n");  */
	/*  GET PHONE DURATION VALUES  */
	p1 = [phone_description getPhoneLength:phone1];
	p2 = [phone_description getPhoneLength:phone2];
	/*  GET FIXED VALUE  */
	fixed = g_rule->duration.fixed_length;
/*	printf("  p1 = %f  p2 = %f  fixed = %f\n",p1,p2,fixed);  */
	/*  CALCULATE LENGTH  */
	phone_length = nint(((((p1-fixed)/2.0) + fixed + ((p2-fixed)/2.0))) / (float)sample_size)
	    * sample_size;
    }
    else if (g_rule->duration.rule == DUR_RULE_FIXED) {
	phone_length = g_rule->duration.fixed_length;
    }
/*    printf("  phone_length = %-d\n",phone_length);  */


    /*  IF ARBITRARY INTERNAL SPLIT, USE PROPORTIONS FOR CALCULATING LENGTHS  */
    if (g_rule->split_mode == SPLIT_MODE_ARBITRARY) {
/*	printf(" SPLIT_MODE_ARBITRARY\n");  */
	/*  FIND TOTAL FIXED LENGTH OF INTERVALS  */
	current_t_interval_ptr = g_rule->t_intervalHead;
	for (i = 0; i < g_rule->number_of_t_intervals; i++) {
	    if (!(current_t_interval_ptr->proportional))
		fixed_length += (current_t_interval_ptr->duration.ival);
	    current_t_interval_ptr = current_t_interval_ptr->next;
	}
	
	/*  CALCULATE TOTAL PROPORTIONAL LENGTH  */
	proportional_length = phone_length - fixed_length;
	
	/*  CALCULATE LENGTH OF EACH T_INTERVAL  */
	excess = proportional_length;
	current_t_interval_ptr = g_rule->t_intervalHead;
	for (i = 0; i < g_rule->number_of_t_intervals; i++) {
	    if (current_t_interval_ptr->proportional) {
		/*  CALCULATE PROPORTIONAL INTERVAL, ROUND TO NEAREST SAMPLE  */
		t_int[i].length = 
		    nint(((double)proportional_length * 
			  (double)current_t_interval_ptr->duration.fval)/
			  (double)sample_size) * sample_size;
		/*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
		if (t_int[i].length <= 0)
		    t_int[i].length = sample_size;
		/*  KEEP TRACK OF EXCESS  */
		excess -= t_int[i].length;
	    }
	    else {
		/*  IF FIXED, SIMPLY USE SPECIFIED FIXED DURATION  */
		t_int[i].length = current_t_interval_ptr->duration.ival;
	    }
	    
	    current_t_interval_ptr = current_t_interval_ptr->next;
	}
	
	/*  IF EXCESS, ADJUST PROPORTIONAL INTERVALS SO THAT TOTAL LENGTH IS RIGHT  */
	/*  APPLY EXCESS TO FIRST PROPORTIONAL INTERVAL, IF POSSIBLE  */
	if (excess != 0) {
	    int original_length;
	    
	    current_t_interval_ptr = g_rule->t_intervalHead;
	    for (i = 0; i < g_rule->number_of_t_intervals; i++) {
		original_length = t_int[i].length;
		if (current_t_interval_ptr->proportional) {
		    /*  APPLY EXCESS, MAKING SURE IT IS SPREAD EVENLY  */
		    if (excess < (-sample_size))
			t_int[i].length += (excess + sample_size);
		    else if (excess > sample_size)
			t_int[i].length += (excess - sample_size);
		    else
			t_int[i].length += excess;
		    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
		    if (t_int[i].length <= 0)
			t_int[i].length = sample_size;
		    /*  CALCULATE LEFTOVER EXCESS  */
		    excess += (original_length - t_int[i].length);
		}
		
		current_t_interval_ptr = current_t_interval_ptr->next;
	    }
	}
    }
    /*  ELSE USE FORMULA TO CALCULATE LENGTHS  */
    else {
	int length_error = NO;
/*	printf(" SPLIT_MODE_FORMULA\n");  */
	if (g_rule->duration.rule == DUR_RULE_NORMAL) {
	    float p1, p2, t1, t2;
/*	    printf("  DUR_RULE_NORMAL\n");  */
	    /*  GET PHONE DURATION VALUES  */
	    p1 = [phone_description getPhoneLength:phone1];
	    p2 = [phone_description getPhoneLength:phone2];
	    /*  GET TRANSITION DURATION VALUE FOR PHONE1  */
	    if ([phone_description getTransitionType:phone1] == T_DURATION_FIXED) {
		t1 = [phone_description getTransitionDurationFixed:phone1];
	    }
	    else {
		t1 = [phone_description getTransitionDurationProp:phone1] * p1;
	    }
	    /*  GET TRANSITION DURATION VALUE FOR PHONE2  */
	    if ([phone_description getTransitionType:phone2] == T_DURATION_FIXED) {
		t2 = [phone_description getTransitionDurationFixed:phone2];
	    }
	    else {
		t2 = [phone_description getTransitionDurationProp:phone2] * p2;
	    }
/*	    printf("  p1 = %f  p2 = %f  t1 = %f  t2 = %f\n",p1,p2,t1,t2);  */
	    /*  CALCULATE FIRST INTERVAL LENGTH  */
	    t_int[0].length = 
		nint(((p1-t1)/2.0)/(double)sample_size) * sample_size;
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[0].length <= 0) {
		t_int[0].length = sample_size;
		length_error = YES;
	    }
	    /*  CALCULATE SECOND INTERVAL LENGTH  */
	    t_int[1].length = 
		nint((t2)/(double)sample_size) * sample_size;
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[1].length <= 0) {
		t_int[1].length = sample_size;
		length_error = YES;
	    }
	    /*  CALCULATE THIRD INTERVAL LENGTH (IS WHAT IS LEFT OVER)  */
	    t_int[2].length = phone_length - (t_int[0].length + t_int[1].length);
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[2].length <= 0) {
		t_int[2].length = sample_size;
		length_error = YES;
	    }
	    /*  IF LENGTH ERROR, RECALCULATE DIPHONE LENGTH  */
	    if (length_error) {
		phone_length = t_int[0].length + t_int[1].length + t_int[2].length;
/*		printf("   length error;  new phone_length = %-d\n",phone_length);  */
	    }
/*	    printf("  int1 = %d  int2 = %d  int3 = %d\n",
		   t_int[0].length,t_int[1].length,t_int[2].length);  */
	}
	else if (g_rule->duration.rule == DUR_RULE_T_RIGHT) {
	    float p1, p2, t1, t2;
/*	    printf("  DUR_RULE_T_RIGHT\n");  */
	    /*  GET PHONE DURATION VALUES  */
	    p1 = [phone_description getPhoneLength:phone1];
	    p2 = [phone_description getPhoneLength:phone2];
	    /*  GET TRANSITION DURATION VALUE FOR PHONE1  */
	    if ([phone_description getTransitionType:phone1] == T_DURATION_FIXED) {
		t1 = [phone_description getTransitionDurationFixed:phone1];
	    }
	    else {
		t1 = [phone_description getTransitionDurationProp:phone1] * p1;
	    }
	    /*  GET TRANSITION DURATION VALUE FOR PHONE2  */
	    if ([phone_description getTransitionType:phone2] == T_DURATION_FIXED) {
		t2 = [phone_description getTransitionDurationFixed:phone2];
	    }
	    else {
		t2 = [phone_description getTransitionDurationProp:phone2] * p2;
	    }
/*	    printf("  p1 = %f  p2 = %f  t1 = %f  t2 = %f\n",p1,p2,t1,t2);  */
	    /*  CALCULATE FIRST INTERVAL LENGTH  */
	    t_int[0].length = 
		nint(((p1-t1)/2.0)/(double)sample_size) * sample_size;
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[0].length <= 0) {
		t_int[0].length = sample_size;
		length_error = YES;
	    }
	    /*  CALCULATE SECOND INTERVAL LENGTH  */
	    t_int[1].length = 
		nint((t2)/(double)sample_size) * sample_size;
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[1].length <= 0) {
		t_int[1].length = sample_size;
		length_error = YES;
	    }
	    /*  CALCULATE THIRD INTERVAL LENGTH (IS WHAT IS LEFT OVER)  */
	    t_int[2].length = phone_length - (t_int[0].length + t_int[1].length);
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[2].length <= 0) {
		t_int[2].length = sample_size;
		length_error = YES;
	    }
	    /*  IF LENGTH ERROR, RECALCULATE DIPHONE LENGTH  */
	    if (length_error) {
		phone_length = t_int[0].length + t_int[1].length + t_int[2].length;
/*		printf("   length error;  new phone_length = %-d\n",phone_length);  */
	    }
/*	    printf("  int1 = %d  int2 = %d  int3 = %d\n",
		   t_int[0].length,t_int[1].length,t_int[2].length);  */
	}
	else if (g_rule->duration.rule == DUR_RULE_T_LEFT) {
	    float p1, p2, t1, t2;
/*	    printf("  DUR_RULE_T_LEFT\n");  */
	    /*  GET PHONE DURATION VALUES  */
	    p1 = [phone_description getPhoneLength:phone1];
	    p2 = [phone_description getPhoneLength:phone2];
	    /*  GET TRANSITION DURATION VALUE FOR PHONE1  */
	    if ([phone_description getTransitionType:phone1] == T_DURATION_FIXED) {
		t1 = [phone_description getTransitionDurationFixed:phone1];
	    }
	    else {
		t1 = [phone_description getTransitionDurationProp:phone1] * p1;
	    }
	    /*  GET TRANSITION DURATION VALUE FOR PHONE2  */
	    if ([phone_description getTransitionType:phone2] == T_DURATION_FIXED) {
		t2 = [phone_description getTransitionDurationFixed:phone2];
	    }
	    else {
		t2 = [phone_description getTransitionDurationProp:phone2] * p2;
	    }
/*	    printf("  p1 = %f  p2 = %f  t1 = %f  t2 = %f\n",p1,p2,t1,t2);  */
	    /*  CALCULATE FIRST INTERVAL LENGTH  */
	    t_int[0].length = 
		nint(((p1)/2.0)/(double)sample_size) * sample_size;
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[0].length <= 0) {
		t_int[0].length = sample_size;
		length_error = YES;
	    }
	    /*  CALCULATE SECOND INTERVAL LENGTH  */
	    t_int[1].length = 
		nint((t1)/(double)sample_size) * sample_size;
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[1].length <= 0) {
		t_int[1].length = sample_size;
		length_error = YES;
	    }
	    /*  CALCULATE THIRD INTERVAL LENGTH (IS WHAT IS LEFT OVER)  */
	    t_int[2].length = phone_length - (t_int[0].length + t_int[1].length);
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[2].length <= 0) {
		t_int[2].length = sample_size;
		length_error = YES;
	    }
	    /*  IF LENGTH ERROR, RECALCULATE DIPHONE LENGTH  */
	    if (length_error) {
		phone_length = t_int[0].length + t_int[1].length + t_int[2].length;
/*		printf("   length error;  new phone_length = %-d\n",phone_length);  */
	    }
/*	    printf("  int1 = %d  int2 = %d  int3 = %d\n",
		   t_int[0].length,t_int[1].length,t_int[2].length);  */
	}
	else if (g_rule->duration.rule == DUR_RULE_T_MIDDLE) {
	    float p1, p2, fixed;
/*	    printf("  DUR_RULE_T_MIDDLE\n");  */
	    /*  GET PHONE DURATION VALUES  */
	    p1 = [phone_description getPhoneLength:phone1];
	    p2 = [phone_description getPhoneLength:phone2];
	    /*  GET FIXED VALUE  */
	    fixed = g_rule->duration.fixed_length;
/*	    printf("  p1 = %f  p2 = %f  fixed = %f\n",p1,p2,fixed);  */
	    /*  CALCULATE FIRST INTERVAL LENGTH  */
	    t_int[0].length = 
		nint(((p1-fixed)/2.0)/(double)sample_size) * sample_size;
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[0].length <= 0) {
		t_int[0].length = sample_size;
		length_error = YES;
	    }
	    /*  CALCULATE SECOND INTERVAL LENGTH  */
	    t_int[1].length = 
		nint((fixed)/(double)sample_size) * sample_size;
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[1].length <= 0) {
		t_int[1].length = sample_size;
		length_error = YES;
	    }
	    /*  CALCULATE THIRD INTERVAL LENGTH (IS WHAT IS LEFT OVER)  */
	    t_int[2].length = phone_length - (t_int[0].length + t_int[1].length);
	    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
	    if (t_int[2].length <= 0) {
		t_int[2].length = sample_size;
		length_error = YES;
	    }
	    /*  IF LENGTH ERROR, RECALCULATE DIPHONE LENGTH  */
	    if (length_error) {
		phone_length = t_int[0].length + t_int[1].length + t_int[2].length;
/*		printf("   length error;  new phone_length = %-d\n",phone_length);  */
	    }
/*	    printf("  int1 = %d  int2 = %d  int3 = %d\n",
		   t_int[0].length,t_int[1].length,t_int[2].length);  */
	}
    }


    /*  CALCULATE TOTAL REGRESSION LENGTH  */
    current_t_interval_ptr = g_rule->t_intervalHead;
    for (i = 0; i < g_rule->number_of_t_intervals; i++) {
	if (current_t_interval_ptr->regression)
	    regression_length += t_int[i].length;
	
	current_t_interval_ptr = current_t_interval_ptr->next;
    }

    /*  CALCULATE REGRESSION FACTOR FOR EACH INTERVAL  */
    current_t_interval_ptr = g_rule->t_intervalHead;
    for (i = 0; i < g_rule->number_of_t_intervals; i++) {
	if (current_t_interval_ptr->regression)
	    t_int[i].regression_factor = (double)t_int[i].length/(double)regression_length;
	else
	    t_int[i].regression_factor = 0.0;

	current_t_interval_ptr = current_t_interval_ptr->next;
    }
    


    /*  ALLOCATE STRUCTURES FOR EACH FILTERED PARAMETER  */
    current_filter_ptr = filter_paramHead;
    while (current_filter_ptr != NULL) {
	/*  ALLOCATE A NEW STRUCTURE  */
	if (number_of_f_parameters == 0) {
	    f_parameterHead = current_f_parameter_ptr = new_f_parameter();
	}
	else {
	    current_f_parameter_ptr->next = new_f_parameter();
	    current_f_parameter_ptr = current_f_parameter_ptr->next;
	}
	/*  SET VALUES IN STRUCT  */
	strcpy(current_f_parameter_ptr->symbol,current_filter_ptr->symbol);
	current_f_parameter_ptr->number_of_f_intervals = g_rule->number_of_t_intervals;
	/*  ALLOCATE INTERVAL STRUCTURES, IF NEEDED  */
	current_f_parameter_ptr->f_intervalHead = NULL;
	for (i = 0; i < current_f_parameter_ptr->number_of_f_intervals; i++) {
	    /*  ALLOCATE A NEW STRUCTURE  */
	    if (i == 0) {
		current_f_parameter_ptr->f_intervalHead = current_f_interval_ptr = 
		    new_f_interval();
		current_f_interval_ptr->previous = NULL;
	    }
	    else {
		current_f_interval_ptr->next = new_f_interval();
		current_f_interval_ptr->next->previous = current_f_interval_ptr;
		current_f_interval_ptr = current_f_interval_ptr->next;
	    }
	    /*  INITIALIZE INTERVAL STRUCTURE  */
	    current_f_interval_ptr->run = t_int[i].length;
	    current_f_interval_ptr->regression_factor = t_int[i].regression_factor;
	    current_f_interval_ptr->abs_value = 0.0;
	    current_f_interval_ptr->rise = 0.0;
	    current_f_interval_ptr->special_event = 0;
	    current_f_interval_ptr->next = NULL;
	}
	current_f_parameter_ptr->next = NULL;

	current_filter_ptr = current_filter_ptr->next;
	number_of_f_parameters++;
    }

    /*  CALCULATE RISE AND ABSOLUTE VALUE FOR EACH PARAMETER, 
	DEPENDING ON RULE AND TARGET VALUES  */
    current_f_parameter_ptr = f_parameterHead;
    for (i = 0; i < number_of_f_parameters; i++) {
	double minimum, maximum, overflow;
/*	printf("  f_parameter = %s\n",current_f_parameter_ptr->symbol);  */
	/*  GET BEGIN AND END TARGET VALUES  */
	current_value = begin_target = 
	    [phone_description getTarget:phone1:current_f_parameter_ptr->symbol];
	end_target = [phone_description getTarget:phone2:current_f_parameter_ptr->symbol];
	target_diff = end_target - begin_target;

	/*  CALCULATE RISE VALUES, DEPENDING ON MODE  */
	if (g_rule->t_interval_mode == FIXED_RISE_MODE) {
	    current_t_interval_ptr = g_rule->t_intervalHead;
	    current_f_interval_ptr = current_f_parameter_ptr->f_intervalHead;
	    for (j = 0; j < current_f_parameter_ptr->number_of_f_intervals; j++) {
		current_f_interval_ptr->abs_value = current_value;
		current_f_interval_ptr->rise = target_diff * (current_t_interval_ptr->rise);
		current_value += (current_f_interval_ptr->rise);

		current_f_interval_ptr = current_f_interval_ptr->next;
		current_t_interval_ptr = current_t_interval_ptr->next;
	    }
	}
	else if (g_rule->t_interval_mode == SLOPE_RATIO_MODE) {
	    /*  CALCULATE REFERENCE SLOPE  */
	    double m_ref, sum = 0.0;
	    current_t_interval_ptr = g_rule->t_intervalHead;
	    current_f_interval_ptr = current_f_parameter_ptr->f_intervalHead;
	    for (j = 0; j < current_f_parameter_ptr->number_of_f_intervals; j++) {
		sum += (current_t_interval_ptr->slope_ratio * (double)current_f_interval_ptr->run);

		current_f_interval_ptr = current_f_interval_ptr->next;
		current_t_interval_ptr = current_t_interval_ptr->next;
	    }
	    m_ref = target_diff / sum;
	    /*  CALCULATE RISE VALUES  */
	    current_t_interval_ptr = g_rule->t_intervalHead;
	    current_f_interval_ptr = current_f_parameter_ptr->f_intervalHead;
	    for (j = 0; j < current_f_parameter_ptr->number_of_f_intervals; j++) {
		current_f_interval_ptr->abs_value = current_value;
		current_f_interval_ptr->rise = 
		    current_t_interval_ptr->slope_ratio * m_ref * 
			(double)current_f_interval_ptr->run;
		current_value += (current_f_interval_ptr->rise);

		current_f_interval_ptr = current_f_interval_ptr->next;
		current_t_interval_ptr = current_t_interval_ptr->next;
	    }
	}

	/*  MAKE SURE ABS VALUES ARE IN RANGE; ADJUST IF NECESSARY  */
	/*  ANCHOR POINTS ARE IGNORED  */
	/*  GET THE MINIMUM AND MAXIMUM FOR THE PARAMETER  */
	minimum = [template parameterSymMinimum:current_f_parameter_ptr->symbol];
	maximum = [template parameterSymMaximum:current_f_parameter_ptr->symbol];

	current_f_interval_ptr = current_f_parameter_ptr->f_intervalHead;
	for (j = 0; j < current_f_parameter_ptr->number_of_f_intervals; j++) {
	    if (current_f_interval_ptr->abs_value > maximum) {
		overflow = current_f_interval_ptr->abs_value - maximum;
		current_f_interval_ptr->previous->rise -= overflow;
		current_f_interval_ptr->abs_value -= overflow;
		if (current_f_interval_ptr->next != NULL)
		    current_f_interval_ptr->rise = 
			current_f_interval_ptr->next->abs_value - current_f_interval_ptr->abs_value;
		else
		    current_f_interval_ptr->rise = end_target - current_f_interval_ptr->abs_value;
	    }
	    else if (current_f_interval_ptr->abs_value < minimum) {
		overflow = current_f_interval_ptr->abs_value - minimum;
		current_f_interval_ptr->previous->rise -= overflow;
		current_f_interval_ptr->abs_value -= overflow;
		if (current_f_interval_ptr->next != NULL)
		    current_f_interval_ptr->rise = 
			current_f_interval_ptr->next->abs_value - current_f_interval_ptr->abs_value;
		else
		    current_f_interval_ptr->rise = end_target - current_f_interval_ptr->abs_value;
	    }
	    
	    current_f_interval_ptr = current_f_interval_ptr->next;
	}

	/*  PRINT OUT UPDATED PARAMETER VALUES  */
/*
	printf("    adjusted parameter values\n");

	current_f_interval_ptr = current_f_parameter_ptr->f_intervalHead;
	for (j = 0; j < current_f_parameter_ptr->number_of_f_intervals; j++) {
	    printf("      %-d: abs_value = %f  rise = %f  run = %-d  regression_factor = %f delta = %f\n",
		   j,current_f_interval_ptr->abs_value,current_f_interval_ptr->rise,
		   current_f_interval_ptr->run,current_f_interval_ptr->regression_factor,
		   (current_f_interval_ptr->rise/(double)current_f_interval_ptr->run) );
	    if (j == (current_f_parameter_ptr->number_of_f_intervals - 1))
		printf("      end value = %f\n",
		       (current_f_interval_ptr->abs_value + current_f_interval_ptr->rise));
	    
	    current_f_interval_ptr = current_f_interval_ptr->next;
	}
*/

	/*  ADD SPECIAL EVENTS HERE, IF ANY ON THIS PARAMETER  */
	current_se_ptr = g_rule->specialEventHead;
	for (j = 0; j < g_rule->number_of_special_events; j++) {
	    if (!strcmp(current_f_parameter_ptr->symbol,current_se_ptr->symbol)) {
		int t_interval_length;
		/*  WE HAVE A MATCH TO A SPECIAL EVENT  */
/*		printf("    Special event match:  %s\n",current_f_parameter_ptr->symbol);  */

		/*  THE FOLLOWING ASSUME ABSOLUTE DEVIATION MODE  */
		/*  ADJUST (AND IF NECESSARY, SUBDIVIDE) EACH INTERVAL IN ORDER  */
		current_se_interval_ptr = current_se_ptr->se_intervalHead;
		current_f_interval_ptr = current_f_parameter_ptr->f_intervalHead;
		while (current_se_interval_ptr != NULL) {
		    /*  GET LENGTH OF F_INTERVAL  */
		    t_interval_length = current_f_interval_ptr->run;
		    
		    /*  FIND TOTAL FIXED LENGTH OF SUB-INTERVALS  */
		    fixed_length = 0;
		    current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
		    for (k = 0; k < current_se_interval_ptr->number_of_sub_intervals; k++) {
			if (!(current_sub_interval_ptr->proportional))
			    fixed_length += (current_sub_interval_ptr->duration.ival);
			current_sub_interval_ptr = current_sub_interval_ptr->next;
		    }
		    
		    /*  CALCULATE TOTAL PROPORTIONAL LENGTH  */
		    proportional_length = t_interval_length - fixed_length;

		    /*  CALCULATE LENGTH OF EACH SUB_INTERVAL  */
		    excess = proportional_length;
		    current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
		    for (k = 0; k < current_se_interval_ptr->number_of_sub_intervals; k++) {
			if (current_sub_interval_ptr->proportional) {
			    /*  CALCULATE PROPORTIONAL INTERVAL, ROUND TO NEAREST SAMPLE  */
			    t_sub_int[k].length = 
				nint(
				 ((double)proportional_length * current_sub_interval_ptr->duration.fval)/
				  (double)sample_size) * sample_size;
			    /*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
			    if (t_sub_int[k].length <= 0)
				t_sub_int[k].length = sample_size;
			    /*  KEEP TRACK OF EXCESS  */
			    excess -= t_sub_int[k].length;
			}
			else {
			    /*  IF FIXED, SIMPLY USE SPECIFIED FIXED DURATION  */
			    t_sub_int[k].length = current_sub_interval_ptr->duration.ival;
			}
			
			current_sub_interval_ptr = current_sub_interval_ptr->next;
		    }
		    
		    /*  IF EXCESS, ADJUST PROPORTIONAL INTERVALS SO THAT TOTAL LENGTH IS RIGHT  */
		    /*  APPLY EXCESS TO FIRST PROPORTIONAL INTERVAL, IF POSSIBLE  */
		    if (excess != 0) {
			int original_length;
			
			current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
			for (k = 0; k < current_se_interval_ptr->number_of_sub_intervals; k++) {
			    original_length = t_sub_int[k].length;
			    if (current_sub_interval_ptr->proportional) {
				/*  APPLY EXCESS, MAKING SURE IT IS SPREAD EVENLY  */
				if (excess < (-sample_size))
				    t_sub_int[k].length += (excess + sample_size);
				else if (excess > sample_size)
				    t_sub_int[k].length += (excess - sample_size);
				else
				    t_sub_int[k].length += excess;
				/*  MAKE SURE THE LENGTH IS GREATER THAN ZERO  */
				if (t_sub_int[k].length <= 0)
				    t_sub_int[k].length = sample_size;
				/*  CALCULATE LEFTOVER EXCESS  */
				excess += (original_length - t_sub_int[k].length);
			    }
			    
			    current_sub_interval_ptr = current_sub_interval_ptr->next;
			}
		    }

		    /*  CALCULATE REGRESSION FOR EACH SUB-INTERVAL  */
		    for (k = 0; k < current_se_interval_ptr->number_of_sub_intervals; k++) {
			t_sub_int[k].regression_factor = current_f_interval_ptr->regression_factor * 
			    ((double)t_sub_int[k].length/(double)t_interval_length);
		    }

		    /*  CALCULATE UN-DEVIATED ABSOLUTE VALUES FOR EVERY SUB-INTERVAL  */
		    delta = current_f_interval_ptr->rise/(double)current_f_interval_ptr->run;
		    current_abs_value = current_f_interval_ptr->abs_value;
		    for (k = 0; k < current_se_interval_ptr->number_of_sub_intervals; k++) {
			t_sub_int[k].abs_value = current_abs_value;
			t_sub_int[k].rise = (double)t_sub_int[k].length * delta;
			current_abs_value += t_sub_int[k].rise;
		    }

		    /*  ADD IN DEVIATION TO EVERY SUB-INTERVAL BY ADDING DELTAS  */
		    if (current_f_interval_ptr->previous == NULL) {
			held_abs_value = current_f_interval_ptr->abs_value;
			previous_deviation = 0.0;
		    }
		    current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
		    for (k = 0; k < current_se_interval_ptr->number_of_sub_intervals; k++) {
			double dev_rise;
			/*  ABSOLUTE VALUE IS HELD OVER FROM PREVIOUS INTERVAL  */
			t_sub_int[k].abs_value = held_abs_value;
			/*  CALCULATE DEVIATION RISE  */
			dev_rise = current_sub_interval_ptr->rise - previous_deviation;
			previous_deviation += dev_rise;
			/*  CALCULATE HELD ABSOLUTE VALUE  */
			held_abs_value += (t_sub_int[k].rise + dev_rise);
			t_sub_int[k].rise = held_abs_value - t_sub_int[k].abs_value;

			current_sub_interval_ptr = current_sub_interval_ptr->next;
		    }
		    
		    /*  ADD SPECIAL EVENTS INTO F_INTERVAL LINKED LIST  */
		    /*  THE FIRST SPECIAL EVENT IS THE SAME AS THE CURRENT F_INTERVAL  */
		    current_f_interval_ptr->run = t_sub_int[0].length;
		    current_f_interval_ptr->regression_factor = t_sub_int[0].regression_factor;
		    current_f_interval_ptr->abs_value = t_sub_int[0].abs_value;
		    current_f_interval_ptr->rise = t_sub_int[0].rise;
		    
		    /*  ALLOCATE NEW F_INTERVAL STRUCTURES  */
		    temp_next_f_interval_ptr = current_f_interval_ptr->next;
		    for (k = 1; k < current_se_interval_ptr->number_of_sub_intervals; k++) {
			/*  ALLOCATE THE STRUCTURE AND UPDATE POINTER  */
			current_f_interval_ptr->next = new_f_interval();
			current_f_interval_ptr->next->previous = current_f_interval_ptr;
			current_f_interval_ptr = current_f_interval_ptr->next;
			/*  TRANSFER VALUES FROM ARRAY TO STRUCTURE  */
			current_f_interval_ptr->run = t_sub_int[k].length;
			current_f_interval_ptr->regression_factor = t_sub_int[k].regression_factor;
			current_f_interval_ptr->abs_value = t_sub_int[k].abs_value;
			current_f_interval_ptr->rise = t_sub_int[k].rise;
			/*  MARK AS SPECIAL EVENT  */
			current_f_interval_ptr->special_event = 1;
			/*  UPDATE NUMBER OF F_INTERVALS  */
			current_f_parameter_ptr->number_of_f_intervals += 1;
		    }
		    /*  TIE INTO REST OF F_INTERVAL LIST  */
		    current_f_interval_ptr->next = temp_next_f_interval_ptr;
		    if (current_f_interval_ptr->next != NULL)
			current_f_interval_ptr->next->previous = current_f_interval_ptr;

		    /*  GO TO NEXT F_INTERVAL AND NEXT SE_INTERVAL */
		    current_f_interval_ptr = current_f_interval_ptr->next;
		    current_se_interval_ptr = current_se_interval_ptr->next;
		}

		/*  MAKE SURE ABS VALUES ARE IN RANGE; ADJUST IF NECESSARY  */
		/*  ANCHOR POINTS ARE IGNORED  */
		current_f_interval_ptr = current_f_parameter_ptr->f_intervalHead;
		for (k = 0; k < current_f_parameter_ptr->number_of_f_intervals; k++) {
		    if (current_f_interval_ptr->abs_value > maximum) {
			overflow = current_f_interval_ptr->abs_value - maximum;
			current_f_interval_ptr->previous->rise -= overflow;
			current_f_interval_ptr->abs_value -= overflow;
			if (current_f_interval_ptr->next != NULL)
			    current_f_interval_ptr->rise = 
				current_f_interval_ptr->next->abs_value - current_f_interval_ptr->abs_value;
			else
			    current_f_interval_ptr->rise = end_target - current_f_interval_ptr->abs_value;
		    }
		    else if (current_f_interval_ptr->abs_value < minimum) {
			overflow = current_f_interval_ptr->abs_value - minimum;
			current_f_interval_ptr->previous->rise -= overflow;
			current_f_interval_ptr->abs_value -= overflow;
			if (current_f_interval_ptr->next != NULL)
			    current_f_interval_ptr->rise = 
				current_f_interval_ptr->next->abs_value - current_f_interval_ptr->abs_value;
			else
			    current_f_interval_ptr->rise = end_target - current_f_interval_ptr->abs_value;
		    }
		    
		    current_f_interval_ptr = current_f_interval_ptr->next;
		}
		
		/*  PRINT OUT UPDATED PARAMETER VALUES  */
/*
		printf("    adjusted parameter values\n");
		current_f_interval_ptr = current_f_parameter_ptr->f_intervalHead;
		for (k = 0; k < current_f_parameter_ptr->number_of_f_intervals; k++) {
		    printf("      %-d: abs_value = %f  rise = %f  run = %-d  regression = %f se = %-d\n",
			   k,current_f_interval_ptr->abs_value,current_f_interval_ptr->rise,
			   current_f_interval_ptr->run,current_f_interval_ptr->regression_factor,
			   current_f_interval_ptr->special_event );
		    if (k == (current_f_parameter_ptr->number_of_f_intervals - 1))
			printf("      end value = %f\n",
			       (current_f_interval_ptr->abs_value + current_f_interval_ptr->rise));
		    
		    current_f_interval_ptr = current_f_interval_ptr->next;
		}
*/

		/*  BREAK OUT OF LOOP  */
		break;
	    }
	    current_se_ptr = current_se_ptr->next;
	}
	
	/*  UPDATE TO NEXT PARAMETER  */
	current_f_parameter_ptr = current_f_parameter_ptr->next;
    }

    /*  CONSOLODATE ALL PARAMETERS  */
    /*  FIND ALL UNIQUE START TIMES;  ALLOCATE A NODE FOR EACH  */
    number_of_start_times = 0;
    start_timeHead = NULL;
    current_f_parameter_ptr = f_parameterHead;
    for (i = 0; i < number_of_f_parameters; i++) {
	int start_time = 0;
	current_f_interval_ptr = current_f_parameter_ptr->f_intervalHead;
	for (j = 0; j < current_f_parameter_ptr->number_of_f_intervals; j++) {
	    /*  SEE IF START TIME IS UNIQUE  */
	    int unique = YES;
	    current_start_time_ptr = start_timeHead;
	    for (k = 0; k < number_of_start_times; k++) {
		if (current_start_time_ptr->value == start_time) {
		    unique = NO;
		    break;
		}
		current_start_time_ptr = current_start_time_ptr->next;
	    }
	    /*  IF START TIME IS UNIQUE, ALLOCATE A NODE FOR IT AND STORE  */
	    if (unique) {
		if (number_of_start_times == 0) {
		    start_timeHead = current_start_time_ptr = new_start_time();
		    current_start_time_ptr->previous = NULL;
		}
		else {
		    /*  FIND END OF LIST  */
		    current_start_time_ptr = start_timeHead;
		    for (k = 1; k < number_of_start_times; k++)
			current_start_time_ptr = current_start_time_ptr->next;
		    /*  ALLOCATE NODE ON END OF LIST  */
		    current_start_time_ptr->next = new_start_time();
		    current_start_time_ptr->next->previous = current_start_time_ptr;
		    current_start_time_ptr = current_start_time_ptr->next;
		}
		/*  INITIALIZE NODE  */
		current_start_time_ptr->next = NULL;
		current_start_time_ptr->value = start_time;
		current_start_time_ptr->special_event = current_f_interval_ptr->special_event;
		/*  UPDATE NUMBER OF START TIME NODES  */
		number_of_start_times++;
	    }

	    start_time += current_f_interval_ptr->run;
	    current_f_interval_ptr = current_f_interval_ptr->next;
	}

	current_f_parameter_ptr = current_f_parameter_ptr->next;
    }
    /*  TEMPORARY:  WRITE OUT START TIMES  */
/*
    printf("    number_of_start_times = %-d\n",number_of_start_times);
    current_start_time_ptr = start_timeHead;
    for (i = 0; i < number_of_start_times; i++) {
	printf("      %-d:  value = %-d  se = %-d\n",
	       i,current_start_time_ptr->value,current_start_time_ptr->special_event);
	current_start_time_ptr = current_start_time_ptr->next;
    }
*/

    /*  SORT THE START TIMES USING INSERTION SORT  */
    current_start_time_ptr = start_timeHead->next;
    for (j = 1; j < number_of_start_times; j++) {
	start_timePtr second_start_time_ptr = current_start_time_ptr->previous;
	int a = current_start_time_ptr->value;
	int b = current_start_time_ptr->special_event;

	while ((second_start_time_ptr != NULL) && (second_start_time_ptr->value > a)) {
	    second_start_time_ptr->next->value = second_start_time_ptr->value;
	    second_start_time_ptr->next->special_event = second_start_time_ptr->special_event;

	    second_start_time_ptr = second_start_time_ptr->previous;
	}
	second_start_time_ptr->next->value = a;
	second_start_time_ptr->next->special_event = b;
	
	current_start_time_ptr = current_start_time_ptr->next;
    }

    /*  TEMPORARY:  WRITE OUT START TIMES  */
/*
    printf("    sorted:  number_of_start_times = %-d\n",number_of_start_times);
    current_start_time_ptr = start_timeHead;
    for (i = 0; i < number_of_start_times; i++) {
	printf("      %-d:  value = %-d  se = %-d\n",
	       i,current_start_time_ptr->value,current_start_time_ptr->special_event);
	current_start_time_ptr = current_start_time_ptr->next;
    }
*/

    /*  WRITE TO FILE AND/OR PAGE OF VM  */
    page_offset_i = (int *)page;
    page_offset_f = (float *)page;

    /*  DIPHONE HEADER  */
    if (fp != NULL)
	fwrite((char *)&number_of_start_times,sizeof(number_of_start_times),1,fp);
    if (page != 0) {
	*(page_offset_i++) = number_of_start_times;
	page_offset_f = (float *)page_offset_i;
    }
/*    printf("  number_of_intervals = %-d\n",number_of_start_times);  */

    coded_duration = phone_length/sample_size;
    if (fp != NULL)
	fwrite((char *)&coded_duration,sizeof(coded_duration),1,fp);
    if (page != 0) {
	*(page_offset_i++) = coded_duration;
	page_offset_f = (float *)page_offset_i;
    }
/*    printf("  total_duration = %-d; in samples = %-d\n",phone_length,coded_duration);  */

    /*  INDIVIDUAL INTERVALS  */
    current_start_time_ptr = start_timeHead;
    for (i = 0; i < number_of_start_times; i++) {
	/*  CALCULATE HEADER  */
	int duration, interval_start_time;
	float regression;
	/*  DURATION  */
	if (current_start_time_ptr->next != NULL)
	    duration = current_start_time_ptr->next->value - current_start_time_ptr->value;
	else
	    duration = phone_length - current_start_time_ptr->value;
	coded_duration = current_start_time_ptr->special_event ? 
	    ((duration/sample_size)|0x80000000) : (duration/sample_size);

	if (fp != NULL)
	    fwrite((char *)&coded_duration,sizeof(coded_duration),1,fp);
	if (page != 0) {
	    *(page_offset_i++) = coded_duration;
	    page_offset_f = (float *)page_offset_i;
	}
/*	printf("    duration = %-d; in samples = %-d  se = %-d coded duration = %-d\n",
	       duration,(duration/sample_size),current_start_time_ptr->special_event,coded_duration); */

	/*  REGRESSION FACTOR, USING FIRST PARAMETER  */
	interval_start_time = 0;
	current_f_interval_ptr = f_parameterHead->f_intervalHead;
	for (j = 0; j < f_parameterHead->number_of_f_intervals; j++) {
	    if ((interval_start_time + current_f_interval_ptr->run) > current_start_time_ptr->value) {
		regression = (float)(current_f_interval_ptr->regression_factor * 
		    ((double)duration/(double)current_f_interval_ptr->run));
		if (fp != NULL)
		    fwrite((char *)&regression,sizeof(regression),1,fp);
		if (page != 0) {
		    *(page_offset_f++) = regression;
		    page_offset_i = (int *)page_offset_f;
		}
/*		printf("    regression_factor = %f\n",regression);  */
		break;
	    }

	    interval_start_time += current_f_interval_ptr->run;
	    current_f_interval_ptr = current_f_interval_ptr->next;
	}
	/*  CALCULATE INDIVIDUAL PARAMETERS  */
	current_f_parameter_ptr = f_parameterHead;
	for (j = 0; j < number_of_f_parameters; j++) {
	    float calculated_rise;
	    /*  FIND THE F_INTERVAL IN WHICH THE CURRENT START TIME OCCURS  */
	    interval_start_time = 0;
	    current_f_interval_ptr = current_f_parameter_ptr->f_intervalHead;
	    for (k = 0; k < current_f_parameter_ptr->number_of_f_intervals; k++) {
		if ((interval_start_time + current_f_interval_ptr->run) > current_start_time_ptr->value)
		    break;

		interval_start_time += current_f_interval_ptr->run;
		current_f_interval_ptr = current_f_interval_ptr->next;
	    }
	    /*  CALCULATE RISE FOR THIS SORTED INTERVAL  */
	    calculated_rise = 
	      (float)((current_f_interval_ptr->rise * (double)duration)/(double)current_f_interval_ptr->run);
	    if (fp != NULL)
		fwrite((char *)&calculated_rise,sizeof(calculated_rise),1,fp);
	    if (page != 0) {
		*(page_offset_f++) = calculated_rise;
		page_offset_i = (int *)page_offset_f;
	    }
/*	    printf("      parameter[%s] rise = %f\n",current_f_parameter_ptr->symbol,calculated_rise); */

	    current_f_parameter_ptr = current_f_parameter_ptr->next;
	}
	

	current_start_time_ptr = current_start_time_ptr->next;
    }
    

    /*  FREE ALL START TIME NODES  */
    current_start_time_ptr = start_timeHead;
    for (i = 0; i < number_of_start_times; i++) {
	temp_start_time_ptr = current_start_time_ptr;
	current_start_time_ptr = current_start_time_ptr->next;
	free_start_time(temp_start_time_ptr);
    }

    /*  FREE ALL F_PARAMETERS  */
    current_f_parameter_ptr = f_parameterHead;
    for (i = 0; i < number_of_f_parameters; i++) {
	temp_f_parameter_ptr = current_f_parameter_ptr;
	current_f_parameter_ptr = current_f_parameter_ptr->next;
	free_f_parameter(temp_f_parameter_ptr);
    }

    return self;
}



- saveToFile:(FILE *)fp1
{
    int i, j, k, l;
    int category_length;
    specifierStructPtr current_specifier_ptr;
    t_intervalPtr current_t_interval;
    specialEventStructPtr current_se_ptr;
    se_intervalPtr current_se_interval_ptr;
    sub_intervalPtr current_sub_interval_ptr;

    /*  WRITE EACH SPECIFIER TO FILE  */
    fwrite((char *)&number_of_specifiers,sizeof(number_of_specifiers),1,fp1);
    current_specifier_ptr = specifierHead;
    for (i = 0; i < number_of_specifiers; i++) {
	/*  WRITE SPECIFIER CATEGORY #1 TO FILE  */
	category_length = strlen(current_specifier_ptr->category1);
	fwrite((char *)&category_length,sizeof(category_length),1,fp1);
	fwrite((char *)(current_specifier_ptr->category1),category_length+1,1,fp1);

	/*  WRITE SPECIFIER CATEGORY #2 TO FILE  */
	category_length = strlen(current_specifier_ptr->category2);
	fwrite((char *)&category_length,sizeof(category_length),1,fp1);
	fwrite((char *)(current_specifier_ptr->category2),category_length+1,1,fp1);

	/*  WRITE TRANSITION INTERVALS TO FILE  */
	fwrite((char *)&(current_specifier_ptr->number_of_t_intervals),sizeof(int),1,fp1);
	current_t_interval = current_specifier_ptr->t_intervalHead;
	for (j = 0; j < current_specifier_ptr->number_of_t_intervals; j++) {
	    fwrite((char *)&(current_t_interval->proportional),sizeof(short int),1,fp1);
	    fwrite((char *)&(current_t_interval->regression),sizeof(short int),1,fp1);
	    fwrite((char *)&(current_t_interval->duration.ival),sizeof(int),1,fp1);
	    fwrite((char *)&(current_t_interval->rise),sizeof(float),1,fp1);
	    fwrite((char *)&(current_t_interval->slope_ratio),sizeof(float),1,fp1);
	    
	    current_t_interval = current_t_interval->next;
	}

	/*  WRITE TRANSITION INTERVAL MODE TO FILE  */
	fwrite((char *)&(current_specifier_ptr->t_interval_mode),sizeof(short int),1,fp1);

	/*  WRITE SPLIT MODE TO FILE  */
	fwrite((char *)&(current_specifier_ptr->split_mode),sizeof(short int),1,fp1);

	/*  WRITE SPECIAL EVENTS TO FILE  */
	fwrite((char *)&(current_specifier_ptr->number_of_special_events),sizeof(int),1,fp1);
	current_se_ptr = current_specifier_ptr->specialEventHead;
	for (j = 0; j < current_specifier_ptr->number_of_special_events; j++) {
	    /*  WRITE SPECIAL EVENT SYMBOL TO FILE  */
	    fwrite((char *)&(current_se_ptr->symbol),SYMBOL_LENGTH_MAX+1,1,fp1);
	    /*  WRITE SPECIAL EVENT INTERVALS TO FILE  */
	    current_se_interval_ptr = current_se_ptr->se_intervalHead;
	    for (k = 0; k < current_specifier_ptr->number_of_t_intervals; k++) {
		/*  WRITE SUB-INTERVALS TO FILE  */
		fwrite((char *)&(current_se_interval_ptr->number_of_sub_intervals),
		       sizeof(int),1,fp1);
		current_sub_interval_ptr = current_se_interval_ptr->sub_intervalHead;
		for (l = 0; l < current_se_interval_ptr->number_of_sub_intervals; l++) {
		    /*  WRITE SUB-INTERVAL PARAMETERS TO FILE  */
		    fwrite((char *)&(current_sub_interval_ptr->proportional),
			   sizeof(short int),1,fp1);
		    fwrite((char *)&(current_sub_interval_ptr->duration.ival),
			   sizeof(int),1,fp1);
		    fwrite((char *)&(current_sub_interval_ptr->rise),
			   sizeof(float),1,fp1);

		    /*  UPDATE SUB-INTERVAL POINTER  */
		    current_sub_interval_ptr = current_sub_interval_ptr->next;
		}

		/*  UPDATE SPECIAL EVENT INTERVAL POINTER  */
		current_se_interval_ptr = current_se_interval_ptr->next;
	    }
	    /*  UPDATE SPECIAL EVENT POINTER  */
	    current_se_ptr = current_se_ptr->next;
	}

	/*  WRITE DURATION RULE INFORMATION TO FILE  */
	fwrite((char *)&(current_specifier_ptr->duration.rule),
	       sizeof(int),1,fp1);
	fwrite((char *)&(current_specifier_ptr->duration.fixed_length),
	       sizeof(int),1,fp1);

	/*  UPDATE SPECIFIER POINTER  */
	current_specifier_ptr = current_specifier_ptr->next;
    }

    return self;
}



- readFromFile:(FILE *)fp1
{
    int i, j, k, l;
    int category_length;
    specifierStructPtr current_specifier_ptr, temp_specifier_ptr;
    t_intervalPtr current_t_interval = NULL, temp_t_interval;
    specialEventStructPtr current_se_ptr = NULL, temp_se_ptr;
    se_intervalPtr current_se_interval_ptr = NULL;
    sub_intervalPtr current_sub_interval_ptr = NULL;
    void free_specialEventStruct();
    specifierStructPtr new_specifierStruct();
    t_intervalPtr new_t_interval();
    specialEventStructPtr new_specialEventStruct();
    se_intervalPtr new_se_interval();
    sub_intervalPtr new_sub_interval();

    /*  FIRST FREE ALL CURRENT SPECIFIER MEMORY, IF NEEDED  */
    current_specifier_ptr = specifierHead;
    for (i = 0; i < number_of_specifiers; i++) {
        /*  FREE ALL DEPENDENT MEMORY  */
        cfree(current_specifier_ptr->category1);
	cfree(current_specifier_ptr->category2);
	/*  FREE ALL TRANSITION INTERVALS  */
	current_t_interval = current_specifier_ptr->t_intervalHead;
	for (j = 0; j < current_specifier_ptr->number_of_t_intervals; j++) {
	    temp_t_interval = current_t_interval;
	    current_t_interval = current_t_interval->next;
	    free(temp_t_interval);
	}
	/*  FREE ALL SPECIAL EVENTS  */
	current_se_ptr = current_specifier_ptr->specialEventHead;
	for (j = 0; j < current_specifier_ptr->number_of_special_events; j++) {
	    temp_se_ptr = current_se_ptr;
	    current_se_ptr = current_se_ptr->next;
	    free_specialEventStruct(temp_se_ptr,current_specifier_ptr);
	}
	/*  FREE SPECIFIER ITSELF  */
	temp_specifier_ptr = current_specifier_ptr->next;
        free(current_specifier_ptr);

	/*  UPDATE SPECIFIER POINTER  */
	current_specifier_ptr = temp_specifier_ptr;
    }
    number_of_specifiers = 0;


    /*  READ FROM FILE  */
    fread((char *)&number_of_specifiers,sizeof(number_of_specifiers),1,fp1);
    specifierHead = NULL;
    for (i = 0; i < number_of_specifiers; i++) {
	if (i == 0) {
	    specifierHead = current_specifier_ptr = new_specifierStruct();
	}
	else {
	    current_specifier_ptr->next = new_specifierStruct();
	    current_specifier_ptr = current_specifier_ptr->next;	    
	}
	current_specifier_ptr->next = NULL;

	/*  READ SPECIFIER CATEGORY #1 FROM FILE  */
	fread((char *)&category_length,sizeof(category_length),1,fp1);
	current_specifier_ptr->category1 = (char *)calloc(category_length+1,sizeof(char));
	fread((char *)(current_specifier_ptr->category1),category_length+1,1,fp1);

	/*  READ SPECIFIER CATEGORY #2 FROM FILE  */
	fread((char *)&category_length,sizeof(category_length),1,fp1);
	current_specifier_ptr->category2 = (char *)calloc(category_length+1,sizeof(char));
	fread((char *)(current_specifier_ptr->category2),category_length+1,1,fp1);

	/*  READ TRANSITION INTERVALS FROM FILE  */
	fread((char *)&(current_specifier_ptr->number_of_t_intervals),sizeof(int),1,fp1);
	current_specifier_ptr->t_intervalHead = NULL;
	for (j = 0; j < current_specifier_ptr->number_of_t_intervals; j++) {
	    if (j == 0) {
		current_specifier_ptr->t_intervalHead = current_t_interval = new_t_interval();
		current_t_interval->previous = NULL;
	    }
	    else {
		current_t_interval->next = new_t_interval();
		current_t_interval->next->previous = current_t_interval;
		current_t_interval = current_t_interval->next;	    
	    }
	    current_t_interval->next = NULL;

	    fread((char *)&(current_t_interval->proportional),sizeof(short int),1,fp1);
	    fread((char *)&(current_t_interval->regression),sizeof(short int),1,fp1);
	    fread((char *)&(current_t_interval->duration.ival),sizeof(int),1,fp1);
	    fread((char *)&(current_t_interval->rise),sizeof(float),1,fp1);
	    fread((char *)&(current_t_interval->slope_ratio),sizeof(float),1,fp1);
	}

	/*  READ TRANSITION INTERVAL MODE FROM FILE  */
	fread((char *)&(current_specifier_ptr->t_interval_mode),sizeof(short int),1,fp1);

	/*  READ SPLIT MODE FROM FILE  */
	fread((char *)&(current_specifier_ptr->split_mode),sizeof(short int),1,fp1);

	/*  READ SPECIAL EVENTS FROM FILE  */
	fread((char *)&(current_specifier_ptr->number_of_special_events),sizeof(int),1,fp1);
	current_specifier_ptr->specialEventHead = NULL;
	for (j = 0; j < current_specifier_ptr->number_of_special_events; j++) {
	    if (j == 0) {
		current_specifier_ptr->specialEventHead = current_se_ptr = 
		    new_specialEventStruct();
	    }
	    else {
		current_se_ptr->next = new_specialEventStruct();
		current_se_ptr = current_se_ptr->next;	    
	    }
	    current_se_ptr->next = NULL;

	    /*  READ SPECIAL EVENT SYMBOL FROM FILE  */
	    fread((char *)&(current_se_ptr->symbol),SYMBOL_LENGTH_MAX+1,1,fp1);
	    /*  READ SPECIAL EVENT INTERVALS FROM FILE  */
	    current_se_ptr->se_intervalHead = NULL;
	    for (k = 0; k < current_specifier_ptr->number_of_t_intervals; k++) {
		if (k == 0) {
		    current_se_ptr->se_intervalHead = current_se_interval_ptr = new_se_interval();
		    current_se_interval_ptr->previous = NULL;
		}
		else {
		    current_se_interval_ptr->next = new_se_interval();
		    current_se_interval_ptr->next->previous = current_se_interval_ptr;
		    current_se_interval_ptr = current_se_interval_ptr->next;	    
		}
		current_se_interval_ptr->next = NULL;

		/*  READ SUB-INTERVALS FROM FILE  */
		fread((char *)&(current_se_interval_ptr->number_of_sub_intervals),
		       sizeof(int),1,fp1);
		current_se_interval_ptr->sub_intervalHead = NULL;
		for (l = 0; l < current_se_interval_ptr->number_of_sub_intervals; l++) {
		    if (l == 0) {
			current_se_interval_ptr->sub_intervalHead = current_sub_interval_ptr = 
			    new_sub_interval();
			current_sub_interval_ptr->previous = NULL;
		    }
		    else {
			current_sub_interval_ptr->next = new_sub_interval();
			current_sub_interval_ptr->next->previous = current_sub_interval_ptr;
			current_sub_interval_ptr = current_sub_interval_ptr->next;	    
		    }
		    current_sub_interval_ptr->next = NULL;

		    /*  READ SUB-INTERVAL PARAMETERS FROM FILE  */
		    fread((char *)&(current_sub_interval_ptr->proportional),
			   sizeof(short int),1,fp1);
		    fread((char *)&(current_sub_interval_ptr->duration.ival),
			   sizeof(int),1,fp1);
		    fread((char *)&(current_sub_interval_ptr->rise),
			   sizeof(float),1,fp1);
		}
	    }
	}
	/*  READ DURATION RULE INFORMATION FROM FILE  */
	fread((char *)&(current_specifier_ptr->duration.rule),
	       sizeof(int),1,fp1);
	fread((char *)&(current_specifier_ptr->duration.fixed_length),
	       sizeof(int),1,fp1);
    }


    /*  RESET DISPLAY  */
    /*  RELOAD LIST INTO BROWSER  */
    [specifierList loadColumnZero];

    /*  DISPLAY NUMBER OF SPECIFIERS  */
    [specifierTotal setIntValue:number_of_specifiers];    

    /*  SCROLL TO FIRST ITEM, SO IT CAN BE SEEN  */
    [[specifierList matrixInColumn:0] scrollCellToVisible:0 :0];

    /*  SELECT THE FIRST ITEM  */
    currentSpecifierPtr = NULL;
    [[specifierList matrixInColumn:0] selectCellAt:0 :0];
    [self specifierBrowserHit:specifierList];

    return self;
}



t_intervalPtr new_t_interval()
{
    return ( (t_intervalPtr) malloc(sizeof(t_interval)) );
}



specifierStructPtr new_specifierStruct()
{
    return ( (specifierStructPtr) malloc(sizeof(specifierStruct)) );
}



specialEventStructPtr new_specialEventStruct()
{
    return ( (specialEventStructPtr) malloc(sizeof(specialEventStruct)) );
}

void free_specialEventStruct(specialEventStructPtr specialEventStruct_ptr, 
			     specifierStructPtr specifier_ptr)
{
    int i;
    se_intervalPtr current_se_interval_ptr, temp_se_interval_ptr;
    void free_se_interval();

    /*  FREE ALL SE INTERVALS FIRST  */
    current_se_interval_ptr = specialEventStruct_ptr->se_intervalHead;
    for (i = 0; i < specifier_ptr->number_of_t_intervals; i++) {
	temp_se_interval_ptr = current_se_interval_ptr;
	current_se_interval_ptr = current_se_interval_ptr->next;
	free_se_interval(temp_se_interval_ptr);
    }

    /*  FREE THE SPECIAL EVENT STRUCT ITSELF  */
    free(specialEventStruct_ptr);
}



se_intervalPtr new_se_interval()
{
    return ( (se_intervalPtr) malloc(sizeof(se_interval)) );
}

void free_se_interval(se_intervalPtr se_interval_ptr)
{
    int i;
    sub_intervalPtr current_sub_interval_ptr, temp_sub_interval_ptr;
    void free_sub_interval();

    /*  FREE ALL SUB-INTERVALS FIRST  */
    current_sub_interval_ptr = se_interval_ptr->sub_intervalHead;
    for (i = 0; i < se_interval_ptr->number_of_sub_intervals; i++) {
	temp_sub_interval_ptr = current_sub_interval_ptr;
	current_sub_interval_ptr = current_sub_interval_ptr->next;
	free_sub_interval(temp_sub_interval_ptr);
    }

    /*  FREE THE SE_INTERVAL ITSELF  */
    free(se_interval_ptr);
}



sub_intervalPtr new_sub_interval()
{
    return ( (sub_intervalPtr) malloc(sizeof(sub_interval)) );
}

void free_sub_interval(sub_intervalPtr sub_interval_ptr)
{
    free(sub_interval_ptr);
}



f_parameterPtr new_f_parameter()
{
    return ( (f_parameterPtr) malloc(sizeof(f_parameter)) );
}


void free_f_parameter(f_parameterPtr f_parameter_ptr)
{
    int i;
    f_intervalPtr current_f_interval_ptr, temp_f_interval_ptr;
    void free_f_interval();

    /*  FREE ALL f_intervals FIRST  */
    current_f_interval_ptr = f_parameter_ptr->f_intervalHead;
    for (i = 0; i < f_parameter_ptr->number_of_f_intervals; i++) {
	temp_f_interval_ptr = current_f_interval_ptr;
	current_f_interval_ptr = current_f_interval_ptr->next;
	free_f_interval(temp_f_interval_ptr);
    }
	
    /*  FREE F_PARAMETER STRUCT ITSELF  */
    free(f_parameter_ptr);
}


f_intervalPtr new_f_interval()
{
    return ( (f_intervalPtr) malloc(sizeof(f_interval)) );
}

void free_f_interval(f_intervalPtr f_interval_ptr)
{
    free(f_interval_ptr);
}

start_timePtr new_start_time()
{
    return ( (start_timePtr) malloc(sizeof(start_timeStruct)) );
}

void free_start_time(start_timePtr start_time_ptr)
{
    free(start_time_ptr);
}
@end
