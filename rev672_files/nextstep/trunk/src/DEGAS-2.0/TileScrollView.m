
/* Generated by Interface Builder */

#import <appkit/ClipView.h>
#import <appkit/NXCursor.h>
#import <appkit/NXImage.h>
#import <stdio.h>
#import <stdlib.h>
#import <math.h>
#import <dpsclient/psops.h>
#import <dpsclient/wraps.h>

#import "TileScrollView.h"
#import "Template.h"
#import "Synthesize.h"
#import "Generate.h"
#import "Rule.h"
#import "PhoneDescription.h"
#import "NXImageView.h"

#import <appkit/Application.h>

@implementation TileScrollView

- initFrame:(NXRect *)theFrame
{
    NXRect tempFrame;
    NXPoint hotSpot;

    /*  DO NORMAL SCROLLVIEW INITIALIZATION  */
    [super initFrame:theFrame];

    /*  SET UPPER AND SIDE TILE DIMENSIONS TO DEFAULTS  */
    upperTileHeight = U_TILE_HEIGHT_DEF;
    lowerTileHeight = L_TILE_HEIGHT_DEF;
    leftTileWidth = LS_TILE_WIDTH_DEF;
    rightTileWidth = RS_TILE_WIDTH_DEF;

    /*  SET TEMP FRAME TO VERY SMALL  */
    tempFrame.size.width = 0.0;
    tempFrame.size.height = 0.0;
    tempFrame.origin.x = 0.0;
    tempFrame.origin.y = 0.0;

    /*  SET BACKGROUND GRAY OF CONTENT VIEW  */
    [self setBackgroundGray:NX_LTGRAY];

    /*  CREATE UPPER TILE CLIPVIEW, TEMPORARILY INVISIBLE  */
    upperTileClipView = [[ClipView alloc] initFrame:&tempFrame];
    [self addSubview:upperTileClipView];
    [upperTileClipView setBackgroundGray:NX_LTGRAY];

    /*  CREATE LOWER TILE CLIPVIEW, TEMPORARILY INVISIBLE  */
    lowerTileClipView = [[ClipView alloc] initFrame:&tempFrame];
    [self addSubview:lowerTileClipView];
    [lowerTileClipView setBackgroundGray:NX_LTGRAY];

    /*  CREATE LEFT TILE CLIPVIEW, TEMPORARILY INVISIBLE  */
    leftTileClipView = [[ClipView alloc] initFrame:&tempFrame];
    [self addSubview:leftTileClipView];
    [leftTileClipView setBackgroundGray:NX_LTGRAY];

    /*  CREATE RIGHT TILE CLIPVIEW, TEMPORARILY INVISIBLE  */
    rightTileClipView = [[ClipView alloc] initFrame:&tempFrame];
    [self addSubview:rightTileClipView];
    [rightTileClipView setBackgroundGray:NX_LTGRAY];

    /*  CREATE CORNER TILE CLIPVIEWS, TEMPORARILY INVISIBLE  */
    corner1ClipView = [[ClipView alloc] initFrame:&tempFrame];
    [self addSubview:corner1ClipView];
    [corner1ClipView setBackgroundGray:NX_LTGRAY];

    corner2ClipView = [[ClipView alloc] initFrame:&tempFrame];
    [self addSubview:corner2ClipView];
    [corner2ClipView setBackgroundGray:NX_LTGRAY];

    corner3ClipView = [[ClipView alloc] initFrame:&tempFrame];
    [self addSubview:corner3ClipView];
    [corner3ClipView setBackgroundGray:NX_LTGRAY];

    corner4ClipView = [[ClipView alloc] initFrame:&tempFrame];
    [self addSubview:corner4ClipView];
    [corner4ClipView setBackgroundGray:NX_LTGRAY];

    /*  SET UP BORDER AND TWO SCROLLERS, SHOULD AUTOMATICALLY RETILE  */
    [self setHorizScrollerRequired:YES];
    [self setVertScrollerRequired:YES];
    [self setBorderType:NX_BEZEL];

    /*  SET CROSS HAIR CURSOR FOR CONTENT VIEW  */
    crosshairCursor = [NXCursor newFromImage:[NXImage newFromSection:"crosshairCursor.tiff"]];
    hotSpot.x = 8.0;  hotSpot.y = 8.0;
    [crosshairCursor setHotSpot:&hotSpot];
    [self setDocCursor:crosshairCursor];

    /*  INITIALIZE IMAGES TO NIL  */
    mainImage = mainImageView = nil;
    upperTileImageView = upperTileImage = nil;
    lowerTileImageView = lowerTileImage = nil;
    leftTileImageView = leftTileImage = nil;
    rightTileImageView = rightTileImage = nil;
    corner3TileImageView = corner3TileImage = nil;
    corner4TileImageView = corner4TileImage = nil;

    /*  INITIALIZE TRACKING TAG TO ZERO  */
    trackingTag = 0;
    return self;
}

- free
{
    [upperTileClipView free];
    [lowerTileClipView free];
    [leftTileClipView free];
    [rightTileClipView free];

    [corner1ClipView free];
    [corner2ClipView free];
    [corner3ClipView free];
    [corner4ClipView free];

    [mainImage free];
    [mainImageView free];
    [upperTileImage free];
    [upperTileImageView free];
    [lowerTileImage free];
    [lowerTileImageView free];
    [leftTileImage free];
    [leftTileImageView free];
    [rightTileImage free];
    [rightTileImageView free];
    [corner3TileImage free];
    [corner3TileImageView free];
    [corner4TileImage free];
    [corner4TileImageView free];

    return [super free];
}



- tile
{
    NXRect tempFrame;

    /*  RESIZE AND ARRANGE SCROLLERS AND CONTENTVIEW AS USUAL  */
    [super tile];

    /*  RESIZE CONTENT VIEW FIRST  */
    [contentView getFrame:&tempFrame];
    tempFrame.origin.x += leftTileWidth;
    tempFrame.size.width -= (leftTileWidth + rightTileWidth);
    tempFrame.origin.y += upperTileHeight;
    tempFrame.size.height -= (upperTileHeight + lowerTileHeight);
    [contentView setFrame:&tempFrame];

    /*  RESIZE UPPER TILE  */
    [contentView getFrame:&tempFrame];
    tempFrame.origin.y -= upperTileHeight;
    tempFrame.size.height = upperTileHeight;
    [upperTileClipView setFrame:&tempFrame];

    /*  RESIZE LOWER TILE  */
    [contentView getFrame:&tempFrame];
    tempFrame.origin.y += tempFrame.size.height;
    tempFrame.size.height = lowerTileHeight;
    [lowerTileClipView setFrame:&tempFrame];

    /*  RESIZE LEFT TILE  */
    [contentView getFrame:&tempFrame];
    tempFrame.origin.x -= leftTileWidth;
    tempFrame.origin.y -= ADJUST;
    tempFrame.size.width = leftTileWidth;
    tempFrame.size.height += (2.0 * ADJUST);
    [leftTileClipView setFrame:&tempFrame];

    /*  RESIZE RIGHT TILE  */
    [contentView getFrame:&tempFrame];
    tempFrame.origin.x += tempFrame.size.width;
    tempFrame.origin.y -= ADJUST;
    tempFrame.size.width = rightTileWidth;
    tempFrame.size.height += (2.0 * ADJUST);
    [rightTileClipView setFrame:&tempFrame];

    /*  RESIZE CORNER1 TILE  */
    [contentView getFrame:&tempFrame];
    tempFrame.origin.x -= leftTileWidth;
    tempFrame.origin.y -= upperTileHeight;
    tempFrame.size.width = leftTileWidth;
    tempFrame.size.height = upperTileHeight - ADJUST;
    [corner1ClipView setFrame:&tempFrame];

    /*  RESIZE CORNER2 TILE  */
    [contentView getFrame:&tempFrame];
    tempFrame.origin.x += tempFrame.size.width;
    tempFrame.origin.y -= upperTileHeight;
    tempFrame.size.width = rightTileWidth;
    tempFrame.size.height = upperTileHeight - ADJUST;
    [corner2ClipView setFrame:&tempFrame];

    /*  RESIZE CORNER3 TILE  */
    [contentView getFrame:&tempFrame];
    tempFrame.origin.x -= leftTileWidth;
    tempFrame.origin.y += (tempFrame.size.height + ADJUST);
    tempFrame.size.width = leftTileWidth;
    tempFrame.size.height = lowerTileHeight - ADJUST;
    [corner3ClipView setFrame:&tempFrame];

    /*  RESIZE CORNER4 TILE  */
    [contentView getFrame:&tempFrame];
    tempFrame.origin.x += tempFrame.size.width;
    tempFrame.origin.y += (tempFrame.size.height + ADJUST);
    tempFrame.size.width = rightTileWidth;
    tempFrame.size.height = lowerTileHeight -  ADJUST;
    [corner4ClipView setFrame:&tempFrame];

    return self;
}



- scrollClip:aClipView to:(NXPoint *)aPoint
{
    NXPoint colOrigin;
    NXRect colBounds;

    /*  DON'T DO ANYTHING IF IT'S NOT THE CONTENTVIEW  */
    if (aClipView != contentView) {
	return self;
    }
    
    /*  TURN OFF DRAWING (TO THE SCREEN)  */
    [window disableFlushWindow];
    
    /*  SCROLL THE CONTENTVIEW TO THE NEW ORIGIN  */
    [aClipView rawScroll:aPoint];
    
    /*  COMPUTE NEW ORIGIN FOR leftTileClipView (DON'T LET IT SCROLL HORIZONTALLY) */
    [leftTileClipView getBounds:&colBounds];
    colOrigin.y = aPoint->y;
    colOrigin.x = colBounds.origin.x;
    /*  SCROLL THE leftTileClipView TO THAT POINT  */
    [leftTileClipView rawScroll:&colOrigin];
    
    /*  COMPUTE NEW ORIGIN FOR rightTileClipView (DON'T LET IT SCROLL HORIZONTALLY) */
    [rightTileClipView getBounds:&colBounds];
    colOrigin.y = aPoint->y;
    colOrigin.x = colBounds.origin.x;
    /*  SCROLL THE rightTileClipView TO THAT POINT  */
    [rightTileClipView rawScroll:&colOrigin];
    
    /*  COMPUTE NEW ORIGIN FOR upperTileClipView (DON'T LET IT SCROLL VERTICALLY) */
    [upperTileClipView getBounds:&colBounds];
    colOrigin.x = aPoint->x;
    colOrigin.y = colBounds.origin.y;
    /*  SCROLL THE upperTileClipView TO THAT POINT  */
    [upperTileClipView rawScroll:&colOrigin];
    
    /*  COMPUTE NEW ORIGIN FOR lowerTileClipView (DON'T LET IT SCROLL VERTICALLY) */
    [lowerTileClipView getBounds:&colBounds];
    colOrigin.x = aPoint->x;
    colOrigin.y = colBounds.origin.y;
    /*  SCROLL THE lowerTileClipView TO THAT POINT  */
    [lowerTileClipView rawScroll:&colOrigin];
    
    /*  COMPUTE NEW ORIGIN FOR corner3TileClipView (DON'T LET IT SCROLL AT ALL) */
    [corner3ClipView getBounds:&colBounds];
    colOrigin.x = colBounds.origin.x;
    colOrigin.y = colBounds.origin.y;
    /*  SCROLL THE corner3ClipView TO THAT POINT  */
    [corner3ClipView rawScroll:&colOrigin];
    
    /*  COMPUTE NEW ORIGIN FOR corner4TileClipView (DON'T LET IT SCROLL AT ALL) */
    [corner4ClipView getBounds:&colBounds];
    colOrigin.x = colBounds.origin.x;
    colOrigin.y = colBounds.origin.y;
    /*  SCROLL THE corner4ClipView TO THAT POINT  */
    [corner4ClipView rawScroll:&colOrigin];
    
    /*  SEND RESULTS TO SCREEN  */
    [[window reenableFlushWindow] flushWindow];
    
    return self;
}



- setUpperTileDocView:aView
{
    [upperTileClipView setDocView:aView];
    return self;
}

- upperTileDocView
{
    return [upperTileClipView docView];
}



- setLowerTileDocView:aView
{
    [lowerTileClipView setDocView:aView];
    return self;
}

- lowerTileDocView
{
    return [lowerTileClipView docView];
}



- setLeftTileDocView:aView
{
    [leftTileClipView setDocView:aView];
    return self;
}

- leftTileDocView
{
    return [leftTileClipView docView];
}



- setRightTileDocView:aView
{
    [rightTileClipView setDocView:aView];
    return self;
}

- rightTileDocView
{
    return [rightTileClipView docView];
}



- setCorner3TileDocView:aView
{
    [corner3ClipView setDocView:aView];
    return self;
}

- corner3TileDocView
{
    return [corner3ClipView docView];
}



- setCorner4TileDocView:aView
{
    [corner4ClipView setDocView:aView];
    return self;
}

- corner4TileDocView
{
    return [corner4ClipView docView];
}



- diphoneDisplay:sender
{
    int i;
    NXRect tempFrame;

    int number_of_parameters, number_of_diphones;
    int vscale, hscale;
    int utterance_duration;
    float adjusted_utterance_duration;
    float speed_factor;
    int speed_type;

    filterParamPtr parameterListHead, current_parameter_ptr;
    diphoneListPtr diphoneListHead, current_diphone_ptr;
    char diphone_marker;

    vm_address_t *diphone_page;
    float temp_x, temp_y;
    struct _param {
	float minimum;
	float maximum;
	float old_y;
    };
    typedef struct _param paramType;
    typedef paramType *paramPtr;
    paramPtr param;

    int fontobject_hs, fontobject_hbl;
    float dx, dy;
    float diphone_duration;


    /*  SET UP A MOUSE TRAP FOR EVENTS IN THE CONTENT VIEW  */
    /*  DISCARD OLD TRACKING RECTANGLE IF NECESSARY  */
    if (trackingTag != 0)
	[window discardTrackingRect:1];
    /*  CALCULATE SIZE OF RECTANGLE TO TRACK  */
    [contentView getFrame:&tempFrame];
    [self convertRect:&tempFrame toView:nil];
    /*  SET THE TRACKING RECTANGLE  */
    [window setTrackingRect:&tempFrame inside:NO owner:self tag:1 left:NO right:NO];

    /*  DEFINE FONT OBJECTS  */
    PSfindfont("Helvetica");
    PSscalefont(SMALL_FONT_SIZE);
    fontobject_hs = DPSDefineUserObject(0);

    PSfindfont("Helvetica-Bold");
    PSscalefont(LARGE_FONT_SIZE);
    fontobject_hbl = DPSDefineUserObject(0);
    
    /*  GET NUMBER OF PARAMETERS AND LIST TO DISPLAY  */
    number_of_parameters = [sender numberOfDisplayParameters:&parameterListHead];

    /*  GET VSCALE  */
    vscale = [sender vscale];

    /*  GET DIPHONE MARKER  */
    diphone_marker = [sender diphoneMarker];

    /*  GET NUMBER OF DIPHONES AND LIST TO DISPLAY  */
    number_of_diphones = [sender numberOfDisplayDiphones:&diphoneListHead];

    /*  SET UP VM TO WRITE DIPHONES ON  */
    diphone_page = (vm_address_t *)calloc(number_of_diphones,sizeof(vm_address_t));
    for (i = 0; i < number_of_diphones; i++)
	vm_allocate(task_self(),(vm_address_t *)&diphone_page[i],vm_page_size,1);

    /*  WRITE DIPHONES TO VM  */
    current_diphone_ptr = diphoneListHead;
    for (i = 0; i < number_of_diphones; i++) {
	[rule writeDiphone:current_diphone_ptr->symbol1:current_diphone_ptr->symbol2
	          :[rule governingRule:current_diphone_ptr->symbol1:current_diphone_ptr->symbol2]
	          :(filterParamPtr)parameterListHead
                  :(FILE *)NULL:(vm_address_t)diphone_page[i]];
	current_diphone_ptr = current_diphone_ptr->next;
    }

#if 0
    /*  PRINT OUT DIPHONES  */
    for (i = 0; i < number_of_diphones; i++) {
	int j, k, number_of_intervals;
	int temp_i;
	float temp_f;
	int *page_offset_i;
	float *page_offset_f;

	/*  TOP OF PAGE  */
	page_offset_i = (int *)diphone_page[i];
	page_offset_f = (float *)diphone_page[i];
	printf("\nDIPHONE PAGE %-d\n",i);

	number_of_intervals = *(page_offset_i++);
	page_offset_f = (float *)page_offset_i;
	printf(" number_of_intervals = %-d\n",number_of_intervals);

	temp_i = *(page_offset_i++);
	page_offset_f = (float *)page_offset_i;
	printf(" total duration = %-d\n",temp_i);

	for (j = 0; j < number_of_intervals; j++) {
	    temp_i = *(page_offset_i++);
	    page_offset_f = (float *)page_offset_i;
	    printf("  interval[%-d]  duration = %-d  ",j,(temp_i & 0x7FFFFFFF));
	    temp_f = *(page_offset_f++);
	    page_offset_i = (int *)page_offset_f;
	    printf("regression = %f",temp_f);
            if (temp_i & 0x80000000)
		printf("  SE\n");
	    else
		printf("\n");
	    for (k = 0; k < number_of_parameters; k++) {
		temp_f = *(page_offset_f++);
		page_offset_i = (int *)page_offset_f;
		printf("   param[%-d] = %f\n",k,temp_f);
	    }
	}
    }
#endif

    /*  GET TOTAL DURATION OF UTTERANCE  */
    utterance_duration = 0;
    for (i = 0; i < number_of_diphones; i++) {
	int temp_i;
	int *page_offset_i;

	page_offset_i = (int *)diphone_page[i];
	temp_i = *(page_offset_i++);
	temp_i = *(page_offset_i++);
	utterance_duration += temp_i;
    }

    /*  GET SPEED FACTOR  */
    speed_factor = [sender speedFactor];

    /*  GET SPEED TYPE  */
    speed_type = [sender speedType];

    /*  ADJUST UTTERANCE DURATION  */
    adjusted_utterance_duration = (float)utterance_duration/speed_factor;

    /*  GET HSCALE  */
    hscale = [sender hscale];

    /*  CALCULATE SIZE OF MAIN IMAGE;  MIN. SIZE IS THAT OF CONTENTVIEW  */
    [contentView getFrame:&tempFrame];
    mainImageSize.height = (number_of_parameters * (vscale + PARAM_SEP)) + PARAM_SEP;
    if (mainImageSize.height < tempFrame.size.height)
	mainImageSize.height = tempFrame.size.height;
    mainImageSize.width = adjusted_utterance_duration * hscale;
    if (mainImageSize.width < tempFrame.size.width)
	mainImageSize.width = tempFrame.size.width;

    /*  CALCULATE SIZE OF UPPER TILE IMAGE;  MIN. WIDTH IS THAT OF CONTENTVIEW  */
    upperTileImageSize.height = upperTileHeight;
    upperTileImageSize.width = mainImageSize.width;

    /*  CALCULATE SIZE OF LOWER TILE IMAGE;  MIN. WIDTH IS THAT OF CONTENTVIEW  */
    lowerTileImageSize.height = lowerTileHeight;
    lowerTileImageSize.width = mainImageSize.width;

    /*  CALCULATE SIZE OF LEFT TILE IMAGE;  MIN. HEIGHT IS THAT OF CONTENTVIEW  */
    leftTileImageSize.height = mainImageSize.height + (2.0 * ADJUST);
    leftTileImageSize.width = leftTileWidth;

    /*  CALCULATE SIZE OF RIGHT TILE IMAGE;  MIN. HEIGHT IS THAT OF CONTENTVIEW  */
    rightTileImageSize.height = mainImageSize.height + (2.0 * ADJUST);
    rightTileImageSize.width = rightTileWidth;

    /*  CALCULATE SIZE OF CORNER3 TILE IMAGE  */
    corner3TileImageSize.height = lowerTileHeight - ADJUST;
    corner3TileImageSize.width = leftTileWidth;

    /*  CALCULATE SIZE OF CORNER4 TILE IMAGE  */
    corner4TileImageSize.height = lowerTileHeight - ADJUST;
    corner4TileImageSize.width = leftTileWidth;

    /*  FREE ALL PREVIOUS DISPLAY IMAGES (setDocView FREES VIEW ITSELF)  */
    [mainImage free];
    [upperTileImage free];
    [lowerTileImage free];
    [leftTileImage free];
    [rightTileImage free];
    [corner3TileImage free];
    [corner4TileImage free];

    /*  ALLOCATE UPPER TILE IMAGE, INITIALIZE TO PROPER SIZE, AND SET DOC VIEW  */
    upperTileImage = [[NXImage alloc] initSize:&upperTileImageSize];
    upperTileImageView = [[NXImageView alloc] initSize:&upperTileImageSize Image:upperTileImage];
    [self setUpperTileDocView:upperTileImageView];

    /*  ALLOCATE LOWER TILE IMAGE, INITIALIZE TO PROPER SIZE, AND SET DOC VIEW  */
    lowerTileImage = [[NXImage alloc] initSize:&lowerTileImageSize];
    lowerTileImageView = [[NXImageView alloc] initSize:&lowerTileImageSize Image:lowerTileImage];
    [self setLowerTileDocView:lowerTileImageView];

    /*  ALLOCATE LEFT TILE IMAGE, INITIALIZE TO PROPER SIZE, AND SET DOC VIEW  */
    leftTileImage = [[NXImage alloc] initSize:&leftTileImageSize];
    leftTileImageView = [[NXImageView alloc] initSize:&leftTileImageSize Image:leftTileImage];
    [self setLeftTileDocView:leftTileImageView];

    /*  ALLOCATE RIGHT TILE IMAGE, INITIALIZE TO PROPER SIZE, AND SET DOC VIEW  */
    rightTileImage = [[NXImage alloc] initSize:&rightTileImageSize];
    rightTileImageView = [[NXImageView alloc] initSize:&rightTileImageSize Image:rightTileImage];
    [self setRightTileDocView:rightTileImageView];

    /*  ALLOCATE CORNER3 TILE IMAGE, INITIALIZE TO PROPER SIZE, AND SET DOC VIEW  */
    corner3TileImage = [[NXImage alloc] initSize:&corner3TileImageSize];
    corner3TileImageView = 
	[[NXImageView alloc] initSize:&corner3TileImageSize Image:corner3TileImage];
    [self setCorner3TileDocView:corner3TileImageView];

    /*  ALLOCATE CORNER4 TILE IMAGE, INITIALIZE TO PROPER SIZE, AND SET DOC VIEW  */
    corner4TileImage = [[NXImage alloc] initSize:&corner4TileImageSize];
    corner4TileImageView = 
	[[NXImageView alloc] initSize:&corner4TileImageSize Image:corner4TileImage];
    [self setCorner4TileDocView:corner4TileImageView];

    /*  ALLOCATE MAIN IMAGE, INITIALIZE TO PROPER SIZE, AND SET DOC VIEW  */
    mainImage = [[NXImage alloc] initSize:&mainImageSize];
    mainImageView = [[NXImageView alloc] initSize:&mainImageSize Image:mainImage];
    [self setDocView:mainImageView];

    /*  DRAW PARAMETER SEPARATORS IN MAIN IMAGE  */
    [mainImage lockFocus];
    PSsetgray(NX_DKGRAY);
    temp_y = 0.0;
    for (i = 0; i < number_of_parameters; i++) {
	PSrectfill(0.0, temp_y, mainImageSize.width, PARAM_SEP);
	temp_y += (PARAM_SEP + vscale);
    }
    /*  FILL IN TOP OF IMAGE */
    PSrectfill(0.0, temp_y, mainImageSize.width, PARAM_SEP);
    temp_y += PARAM_SEP;
    if (temp_y < mainImageSize.height) {
	PSsetgray(5.0/6.0);
	PSrectfill(0.0, temp_y, mainImageSize.width, mainImageSize.height-temp_y);
    }
    [mainImage unlockFocus];

    /*  DRAW IN GRAY, RANGES, PARAMETER NAMES IN LEFT TILE  */
    [leftTileImage lockFocus];
    /*  GRAY TILE  */
    PSsetgray(NX_LTGRAY);
    PSrectfill(0.0,0.0,leftTileImageSize.width,leftTileImageSize.height);
    /*  DRAW IN RIGHT LINE  */
    PSsetgray(NX_BLACK);
    PSsetlinewidth(2.0);
    PSmoveto(leftTileImageSize.width,0.0);
    PSrlineto(0.0,leftTileImageSize.height);
    PSstroke();

    /*  DRAW RANGES, PARAMETER NAMES  */
    temp_y = 0.0 + ADJUST + ((number_of_parameters-1)*(PARAM_SEP+vscale));
    current_parameter_ptr = parameterListHead;
    for (i = 0; i < number_of_parameters; i++) {
	char buffer[64];
	/*  PARAMETER NAME  */
	PSsetfont(fontobject_hbl);
	PSstringwidth(current_parameter_ptr->symbol,&dx,&dy);
	PSmoveto(0.0,(temp_y+PARAM_SEP+(vscale/2.0)));
	PSrmoveto(((leftTileImageSize.width-dx)/2.0),(-LARGE_FONT_SIZE/2.0 + 1.0));
	PSshow(current_parameter_ptr->symbol);
	/*  MINIMUM  */
	PSsetfont(fontobject_hs);
	sprintf(buffer,"%.2f",[template parameterSymMinimum:current_parameter_ptr->symbol]);
	PSstringwidth(buffer,&dx,&dy);
	PSmoveto(leftTileImageSize.width,(temp_y+PARAM_SEP));
	PSrmoveto((-dx-3.0),(-SMALL_FONT_SIZE/2.0 + 1.0));
	PSshow(buffer);
	/*  MAXIMUM  */
	sprintf(buffer,"%.2f",[template parameterSymMaximum:current_parameter_ptr->symbol]);
	PSstringwidth(buffer,&dx,&dy);
	PSmoveto(leftTileImageSize.width,(temp_y+PARAM_SEP+vscale));
	PSrmoveto((-dx-3.0),(-SMALL_FONT_SIZE/2.0 + 1.0));
	PSshow(buffer);
	/*  UPDATE Y  */
	temp_y -= (PARAM_SEP + vscale);
	current_parameter_ptr = current_parameter_ptr->next;
    }
    [leftTileImage unlockFocus];

    [rightTileImage lockFocus];
    /*  GRAY TILE  */
    PSsetgray(NX_LTGRAY);
    PSrectfill(0.0,0.0,rightTileImageSize.width,rightTileImageSize.height);
    /*  DRAW IN LEFT LINE  */
    PSsetgray(NX_BLACK);
    PSsetlinewidth(2.0);
    PSmoveto(0.0,0.0);
    PSrlineto(0.0,rightTileImageSize.height);
    PSstroke();
    [rightTileImage unlockFocus];

    /*  DRAW DIPHONE NAMES IN UPPER TILE  */
    [upperTileImage lockFocus];
    /*  GRAY TILE  */
    PSsetgray(NX_LTGRAY);
    PSrectfill(0.0,0.0,upperTileImageSize.width,upperTileImageSize.height);
    /*  DRAW IN BOTTOM LINE  */
    PSsetgray(NX_BLACK);
    PSsetlinewidth(2.0);
    PSmoveto(0.0,0.0);
    PSrlineto(upperTileImageSize.width,0.0);
    PSstroke();
    /*  DRAW IN DIPHONE NAMES  */
    PSsetfont(fontobject_hbl);
    temp_x = 0.0;
    temp_y = (upperTileHeight - LARGE_FONT_SIZE)/2.0 + 2.0;
    current_diphone_ptr = diphoneListHead;
    for (i = 0; i < number_of_diphones; i++) {
	char buffer[128];
	int temp_i;
	int *page_offset_i;
	float length;
	/*  FIND ADJUSTED LENGTH OF DIPHONE  */
	page_offset_i = (int *)diphone_page[i];
	temp_i = *(page_offset_i++);
	temp_i = *(page_offset_i++);
	length = ((float)(temp_i * hscale))/speed_factor;
	/*  CREATE DIPHONE STRING  */
	sprintf(buffer,"%s%c%s",current_diphone_ptr->symbol1,
	       diphone_marker,current_diphone_ptr->symbol2);
	/*  PRINT DIPHONE STRING IN MIDDLE OF DIPHONE  */
	PSstringwidth(buffer,&dx,&dy);
	PSmoveto((temp_x + (length-dx)/2.0),temp_y);
	PSshow(buffer);
	/*  UPDATE START POINT AND CURRENT DIPHONE  */
	temp_x += length;
	current_diphone_ptr = current_diphone_ptr->next;
    }
    [upperTileImage unlockFocus];

    /*  DRAW CORNER3 TILE  */
    [corner3TileImage lockFocus];
    /*  GRAY TILE  */
    PSsetgray(NX_LTGRAY);
    PSrectfill(0.0,0.0,corner3TileImageSize.width,corner3TileImageSize.height);
    /*  DRAW IN RIGHT LINE FOR STRETCH BOX  */
    PSsetgray(NX_BLACK);
    PSsetlinewidth(2.0);
    PSmoveto(corner3TileImageSize.width,(lowerTileHeight - STRETCHBOX_HEIGHT)/2.0);
    PSrlineto(0.0,STRETCHBOX_HEIGHT);
    PSstroke();
    [corner3TileImage unlockFocus];

    /*  DRAW CORNER4 TILE  */
    [corner4TileImage lockFocus];
    /*  GRAY TILE  */
    PSsetgray(NX_LTGRAY);
    PSrectfill(0.0,0.0,corner4TileImageSize.width,corner4TileImageSize.height);
    /*  DRAW IN LEFT LINE FOR STRETCH BOX  */
    PSsetgray(NX_BLACK);
    PSsetlinewidth(2.0);
    PSmoveto(0.0,(lowerTileHeight - STRETCHBOX_HEIGHT)/2.0);
    PSrlineto(0.0,STRETCHBOX_HEIGHT);
    PSstroke();
    [corner4TileImage unlockFocus];

    /*  DRAW LOWER TILE  */
    [lowerTileImage lockFocus];
    /*  GRAY TILE  */
    PSsetgray(NX_LTGRAY);
    PSrectfill(0.0,0.0,lowerTileImageSize.width,lowerTileImageSize.height);
    /*  DRAW IN UPPER LINE  */
    PSsetgray(NX_BLACK);
    PSsetlinewidth(2.0);
    PSmoveto(0.0,lowerTileImageSize.height);
    PSrlineto(lowerTileImageSize.width,0.0);
    PSstroke();
    /*  DRAW IN "STRETCH BOXES"  */
    /*  CALCULATE COMMON Y COORDINATE  */
    temp_y = (lowerTileHeight - STRETCHBOX_HEIGHT)/2.0;
    /*  GRAY OUT BOX  */
    PSsetgray(5.0/6.0);
    PSrectfill(0.0,temp_y,lowerTileImageSize.width,STRETCHBOX_HEIGHT);
    /*  DRAW IN UPPER AND LOWER LINES OF BOX  */
    PSsetgray(NX_BLACK);
    PSsetlinewidth(1.0);
    PSmoveto(0.0,temp_y);
    PSrlineto(lowerTileImageSize.width,0.0);
    PSmoveto(0.0,(temp_y + STRETCHBOX_HEIGHT));
    PSrlineto(lowerTileImageSize.width,0.0);
    PSstroke();
    /*  FILL IN BOX WHERE STRETCHABLE  */
    temp_x = 0.0;
    PSsetgray(NX_BLACK);
    for (i = 0; i < number_of_diphones; i++) {
	int temp_i, number_of_intervals, j;
	int *page_offset_i;
	float *page_offset_f, temp_f;
	float length, adjusted_length, delta;
	/*  FIND ADJUSTED LENGTH OF DIPHONE  */
	page_offset_i = (int *)diphone_page[i];
	page_offset_f = (float *)page_offset_i;
	number_of_intervals = *(page_offset_i++);
	page_offset_f = (float *)page_offset_i;
	length = (float)(*(page_offset_i++));
	page_offset_f = (float *)page_offset_i;
	adjusted_length = length/speed_factor;
	delta = adjusted_length - length;

	for (j = 0; j < number_of_intervals; j++) {
	    int special_event, k;
	    /*  READ CODED DURATION  */
	    temp_i = *(page_offset_i++);
	    page_offset_f = (float *)page_offset_i;
	    /*  SEE IF SPECIAL EVENT  */
	    special_event = (temp_i & 0x80000000);
	    /*  GET LENGTH IN SAMPLES  */
	    length = (float)(temp_i & 0x7FFFFFFF);
	    /*  GET STRETCH FACTOR  */
	    temp_f = *(page_offset_f++);
	    page_offset_i = (int *)page_offset_f;
	    /*  CALCULATE ADJUSTED LENGTH  */
	    if (speed_type == SPEED_SWITCH_REGRESS)
		adjusted_length = (length + (delta * temp_f)) * hscale;
	    else
		adjusted_length = (length/speed_factor) * hscale;
	    /*  MAKE SURE ADJUSTED LENGTH DOESN'T FALL BELOW MINIMUM  */
	    if (adjusted_length < hscale)
		adjusted_length = hscale;

	    /*  DRAW THE STRETCH BOX, IF STRETCH FACTOR != 0  */
	    if (temp_f != 0.0) {
		PSrectfill(temp_x,temp_y,adjusted_length,STRETCHBOX_HEIGHT);
	    }

	    /*  DUMP RISE VALUES IN BIT BUCKET  */
	    for (k = 0; k < number_of_parameters; k++) {
		temp_f = *(page_offset_f++);  /* careful when using synth, or filter  */
		page_offset_i = (int *)page_offset_f;
	    }
	    /*  CALCULATE X COORDINATE  */
	    temp_x += adjusted_length;
	}
    }
    [lowerTileImage unlockFocus];

    /*  DRAW IN GRID, IF REQUESTED, IN MAIN IMAGE  */
    if ([sender grid]) {
	double min, max, range, unit, scaled_unit, start, y;
	int n = 0;
	/*  SET UP DRAWING  */
	[mainImage lockFocus];
	PSsetgray(NX_LTGRAY);
	PSsetlinewidth(1.0);

	/*  DO GRID FOR EACH PARAMETER  */
	temp_y = PARAM_SEP + ((number_of_parameters-1) * (vscale + PARAM_SEP));
	current_parameter_ptr = parameterListHead;
	for (i = 0; i < number_of_parameters; i++) {
	    /*  FIND MINIMUM AND MAXIMUMS FOR THIS PARAMETER  */
	    min = [template parameterSymMinimum:current_parameter_ptr->symbol];
	    max = [template parameterSymMaximum:current_parameter_ptr->symbol];
	    /*  FIND RANGE  */
	    range = max - min;
	    /*  FIND UNIT SIZE  */
	    n = 0;
	    if (range > 1.0) {
		while (range > 1.0) {
		    range /= 10.0;
		    n++;
		}
		unit = pow(10.0,n-1);
	    }
	    else {
		while (range <= 1.0) {
		    range *= 10.0;
		    n++;
		}
		unit = 1.0 / (pow(10.0,n));
	    }
	    /*  MAKE SURE THERE IS MORE THAN ONE GRID LINE  */
	    if ((unit * 2.0) >= (max - min))
		unit /= 10.0;
	    /*  FIND SCALED UNIT SIZE  */
	    scaled_unit = (vscale * unit) / (max - min);
	    /*  FIND BOTTOM START VALUE  */
	    if (min >= 0.0)
		start = ((int)(min/unit) + 1) * unit;
	    else
		start = ((int)(min/unit)) * unit;
	    if (start <= min)
		start += unit;
	    /*  DRAW LINES  */
	    y = temp_y + (((start - min) / (max - min)) * vscale);
	    while (((temp_y + vscale) - y) > .000001) {
		PSmoveto(0.0,y);
		PSrlineto(mainImageSize.width,0.0);
		y += scaled_unit;
	    }

	    temp_y -= (vscale + PARAM_SEP);
	    current_parameter_ptr = current_parameter_ptr->next;
	}
	PSstroke();
	[mainImage unlockFocus];
    }


    /*  DRAW IN VERTICAL LINES IN MAIN IMAGE  */
    [mainImage lockFocus];
    temp_x = 0.0;
    for (i = 0; i < number_of_diphones; i++) {
	int temp_i, number_of_intervals, j;
	int *page_offset_i;
	float *page_offset_f, temp_f;
	float length, adjusted_length, delta;
	/*  FIND ADJUSTED LENGTH OF DIPHONE  */
	page_offset_i = (int *)diphone_page[i];
	page_offset_f = (float *)page_offset_i;
	number_of_intervals = *(page_offset_i++);
	page_offset_f = (float *)page_offset_i;
	length = (float)(*(page_offset_i++));
	page_offset_f = (float *)page_offset_i;
	adjusted_length = length/speed_factor;
	delta = adjusted_length - length;

	diphone_duration = 0.0;
	for (j = 0; j < number_of_intervals; j++) {
	    int special_event, k;
	    /*  READ CODED DURATION  */
	    temp_i = *(page_offset_i++);
	    page_offset_f = (float *)page_offset_i;
	    /*  SEE IF SPECIAL EVENT  */
	    special_event = (temp_i & 0x80000000);
	    /*  GET LENGTH IN SAMPLES  */
	    length = (float)(temp_i & 0x7FFFFFFF);
	    /*  GET STRETCH FACTOR  */
	    temp_f = *(page_offset_f++);
	    page_offset_i = (int *)page_offset_f;
	    /*  CALCULATE ADJUSTED LENGTH  */
	    if (speed_type == SPEED_SWITCH_REGRESS)
		adjusted_length = (length + (delta * temp_f)) * hscale;
	    else
		adjusted_length = (length/speed_factor) * hscale;
	    /*  MAKE SURE ADJUSTED LENGTH DOESN'T FALL BELOW MINIMUM  */
	    if (adjusted_length < hscale)
		adjusted_length = hscale;
	    /*  UPDATE DIPHONE DURATION  */
	    diphone_duration += adjusted_length;
	    /*  IF FIRST LINE, DRAW THICK DIPHONE DIVIDING LINE  */
	    if (j == 0)
		PSsetlinewidth(2.0);
	    else
		PSsetlinewidth(1.0);
	    /*  IF SPECIAL EVENT, CHANGE COLOR  */
	    if (special_event)
		PSsetgray(NX_LTGRAY);
	    else
		PSsetgray(NX_BLACK);
	    /*  DRAW THE LINE  */
	    PSmoveto(temp_x,0.0);
	    PSrlineto(0.0,mainImageSize.height);
	    PSstroke();
	    /*  DUMP RISE VALUES IN BIT BUCKET  */
	    for (k = 0; k < number_of_parameters; k++) {
		temp_f = *(page_offset_f++);  /* careful when using synth, or filter  */
		page_offset_i = (int *)page_offset_f;
	    }
	    /*  CALCULATE X COORDINATE  */
	    temp_x += adjusted_length;
	}
	/*  SYNTHESIZE OBJECT NEEDS DIPHONE DISPLAY DURATION  */
	[sender setDisplayDuration:diphone_duration for:i];
    }
    /*  DRAW LAST DIPHONE DIVIDING LINE  */
    PSsetgray(NX_BLACK);
    PSsetlinewidth(2.0);
    PSmoveto(temp_x,0.0);
    PSrlineto(0.0,mainImageSize.height);
    PSstroke();
    [mainImage unlockFocus];

    /*  DRAW IN PARAMETER TRACKS IN MAIN IMAGE  */
    /*  ALLOCATE A TEMPORARY Y VARIABLE FOR EVERY PARAMETER  */
    param = (paramPtr)calloc(number_of_parameters,sizeof(paramType));
    [mainImage lockFocus];
    /*  SET LINE WIDTH, AND TO BLACK  */
    PSsetlinewidth(2.0);
    PSsetgray(NX_BLACK);
    temp_x = 0.0;
    current_diphone_ptr = diphoneListHead;
    for (i = 0; i < number_of_diphones; i++) {
	int temp_i, number_of_intervals, j;
	int *page_offset_i;
	float *page_offset_f, temp_f;
	float length, adjusted_length, delta;
	/*  FIND ADJUSTED LENGTH OF DIPHONE  */
	page_offset_i = (int *)diphone_page[i];
	page_offset_f = (float *)page_offset_i;
	number_of_intervals = *(page_offset_i++);
	page_offset_f = (float *)page_offset_i;
	length = (float)(*(page_offset_i++));
	page_offset_f = (float *)page_offset_i;
	adjusted_length = length/speed_factor;
	delta = adjusted_length - length;
	/*  SET INITIAL Y VALUES FOR EACH PARAMETER  */
	temp_y = PARAM_SEP + ((number_of_parameters-1) * (vscale + PARAM_SEP));
	current_parameter_ptr = parameterListHead;
	for (j = 0; j < number_of_parameters; j++) {
	    float y;
	    param[j].minimum = [template parameterSymMinimum:current_parameter_ptr->symbol];
	    param[j].maximum = [template parameterSymMaximum:current_parameter_ptr->symbol];
	    y = [phoneDescriptionObj
	     getTarget:(current_diphone_ptr->symbol1):(current_parameter_ptr->symbol)];
	    param[j].old_y = (((y - param[j].minimum)/(param[j].maximum-param[j].minimum)) *
		              vscale) + temp_y;
	    temp_y -= (vscale + PARAM_SEP);
	    current_parameter_ptr = current_parameter_ptr->next;
	}
	for (j = 0; j < number_of_intervals; j++) {
	    int k;
	    /*  READ CODED DURATION  */
	    temp_i = *(page_offset_i++);
	    page_offset_f = (float *)page_offset_i;
	    /*  GET LENGTH IN SAMPLES  */
	    length = (float)(temp_i & 0x7FFFFFFF);
	    /*  GET STRETCH FACTOR  */
	    temp_f = *(page_offset_f++);
	    page_offset_i = (int *)page_offset_f;
	    /*  CALCULATE ADJUSTED LENGTH  */
	    if (speed_type == SPEED_SWITCH_REGRESS)
		adjusted_length = (length + (delta * temp_f)) * hscale;
	    else
		adjusted_length = (length/speed_factor) * hscale;
	    /*  MAKE SURE ADJUSTED LENGTH DOESN'T FALL BELOW MINIMUM  */
	    if (adjusted_length < hscale)
		adjusted_length = hscale;

	    /*  DRAW LINES FOR EACH PARAMETER  */
	    for (k = 0; k < number_of_parameters; k++) {
		float y;
		temp_f = *(page_offset_f++);  /* careful when using synth, or filter  */
		page_offset_i = (int *)page_offset_f;
		PSmoveto(temp_x,param[k].old_y);
		y = (temp_f / (param[k].maximum - param[k].minimum) ) * vscale;
		PSrlineto(adjusted_length,y);
		param[k].old_y += y;
	    }
	    /*  CALCULATE X COORDINATE  */
	    temp_x += adjusted_length;
	}
	current_diphone_ptr = current_diphone_ptr->next;
    }
    PSstroke();
    [mainImage lockFocus];

    /*  FREE PARAM MEMORY  */
    cfree(param);

    /*  DISPLAY NEW IMAGES  */
    [self display];

    /*  DEALLOCATE DIPHONE PAGES VM  */
    for (i = 0; i < number_of_diphones; i++)
	vm_deallocate(task_self(),diphone_page[i],vm_page_size);

    /*  FREE POINTERS TO PAGES  */
    cfree(diphone_page);

    return self;
}



- mouseEntered:(NXEvent *)e
{
    NXEvent *eventPtr, *nextEventPtr, nextEvent;
    NXPoint mLoc;

    if (![window isKeyWindow])
	return self;

    /*  GET IMMEDIATE MOUSE LOCATION  */
    [window getMouseLocation:&mLoc];

    /*  TRANSLATE POSITION INTO THAT OF CONTENT VIEW  */
    [contentView convertPoint:&mLoc fromView:nil];

    /*  SEND LOCATION TO SYNTHESIZER OBJECT  */
    [synthesize trackMouse:&mLoc];
    
    /*  SET UP MASK SO THAT MOUSE MOVED EVENTS ARE ALSO RECEIVED  */
    [window addToEventMask:NX_MOUSEMOVEDMASK];

    /*  MODAL LOOP  */
    for (;;) {
	/*  GRAB ALL EVENTS;  SEND ALL BUT MOUSE MOVED AND EXITED BACK TO NXApp  */
	eventPtr = [NXApp getNextEvent:NX_ALLEVENTS];
        if ((eventPtr->type != NX_MOUSEMOVED) && (eventPtr->type != NX_MOUSEEXITED))
	    [NXApp sendEvent:eventPtr];

	/*  IF EVENT IS A MOUSEEXITED, EXIT  */
	if (eventPtr->type == NX_MOUSEEXITED)
	    break;

	/*  IF FOLLOWING EVENT IS A MOUSE EXITED, THEN EXIT  */
	nextEventPtr = [NXApp peekNextEvent:(NX_MOUSEMOVEDMASK | NX_MOUSEEXITEDMASK)
		    into:&nextEvent];
        if ((nextEventPtr != NULL) && (nextEventPtr->type == NX_MOUSEEXITED))
	    break;

	/*  IF MOUSE MOVED EVENT, AND STILL KEY WINDOW, CALCULATE MOUSE POSITION  */
	if ((eventPtr->type == NX_MOUSEMOVED) && [window isKeyWindow]) {
	    NXPoint actualPos;

	    actualPos.x = eventPtr->location.x;
	    actualPos.y = eventPtr->location.y;
	    
	    /*  TRANSLATE POSITION INTO THAT OF CONTENT VIEW  */
	    [contentView convertPoint:&actualPos fromView:nil];

	    /*  SEND LOCATION TO SYNTHESIZER OBJECT  */
	    [synthesize trackMouse:&actualPos];
	}
    }
    /*  STOP PROCESSING MOUSE MOVED EVENTS  */
    [window removeFromEventMask:NX_MOUSEMOVEDMASK];

    /*  TELL SYNTHESIZER OBJECT THAT TRACKING IS DONE  */
    [synthesize stopTrackingMouse];

    return self;
}

@end
