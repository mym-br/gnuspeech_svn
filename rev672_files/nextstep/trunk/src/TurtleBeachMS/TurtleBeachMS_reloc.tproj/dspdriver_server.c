/* dspdriver_server.c by David A. Jaffe */

#import <kernserv/kern_server_types.h>
#import <mach/mig_errors.h>
#import <driverkit/i386/ioPorts.h>
#import <driverkit/generalFuncs.h>

#import "dspdriver.h"  /* Generated by MIG */

/* Forward references */
extern boolean_t _dsp_portDeath(port_name_t port);

static port_t devPort = PORT_NULL;

kern_server_t instance;        /* Needed? */

/* Macros for accessing host port via Intel IO ports */
#define BASEIO(_unit) (classVars.driverObjects[_unit]->baseIO)

#define DSPDRIVER_ICR(_unit) (BASEIO(_unit)+0)
#define DSPDRIVER_CVR(_unit) (BASEIO(_unit)+1)
#define DSPDRIVER_ISR(_unit) (BASEIO(_unit)+2) // RO
#define DSPDRIVER_IVR(_unit) (BASEIO(_unit)+3)
// #define UNUSED(_unit) (BASEIO(_unit)+4)
#define DSPDRIVER_DATA_HIGH(_unit) (BASEIO(_unit)+5)
#define DSPDRIVER_DATA_MED(_unit) (BASEIO(_unit)+6)
#define DSPDRIVER_DATA_LOW(_unit) (BASEIO(_unit)+7)

/* ------------------------------------------------------------------- 
 * Interface functions, exported to the user via MIG. 
 * ------------------------------------------------------------------- 
 */
#define EXPORTED 

#define CHECK_OWNER  
/* Undefine this if you want to allow multiple apps to access at once (probably
   a bad idea, but may be useful for debugging 
   */

#ifdef CHECK_OWNER
#define ownerCheck() \
  if ((!classVars.driverObjects[unit]) || (owner_port != classVars.driverObjects[unit]->owner)) return DSPDRIVER_ERROR_NOT_OWNER
#else
#define ownerCheck()
#endif

#define unitCheck() if (unit>=MAX_UNITS || unit<0) return DSPDRIVER_ERROR_BAD_UNIT_OR_DRIVER


/******* Functions required by kern_loader *********************/
EXPORTED void _dsp_init(void) {
    /* Load handler. This gets called before initFromDeviceDescription: */
    // Need this if ever make it a user level driver:   IOInitGeneralFuncs();  
}

EXPORTED void _dsp_signoff(void) {
    /* Unload handler.  Actually, since Driver Kit drivers can't be unloaded,
     * we never do this.
     */
    int i;
    for (i=0; i<MAX_UNITS; i++)
      if (classVars.driverObjects[i])
	classVars.driverObjects[i]->owner = PORT_NULL;
}

EXPORTED boolean_t _dsp_portDeath(port_name_t port) {
  /* This is invoked when the user's owner port dies (e.g. app exited)
   */
    int i;
    for (i=0; i<MAX_UNITS; i++) {
	if (classVars.driverObjects[i]->owner == port) { /* Find it */
	    [classVars.driverObjects[i] resetDSP:1];
	    IOSleep(10); /* 10 ms */
	    [classVars.driverObjects[i] resetDSP:0];
	    classVars.driverObjects[i]->owner = PORT_NULL;
	    return TRUE;
	}
    }
    return FALSE;
}

/******* Managing ownership of the driver ********/
EXPORTED kern_return_t 
  dsp_become_owner(port_t device_port, port_t owner_port, int unit) {
    /* Becoming owner of the driver and initializing time. */
    if (!classVars.driverObjects[unit]) {
	printf("dsp_become_owner failed: device is nonexistant.\n");
	return DSPDRIVER_ERROR_BAD_UNIT_OR_DRIVER;
    }
    if (classVars.driverObjects[unit]->owner) {
	printf("dsp_become_owner failed: device is busy.\n");
	return DSPDRIVER_ERROR_BUSY;
    }
    if (devPort == PORT_NULL) 
      devPort = device_port;
    else if (device_port != devPort) {
	printf("DSP driver error: bad device port??\n");
	return DSPDRIVER_ERROR_UNKNOWN_ERROR;
    }
    classVars.driverObjects[unit]->owner = owner_port;
    return KERN_SUCCESS;
}

EXPORTED kern_return_t 
  dsp_release_ownership(port_t dspdriver_port,port_t owner_port, int unit) {
    /* Releasing ownership of driver. */
    unitCheck(); ownerCheck();
    classVars.driverObjects[unit]->owner = PORT_NULL;
    return KERN_SUCCESS;
}

/******* Functions for getting/setting raw data ********/

EXPORTED kern_return_t
  dsp_get_icr(port_t dspdriver_port,port_t owner_port,char *icr, int unit)
{
    unitCheck(); ownerCheck();;
    *icr = inb(DSPDRIVER_ICR(unit));
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_get_cvr(port_t dspdriver_port,port_t owner_port,char *cvr, int unit)
{
    unitCheck(); ownerCheck();;
    *cvr = inb(DSPDRIVER_CVR(unit));
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_get_isr(port_t dspdriver_port,port_t owner_port,char *isr, int unit)
{
    unitCheck(); ownerCheck();
    *isr = inb(DSPDRIVER_ISR(unit));
    return KERN_SUCCESS;
}


EXPORTED kern_return_t
  dsp_get_ivr(port_t dspdriver_port,port_t owner_port,char *ivr, int unit)
{
    unitCheck(); ownerCheck();
    *ivr = inb(DSPDRIVER_IVR(unit));
    return KERN_SUCCESS;
}


EXPORTED kern_return_t
  dsp_put_icr(port_t dspdriver_port,port_t owner_port,char icr, int unit)
{
    unitCheck(); ownerCheck();
    outb(DSPDRIVER_ICR(unit),icr);
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_cvr(port_t dspdriver_port,port_t owner_port,char cvr, int unit)
{
    unitCheck(); ownerCheck();
    outb(DSPDRIVER_CVR(unit),cvr);
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_ivr(port_t dspdriver_port,port_t owner_port,char ivr, int unit)
{
    unitCheck(); ownerCheck();
    outb(DSPDRIVER_IVR(unit),ivr);
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_get_hi(port_t dspdriver_port,port_t owner_port, int *hiRegs, int unit)
{
    unsigned int v;
    unsigned char icr,ivr,cvr,isr;
    unitCheck(); ownerCheck();
    icr = inb(DSPDRIVER_ICR(unit));
    cvr = inb(DSPDRIVER_CVR(unit));
    isr = inb(DSPDRIVER_ISR(unit));
    ivr = inb(DSPDRIVER_IVR(unit));
    v = icr;
    v = (v << 8) | cvr;
    v = (v << 8) | isr;
    v = (v << 8) | ivr;
    *(unsigned int *)hiRegs = v;
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_data_raw(port_t dspdriver_port,port_t owner_port,char high,
	     char med, char low, int unit)
{
    unitCheck(); ownerCheck();
    outb(DSPDRIVER_DATA_HIGH(unit),high);
    outb(DSPDRIVER_DATA_MED(unit),med);
    outb(DSPDRIVER_DATA_LOW(unit),low);
    return KERN_SUCCESS;
}


EXPORTED kern_return_t
  dsp_get_data_raw(port_t dspdriver_port,port_t owner_port,char *high,
	     char *med, char *low, int unit)
{
    unitCheck(); ownerCheck();
    *high = inb(DSPDRIVER_DATA_HIGH(unit));
    *med = inb(DSPDRIVER_DATA_MED(unit));
    *low = inb(DSPDRIVER_DATA_LOW(unit));
    return KERN_SUCCESS;
}
/******* Functions for higher level interaction ***********/

#define SLEEP_TIME 1 /* ms */
#define TIMEOUT 20 /* ms */

/* Set to printf to see error messages */
#define TPRINTF printf

static int awaitISRMaskAndValue(unsigned char mask,unsigned char value, 
				int unit)
{
    char isr;
    isr = inb(DSPDRIVER_ISR(unit));
    if ((isr & mask) == value)
      return KERN_SUCCESS;
    IODelay(1);           /* 1 us spin */
    isr = inb(DSPDRIVER_ISR(unit)); /* Try again */
    if ((isr & mask) == value)
      return KERN_SUCCESS;
    IODelay(1);           /* 1 us spin */
    isr = inb(DSPDRIVER_ISR(unit)); /* Try again */
    if ((isr & mask) == value) 
      return KERN_SUCCESS;
    IODelay(1);           /* 1 us spin */
    isr = inb(DSPDRIVER_ISR(unit)); /* Try again */
    if ((isr & mask) == value) 
      return KERN_SUCCESS;
    {
      int timeSlept = 0;
      do {
        timeSlept += SLEEP_TIME;
        if (timeSlept > TIMEOUT) {
          TPRINTF("dspdriver: Timed out sleeping waiting for isr&0x%x=0x%x!\n",(int)mask,(int)value);
          return DSPDRIVER_ERROR_TIMEOUT;
        }
//	DPRINTF ("Sleeping waiting for isr&0x%d=0x%d!\n",(int)mask,(int)value);
	IOSleep(SLEEP_TIME);      
	isr = inb(DSPDRIVER_ISR(unit)); /* Try again */
      } while ((isr & mask) != value);
    }
    return KERN_SUCCESS;
}

static inline int awaitISRMask(unsigned char mask, int unit)
{
    return awaitISRMaskAndValue(mask,mask,unit);
}

static int awaitCVRMaskAndValue(unsigned char mask,unsigned char value, 
				int unit)
{
    unsigned char cvr;
    cvr = inb(DSPDRIVER_CVR(unit));
    if ((cvr & mask) == value)
      return KERN_SUCCESS;
    IODelay(1);           /* 1 us spin */
    cvr = inb(DSPDRIVER_CVR(unit)); /* Try again */
    if ((cvr & mask) == value)
      return KERN_SUCCESS;
    IODelay(1);           /* 1 us spin */
    cvr = inb(DSPDRIVER_CVR(unit)); /* Try again */
    if ((cvr & mask) == value) 
      return KERN_SUCCESS;
    {
	int timeSlept = 0;
	do {
	    timeSlept += SLEEP_TIME;
	    if (timeSlept > TIMEOUT) {
		TPRINTF("dspdriver: Timed out sleeping waiting for cvr&0x%x=0x%x!\n",(int)mask,(int)value);
		return DSPDRIVER_ERROR_TIMEOUT;
	    }
//	    DPRINTF ("Sleeping waiting for cvr&0x%d==0x%d.\n",(int)mask,(int)value);
	    IOSleep(SLEEP_TIME);      
	    cvr = inb(DSPDRIVER_CVR(unit)); /* Try again */
	} while ((cvr & mask) != value);
    }
    return KERN_SUCCESS;
}


#define HF3  ((unsigned char) 0x10)
#define HF2  ((unsigned char) 8)
#define TRDY ((unsigned char) 4)  /* In ISR */
#define TXDE ((unsigned char) 2)  /* In ISR */
#define RXDF ((unsigned char) 1)  /* In ISR */

static inline int writeInt(int i, int unit)
{
    unsigned char low = i & 0xff;
    unsigned char med = (i >> 8) & 0xff;
    unsigned char high = (i >> 16);
    if (awaitISRMask(TXDE,unit))
      return DSPDRIVER_ERROR_TIMEOUT;
    outb(DSPDRIVER_DATA_HIGH(unit),high);
    outb(DSPDRIVER_DATA_MED(unit),med);
    outb(DSPDRIVER_DATA_LOW(unit),low);
}

EXPORTED kern_return_t 
  dsp_put_data(port_t dspdriver_port,port_t owner_port,char high,
	       char med, char low, int unit)
  /* Like dsp_put_data_raw but waits for TXDE to be set. */
{
    unitCheck(); ownerCheck();
    if (awaitISRMask(TXDE,unit))
      return DSPDRIVER_ERROR_TIMEOUT;
    outb(DSPDRIVER_DATA_HIGH(unit),high);
    outb(DSPDRIVER_DATA_MED(unit),med);
    outb(DSPDRIVER_DATA_LOW(unit),low);
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_get_data(port_t dspdriver_port,port_t owner_port,char *high,
	       char *med, char *low, int unit)
{
    unitCheck(); ownerCheck();
    if (awaitISRMask(RXDF,unit))
      return DSPDRIVER_ERROR_TIMEOUT;
    *high = inb(DSPDRIVER_DATA_HIGH(unit));
    *med = inb(DSPDRIVER_DATA_MED(unit));
    *low = inb(DSPDRIVER_DATA_LOW(unit));
    return KERN_SUCCESS;
}


EXPORTED kern_return_t
  dsp_put_data_array(port_t dspdriver_port, port_t owner_port, 
		     int *data, unsigned int count, int unit)
{
    int v;
    unitCheck(); ownerCheck();
    while (count--) {
	v = *data++;
	writeInt(v,unit);
    }
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_get_data_array(port_t dspdriver_port, port_t owner_port, int count,
		     int *data, unsigned int *dataCount, int unit)
/* count is what is passed by the user.  
   *dataCount is what we set to say how much we read. 
   Currently, we just always set *dataCount = count;
   */
{
    unsigned char low,med,high;
    int v;
    unitCheck(); ownerCheck();
    *dataCount = count;
    while (count--) {
	if (awaitISRMask(RXDF,unit))
	  return DSPDRIVER_ERROR_TIMEOUT;
	high = inb(DSPDRIVER_DATA_HIGH(unit));
	med = inb(DSPDRIVER_DATA_MED(unit));
	low = inb(DSPDRIVER_DATA_LOW(unit));
	v = high;
	v = (v << 8) | med;
	v = (v << 8) | low;
	*data++ = v;
    }
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_data_byte_array(port_t dspdriver_port, port_t owner_port, 
			  char *data, unsigned int count, int unit)
{
    char low,signExt;
    unitCheck(); ownerCheck();
    while (count--) {
	low = *data++;
	signExt = (low & 0x80) ? 0xFF : 0;
	if (awaitISRMask(TXDE,unit))
	  return DSPDRIVER_ERROR_TIMEOUT;
	outb(DSPDRIVER_DATA_HIGH(unit),signExt);
	outb(DSPDRIVER_DATA_MED(unit),signExt);
	outb(DSPDRIVER_DATA_LOW(unit),low);
    }
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_data_short_array(port_t dspdriver_port, port_t owner_port, 
			   short *data, unsigned int count, int unit)
{
    char low,med,signExt;
    short v;
    unitCheck(); ownerCheck();
    while (count--) {
      v = *data++;
      low = v & 0xff;
      med = v >> 8;
      signExt = (med & 0x80) ? 0xff : 0;
      if (awaitISRMask(TXDE,unit))
	return DSPDRIVER_ERROR_TIMEOUT;
      outb(DSPDRIVER_DATA_HIGH(unit),signExt);
      outb(DSPDRIVER_DATA_MED(unit),med);
      outb(DSPDRIVER_DATA_LOW(unit),low);
    }
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_data_packed_array(port_t dspdriver_port, port_t owner_port, 
			    char *data, unsigned int count, int unit) 
{
    char low,med,high;
    unitCheck(); ownerCheck();
    count /= 3;        /* Count is in bytes */
    while (count--) {
	low = *data++;
	med = *data++;
	high = *data++;
	if (awaitISRMask(TXDE,unit))
	  return DSPDRIVER_ERROR_TIMEOUT;
	outb(DSPDRIVER_DATA_HIGH(unit),high);
	outb(DSPDRIVER_DATA_MED(unit),med);
	outb(DSPDRIVER_DATA_LOW(unit),low);
    }
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_data_left_array(port_t dspdriver_port, port_t owner_port, 
			  int *data, unsigned int count, int unit) 
{
    int v;
    unitCheck(); ownerCheck();
    while (count--) {
	v = *data++;
	v >>= 8;      /* Right justify it */
	writeInt(v,unit);
    }
    return KERN_SUCCESS;
}

/************ Special Music Kit Functions ***********/

#define UNTIMED_MESSAGE (-1)

// #import <dsp/dsp.h>
/* Must agree with dsp/dsp.h */
#define DSP_HC_XHM ((0x26>>1))
#define HC ((unsigned char)0x80)

static inline int xhm(int unit)
{
    if (awaitCVRMaskAndValue(HC,0,unit))
      return DSPDRIVER_ERROR_TIMEOUT;
    if (awaitISRMaskAndValue(TRDY|HF2|HF3,TRDY,unit))
      return DSPDRIVER_ERROR_TIMEOUT;
    outb(DSPDRIVER_CVR(unit),HC|DSP_HC_XHM);
    return KERN_SUCCESS;
}

EXPORTED kern_return_t
  dsp_put_mk_timed_message(port_t dspdriver_port,port_t owner_port,
			   int highWord,int lowWord,int opCode, int unit)
{
    unitCheck(); ownerCheck();
    if (highWord != UNTIMED_MESSAGE) {
      writeInt(highWord,unit);
      writeInt(lowWord,unit);
    }
    writeInt(opCode,unit);
    return xhm(unit);
}

EXPORTED kern_return_t
  dsp_exec_mk_host_message(port_t dspdriver_port,port_t owner_port, int unit)
{
    unitCheck(); ownerCheck();
    return xhm(unit);
}

/************ Other settings ************************/

EXPORTED kern_return_t
  dsp_reset_chip(port_t dspdriver_port,port_t owner_port,char resetOn, 
	 	 int unit)
{
    unitCheck(); ownerCheck();
    [classVars.driverObjects[unit] resetDSP:resetOn];
    return KERN_SUCCESS;
}



// added by len
#import "addons.c"
// end addition
