
/* Generated by Interface Builder */

#import "Controller.h"
#import <appkit/appkit.h>
#import <streams/streams.h>
#import <TextToSpeech/TextToSpeech.h>


@implementation Controller

- appDidInit:sender
{
    /*  TRY TO INSTANTIATE TEXT-TO-SPEECH OBJECT  */
    mySpeaker = [[TextToSpeech alloc] init];
    if (mySpeaker == nil) {
	NXRunAlertPanel ("Cannot connect",
			 "Too many clients, or TTS_server cannot be started.",
			 "OK", NULL, NULL);
	exit(0);
    }
    return self;
}

- appWillTerminate:sender
{
    /*  FREE TEXT-TO-SPEECH OBJECT;  FREES UP A CLIENT SLOT  */
    [mySpeaker free];
    return self;
}



- setSpeedButton:sender
{
    [outputField setIntValue:[mySpeaker setSpeed:[inputField floatValue]]];
    return self;
}

- speedButton:sender
{
    [outputField setFloatValue:[mySpeaker speed]];
    return self;
}



- setElasticityButton:sender
{
    [outputField setIntValue:[mySpeaker setElasticity:[inputField intValue]]];
    return self;
}

- elasticityButton:sender
{
    [outputField setIntValue:[mySpeaker elasticity]];
    return self;
}



- setIntonationButton:sender
{
    [outputField setIntValue:[mySpeaker setIntonation:[inputField intValue]]];
    return self;
}

- intonationButton:sender
{
    [outputField setIntValue:[mySpeaker intonation]];
    return self;
}



- setVoiceTypeButton:sender
{
    [outputField setIntValue:[mySpeaker setVoiceType:[inputField intValue]]];
    return self;
}

- voiceTypeButton:sender
{
    [outputField setIntValue:[mySpeaker voiceType]];
    return self;
}



- setPitchOffsetButton:sender
{
    [outputField setIntValue:[mySpeaker setPitchOffset:[inputField floatValue]]];
    return self;
}

- pitchOffsetButton:sender
{
    [outputField setFloatValue:[mySpeaker pitchOffset]];
    return self;
}



- setVolumeButton:sender
{
    [outputField setIntValue:[mySpeaker setVolume:[inputField floatValue]]];
    return self;
}

- volumeButton:sender
{
    [outputField setFloatValue:[mySpeaker volume]];
    return self;
}



- setBalanceButton:sender
{
    [outputField setIntValue:[mySpeaker setBalance:[inputField floatValue]]];
    return self;
}

- balanceButton:sender
{
    [outputField setFloatValue:[mySpeaker balance]];
    return self;
}



- setDictionaryOrderButton:sender
{
    short order[4];
    char *c_ptr;
    int i;

    /*  GET THE INPUT STRING  */
    c_ptr = (char *)[inputField stringValue];

    /*  GET NEXT FOUR NUMBERS  */
    for (i = 0; i < 4; i++)
	order[i] = (short)strtol(c_ptr, &c_ptr, 0);

    /*  SEND ORDER TO TTS OBJECT, DISPLAY RETURN VALUE  */
    [outputField setIntValue:[mySpeaker setDictionaryOrder:order]];

    return self;
}

- dictionaryOrderButton:sender
{
    const short int *order;
    char buffer[64];

    /*  GET ORDER FROM SERVER  */
    order = [mySpeaker dictionaryOrder];

    /*  FORMAT AND DISPLAY  */
    sprintf(buffer,"%-d  %-d  %-d  %-d",order[0],order[1],order[2],order[3]);
    [outputField setStringValue:buffer];

    return self;
}



- setAppDictPathButton:sender
{
    [outputField setIntValue:[mySpeaker setAppDictPath:[inputField stringValue]]];
    return self;
}

- appDictPathButton:sender
{
    [outputField setStringValue:[mySpeaker appDictPath]];
    return self;
}



- setUserDictPathButton:sender
{
    [outputField setIntValue:[mySpeaker setUserDictPath:[inputField stringValue]]];
    return self;
}

- userDictPathButton:sender
{
    [outputField setStringValue:[mySpeaker userDictPath]];
    return self;
}



- speakTextButton:sender
{
    [outputField setIntValue:[mySpeaker speakText:[inputField stringValue]]];
    return self;
}

- speakStreamButton:sender
{
    NXStream *stream;

    /*  MEMORY MAP SPECIFIED INPUT FILE TO MEMORY STREAM  */
    if ((stream = NXMapFile([inputField stringValue], NX_READONLY)) == NULL) {
	[outputField setStringValue:"Cannot find or read specified file."];
	return self;
    }

    /*  SPEAK MEMORY STREAM  */
    [outputField setIntValue:[mySpeaker speakStream:stream]];

    /*  CLOSE THE MEMORY STREAM, INCLUDING ALL MEMORY IT USES  */
    NXCloseMemory(stream, NX_FREEBUFFER);

    return self;
}

- setEscapeCharacterButton:sender
{
    [outputField setIntValue:[mySpeaker setEscapeCharacter:*[inputField stringValue]]];
    return self;
}

- escapeCharacterButton:sender
{
    char c, buffer[64];

    /*  GET THE ESCAPE CHARACTER  */
    c = [mySpeaker escapeCharacter];

    /*  FORMAT AND DISPLAY  */
    sprintf(buffer,"%c = 0x%-X",c,c);
    [outputField setStringValue:buffer];

    return self;
}

- setBlockButton:sender
{
    [outputField setIntValue:[mySpeaker setBlock:[inputField intValue]]];
    return self;
}

- blockButton:sender
{
    [outputField setIntValue:[mySpeaker block]];
    return self;
}



- pauseImmediatelyButton:sender
{
    [outputField setIntValue:[mySpeaker pauseImmediately]];
    return self;
}

- pauseAfterCurrentWordButton:sender
{
    [outputField setIntValue:[mySpeaker pauseAfterCurrentWord]];
    return self;
}

- pauseAfterCurrentUtteranceButton:sender
{
    [outputField setIntValue:[mySpeaker pauseAfterCurrentUtterance]];
    return self;
}

- continueButton:sender
{
    [outputField setIntValue:[mySpeaker continue]];
    return self;
}

- eraseAllSoundButton:sender
{
    [outputField setIntValue:[mySpeaker eraseAllSound]];
    return self;
}

- eraseAllWordsButton:sender
{
    [outputField setIntValue:[mySpeaker eraseAllWords]];
    return self;
}

- eraseCurrentUtteranceButton:sender
{
    [outputField setIntValue:[mySpeaker eraseCurrentUtterance]];
    return self;
}



- serverVersionButton:sender
{
    [outputField setStringValue:[mySpeaker serverVersion]];
    return self;
}



- dictionaryVersionButton:sender
{
    [outputField setStringValue:[mySpeaker dictionaryVersion]];
    return self;
}

@end
