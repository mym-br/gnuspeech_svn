/*
 *    Filename:	PrDictViewer.m 
 *    Created :	Mon May  4 23:23:27 1992 
 *    Author  :	Vince DeMarco
 *		<vince@whatnxt.cuc.ab.ca>
 *    LastEditDate was "Sat Jun  6 11:31:42 1992"
 *
 *    $Id: PrDictViewer.m,v 1.1 2002-03-21 16:49:51 rao Exp $
 *
 *    $Log: not supported by cvs2svn $
# Revision 2.1  1992/06/10  14:24:04  vince
# *** empty log message ***
#
 */


/* Generated by Interface Builder */

#import "PrDictViewer.h"
#import <appkit/Matrix.h>
#import <appkit/NXBrowser.h>
#import <appkit/NXBrowserCell.h>
#import <appkit/Panel.h>
#import <mach/mach.h>
#import <defaults/defaults.h>

#import "PrEditorApp.h"
#import "PrEditorDocument.h"
#import "PrDict.h"

#import <appkit/nextstd.h>

#import "objc-debug.h"

#define WORDINSPECTORPOS "WordInspectorPosition"

@implementation PrDictViewer

+ initialize
{
    const NXDefaultsVector PrEditorDefaults = {{WORDINSPECTORPOS,"0 0 0 0"},{NULL,NULL}};

    if (self == [PrDictViewer class]){
	NXRegisterDefaults("PrEditor", PrEditorDefaults);
    }
    return self;
}

- init
{
    self = [super init];
    prDictionary = nil;
    return self;
}

- documentChanged
{
    [self loadDict:[[NXApp mainDocument] dictionary]];
    return self;
}

- loadDict:dictionary
{
    DEBUG_METHOD;  

    prDictionary = dictionary;

    if ([viewerPanel isVisible]){
	[viewerPanel disableFlushWindow];
	if (prDictionary){
	    [browser reloadColumn:0]; /* Using reloadColumn here instead of loadColumnZero because
				       * it reloads the column and then reselecting the previously 
				       * selected Cell if it's still in the Matrix
				       */
	}else{
	    [browser loadColumnZero]; /* Workaround, the method loadColumnZero will only
				       * Get called when there are no mainWindows
				       * up on the screen, ie dictionary == nil
				       * when this happens we explicitly get the browser
				       * to reload it self.  What will happen is that the
				       * current contents of the browser will get completely
				       * removed, this is needed because, the browser values
				       * are set with setStringValueNoCopy, so when the current
				       * dictionary is removed, so are pointers from the
				       * Browser into memory for the strings.
				       *
				       * An alternative fix would be in the method
				       * browser:loadCell:atRow:inColumn: change the
				       * setStringValueNoCopy: to setStringValue:
				       */
	}
	[viewerPanel reenableFlushWindow];
	[viewerPanel flushWindow];
    }

    return self;
}

-  dictViewer:sender
{
    const char *theDefault;
    NXRect windowFrame;
    
    DEBUG_METHOD;  
    
    if (!viewerPanel){
	[NXApp loadNibSection:"PrDictViewer.nib" owner:self withNames: NO fromZone:[self zone]];
	/* make the panel a floating panel, for now not sure if this is actually
	 * appropriate
	 */
        [browser reuseColumns:YES];
	/* From the 2.1 AppKit docs 
	 * The NXBrowser method setEnabled: does not work properly with reuseColumns:YES.
	 */
        [browser acceptArrowKeys:YES andSendActionMessages:YES];
	[browser setDoubleAction:@selector(browserDoubleHit:)];
	[browser setMaxVisibleColumns:1];
	[viewerPanel getFrame:&viewerRect];

	if (theDefault = NXGetDefaultValue("PrEditor",WORDINSPECTORPOS)){
	    sscanf(theDefault,"%f %f %f %f",&windowFrame.origin.x,&windowFrame.origin.y,
		   &windowFrame.size.width,&windowFrame.size.height);
	    if (windowFrame.size.width != 0.0){
		[viewerPanel sizeWindow:windowFrame.size.width:windowFrame.size.height];
		[viewerPanel moveTo:windowFrame.origin.x :windowFrame.origin.y];
	    }
	}
	
	[viewerPanel setFloatingPanel:YES];
	[viewerPanel setBecomeKeyOnlyIfNeeded:YES]; 
	[viewerPanel useOptimizedDrawing:YES];
    }
    if (![viewerPanel isVisible]){
	[viewerPanel orderFront:sender];
	[self documentChanged];
    }
    return self;
}

- browserHit:sender
{
    id mainDoc;
    const char *word = [[[sender matrixInColumn:0] selectedCell] stringValue];
    
    DEBUG_METHOD;  
    
    if (word && word[0]){
	mainDoc = [NXApp mainDocument];
	[[mainDoc wordField] setStringValue:word];
	[mainDoc getPronounciationCurrentDict:sender];
    }
    return self;
}

- browserDoubleHit:sender
{
    [NXApp sendAction:@selector(speakWord:) to:nil from:sender];
    return self;
}

/* Browser Delgation Methods */
- (int)browser:sender getNumRowsInColumn:(int)column
{
    if (prDictionary != nil){
	return (int)[prDictionary count];
    }
    return 0;
}

- browser:sender loadCell:cell atRow:(int)row inColumn:(int)column
{
    [cell setStringValueNoCopy: [prDictionary valueAtPos: row]];
    [cell setLeaf:YES];
    return self;
}

/* Window Delegation Methods */
- windowWillResize:sender toSize:(NXSize *)frameSize
{
    /* Now i don't have to change the min size here when i change the size
     * of the Window in Interface Builder
     * Isn't this much cleaner?
     */
    frameSize->width  = MAX(frameSize->width, viewerRect.size.width);
    frameSize->height = MAX(frameSize->height,viewerRect.size.height);
    return self;
}

- windowDidUpdate:sender
{
    NXRect windowFrame;
    char theDefault[50];
   
    [sender getFrame: &windowFrame];
    /* The -2 and -32 are there to take into account the size of the window resize
     * buttons. Yeah i know this is a hack, but what can i do about it?
     * It would be nice if getFrame: returned something more meaningfull
     */

    sprintf(theDefault,"%.0f %.0f %.0f %.0f", windowFrame.origin.x,windowFrame.origin.y,
	    windowFrame.size.width-2,windowFrame.size.height-32);
    NXWriteDefault("PrEditor",WORDINSPECTORPOS,theDefault);

    return self;
}

@end
